<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据可视化 - 经典的图表分析]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20-%20%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[柱状图 Bar Chart - 比较其中一个轴表示需要对比的分类维度，另一个轴代表相应的数值。 柱状图描述的是分类数据，回答的是每一个分类中“有多少？”这个问题。 类别 纵向柱状图：&lt;12条数据，类别最好使用不同颜色表示 横向柱状图：&lt;30条数据 适合场景 - 类别对比适合应用到分类数据对比。 不适合场景 分类太多不适合使用纵向柱状图。 不适合表示趋势 对比 柱状图适合多个类别的大小、数值对比 折线图用于连续数值(时间)或有序分类的变化趋势 饼图展示分类占比情况 南丁格尔玫瑰图通过半径比较，柱状图通过矩形长度比较 折线图 Line chart - 趋势显示数据在一个连续的时间间隔或者时间跨度上的变化，它的特点是反映事物随时间或有序类别而变化的趋势。 适合的场景例子：有序的因变量，比如：时间。 折线图可以很好地表现数据递减、增减的速率、增减的规律、峰值等特征。 不适合的场景当水平轴的数据类型为无序的分类或者垂直轴的数据类型为连续时间时，不适合使用折线图。 当折线的条数过多时不建议将多条线绘制在一张图上，可以控制仅显示一条线来解决这个问题。 对比 - 折线图和面积图 折线图和面积图都可以表示一段时间（或者有序分类）的趋势，相比之下面积图的表现力更强一些 面积图还可以表示数据的上下限，例如可以表示温度的最小值、最大值 层叠面积图：河流图，清晰的反应每个数值所占百分比随时间或类别变化的趋势线 饼图 -优点： 显示部分到整体的关系 熟悉的形状 缺点： 难以阅读，因为它更容易区分长度差异而不是角度差异 它很容易被滥用 因为人类大脑可以更容易地比较长度而不是角度。 适合的场景例子1: 展示 2 个分类的占比情况。 例子2：多个但不超过 9 个分类的占比情况。 不适合的场景例子1：分类过多的场景。推荐使用横向柱状图。 例子2: 分类占比差别不明显的场景 对比 - 饼图和南丁格尔玫瑰图 饼图通过弧度的大小来对比数据。 南丁格尔图通过半径的大小来对比数据。 直方图 Histogram - 分布形状类似柱状图却有着与柱状图完全不同的含义。直方图牵涉统计学的概念，首先要对数据进行分组，然后统计每个分组内数据元的数量。 首先要对数据进行分组，然后统计每个分组内数据元的数量。 在平面直角坐标系中，横轴标出每个组的端点，纵轴表示频数，每个矩形的高代表对应的频数，称这样的统计图为频数分布直方图。 类别 非标准的直方图：纵轴表示数量 频数分布直方图：纵轴为频数 适合的场景 - 数据分布 用于表示分布情况 用于观察异常或孤立数据 不适合的场景抽取的样本数量过小，将会产生较大误差，可信度低，也就失去了统计的意义。因此，样本数不应少于 50 个。 直方图与柱状图对比 柱状图是以矩形的长度表示每一组的频数或数量，其宽度(表示类别)则是固定的，利于较小的数据集分析。 直方图是以矩形的长度表示每一组的频数或数量，宽度则表示各组的组距，因此其高度与宽度均有意义，利于展示大量数据集的统计结果。 由于分组数据具有连续性，直方图的各矩形通常是连续排列，而柱状图则是分开排列。 ###]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化 - 经典的图表分析]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20-%20D3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[柱状图 Bar Chart - 比较]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发和研究合集]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%BC%80%E5%8F%91%E4%B8%8E%E7%A0%94%E7%A9%B6%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[包括研究项目和开发的APP。（更新ing） 研究项目合集自由探索——面向分类的感知驱动的可视化监督降维方法成绩：自由探索项目，预计4月-5月投稿TVCG。（负责人） 背景：有标签的高维数据大数据时代，涌现出无数复杂的有标签的高维数据：如手写数据、汽车数据、人脸数据等。 困难：难以分析标签HD数据降维是分析有标签的高维数据的常用方法。 高维数据的低维表示可以帮助用户探索有标签数据中类的分离程度和数据的空间分布。 非监督降维方法PCA：没有考虑类的分离程度；监督降维方法LDA：事先假设数据符合高斯分布，对于复杂的类结构无效；感知驱动降维PDD：单个投影可能会导致重要的类结构被忽略。 方法：三个步骤本文提出了一种感知驱动的线性降维方法，寻求生成具有最大视觉分离程度、最少数量的最优二维投影集合。 （1）子空间表达：对于类别两两之间利用分离度量求最优分离向量，然后利用仿射空间在各个维度上找出在这个度量上能够达到分离度量阈值的范围，各个维度上的范围构成了一个包围盒。 （2）子空间求交：包围盒如果有交集，则代表它们之间可以用一条向量进行区分。 我们将包围盒看做点，两个包围盒有交，则在对应的点之间连边，若存在一个完全图，则代表这些包围盒所代表的点对都可以用一条向量进行区分，用最少数量的团对这张图进行覆盖，这些团就对应了最少数量的包围盒集合。 （3）组合优化：我们取包围盒的中心所对应的向量作为投影的坐标轴，将坐标轴进行组合，得到最少数量的投影集合。 困难1：发现单个视图降维方法的不足一开始构建单个视图，发现类别多的时候无法构建 目标函数：为了最大化非线性目标函数dDSC。优化方法：使用模拟退火算法，通过比较随机生成的投影结果的costFuction，找出全局最优值。得到最优的投影结果展示分类数据。 发现：真实数据中可能存在很多类，如服装数据包括：睡衣、风衣、内衣等各种内容。 困难2：算法不可行。子空间表达目标其实就是找到：既能满足两个类别类内密集，类间最大的子空间。用于下一步两两求交。 原方法：几何的方式优化。 1）【保证A\B自己类内很密集】得到使方差很小的Pa、Pb两个子空间 通过特征分解，已经得到了前k小的方差的向量组成的子空间，向着各个方向偏转直至度量值到达无法分离两个类。此时得到了一个可分子空间，使用矩阵表示。 2）【保证同时满足A\B类内很密集】子空间相交。 关于如何求解子空间的交，使得： 将特征子空间中的特征向量带入，联立方程组，可以解出基础解系w Va ∩ Vb = w 3）【满足类内密集且类间距离最大】 该特征项就是两个类别中心的连线——蓝色部分，单位化后为橙色 ：v_{dist} = u_a-u_b 然而，如何结合使得两类距离最大的向量vec和使A\B都满足类间距离小的子空间Sab是一个问题。 此时就想到了现在的解决方法——将向量投射到n-1维的仿射空间使用包围盒求交。 基于 kNN Graph的内蕴特征抽取可视分析背景高维数据(High-Dimensional Data)，是指向每个数据有多个属性的数据。现实世界中的高维数据中的样本点，往往是分布在一个或者多个低维度的非线性的流形结构之中，如何找出隐藏在高维数据中的低维结构与特征是目前我们所面临的问题。 特征抽取是获取数据特征的重要方式。分为线性和非线性方式，线性提取方式是简单的原始维度线性组合，用户根据自己的喜好选择正向负向的点；非线性为点选绘制自由曲线，产生一个贴合用户认知的非线性模型的内蕴特征轴。 选取点对、选取点序列、画自由曲线等三种指定内蕴轴的交互式方法 例子图 5-3(a)表示了全球生活质量形状趋势(图中箭头方向)，按照其趋势绘制自由曲线，将在散点图中得到新的坐标轴，图 5-3(b)显示了直方图和河流图。 趋势：在图中可看出从左到右,正向的指数降低,如购买力指数(蓝色)，安全指数(浅蓝色)，和医疗指数(橙色)，而负向指数增加，如交通通勤时间指数(浅绿色)和污染指数(红色)，随着X 轴增加，国家生活质量下降，该轴代表了生活质量下降的趋势。 异常：卢旺达，购买力低，然而，安全与卫生保健较高，印证了它是非洲排名第一的国家，政府效率高的信息。委内瑞拉购买力低远远低于其他国家，发现其正面临经济危机的。 有 698 个图像和 4096 个维度，每个维度都表示为一个像素值。为了方便可视化，数据预处理，使用 PCA 将维数减少到 35 维。 节点-链接布局呈现了一个圈的形状(图 5-4(a))。用户想知道圆圈的方向是否为全局模式。于是，他沿着圆的方向画了一条自由的线，但是发现有脸部姿势和光线的两个变化，同时他注意到交互绘制的草图的中心部分只呈现出左右姿势变换。他决定探索这个圈的主要部分。首先，他沿着第一个主要方向画了草图 (在图(a)的红色路径)， 生成的轴显示了从左到右脸部姿势的变化(对应图 5-4(c)中的 x 轴)。接着，他沿着第 二个主要方向 (图 5-4(a)中的绿色路径)绘制了自由曲线，所构造的轴是脸部从上到 下的姿势变化(对应图(c)中的 y 轴)。最后，他沿着其余部分绘制自由曲线(图(a))，改方向表征了光线由暗到明的变化。 高维数据中的低维结构的可视探索成绩：并推荐可视化顶级刊 TVCG。非学生一作，负责user study和对比试验。 问题：高维数据集中往往含有不同结构的低维结构，当未知数据集中的低维结构与当前的可视化方法的假设不匹配时，可视化结果将难以理解。 解决：可视分析方法帮助用户有效地识别低维结构及关键特征，为进一步分析提供关键结构信息。 方法：t-SNE初步提供初始聚类信息：当我们想对高维数据集进行分类，但又不清楚这个数据集有没有很好的可分性（同类之间间隔小、异类之间间隔大）时，可以通过t-SNE将数据投影到2维或3维空间中观察一下：如果在低维空间中具有可分性，则数据是可分的；如果在低维空间中不可分，则可能是因为数据集本身不可分，或者数据集中的数据不适合投影到低维空间。 局部切空间-测地距离视图用来发现子空间 2个滚石图拐点为子空间维度 考勤管理系统成绩：中南大学学报审稿中，EI期刊。负责需求设计： 主页面： 细节视图： 成员当日考勤部分： 个人多日考勤细节以及交互： 考勤统计视图： APP项目合集编码工具： Xcode 10.1，Swift 4.2，UIKit 设计工具：Adobe Inllustrator， 设计icon ， 生成icon 第三工具：移动端火热数据库 Realm，天气API等 思路来源：平时喜欢在APP store里面下载一些独立开发者的APP。这些APP部分思路来自于优秀的APP（如羡辙-2019字体日历、素记 等），部分是自己生活需要的简单小功能。 代码方面：大部分使用了Storyboard，UI设计需要；纯手写代码在 每日一个swift小程序内 开源项目：暂未整理完成 上架中： Project : Todos 极简事项 需求分析：iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 技术： 数据存储：先学习了userDefault，再改为时下火热的移动端数据库Realm存储数据 TableView 具体实现 Project : Weather 元气天气 需求分析：让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 技术： 页面传值 第三方库管理器 具体实现 Project 3 : Quizzler 奇怪问答 需求分析：该问答APP可以修改为任意主题的答题APP。目前想法是改为数据结构基础知识的APP，因为我自己可以用该APP为了实习面试而刷题。 技术： SVM模式 题库存储：realm移动端数据库 具体实现 Project 4 : Piano 木琴 按下不同的按键，发出不同的音调。 Project 3 : Dicee 麻将骰子模拟器 技术： 具体实现 Project 2 : Magic 8 Ball 问答魔力球 Project 1 : 计时器 技术： SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 具体实现]]></content>
      <categories>
        <category>可视分析</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>可视分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - APP合集]]></title>
    <url>%2F2019%2F03%2F09%2FAPP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[合集简介编码工具： Xcode 10.1，Swift 4.2，UIKit 设计工具：Adobe Inllustrator， 设计icon ， 生成icon 第三工具：移动端火热数据库 Realm，天气API等 思路来源：平时喜欢在APP store里面下载一些独立开发者的APP。这些APP部分思路来自于优秀的APP（如羡辙-2019字体日历、素记 等），部分是自己生活需要的简单小功能。 代码方面：大部分使用了Storyboard，UI设计需要；纯手写代码在 每日一个swift小程序内 开源项目：暂未整理完成 上架中： Project : Todos 极简事项 需求分析：iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 技术： 数据存储：先学习了userDefault，再改为时下火热的移动端数据库Realm存储数据 TableView 具体实现 Project : Weather 元气天气 需求分析：让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 技术： 页面传值 第三方库管理器 具体实现 Project 3 : Quizzler 奇怪问答 需求分析：该问答APP可以修改为任意主题的答题APP。目前想法是改为数据结构基础知识的APP，因为我自己可以用该APP为了实习面试而刷题。 技术： SVM模式 题库存储：realm移动端数据库 具体实现 Project 4 : Piano 木琴 按下不同的按键，发出不同的音调。 Project 3 : Dicee 麻将骰子模拟器 技术： 具体实现 Project 2 : Magic 8 Ball 问答魔力球 Project 1 : 计时器 技术： SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 具体实现]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 5 任务清单APP]]></title>
    <url>%2F2019%2F03%2F08%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%2F</url>
    <content type="text"><![CDATA[项目介绍需求分析TableViewController 增加任务 删除任务 修改任务 需求遇到的困难知识点 项目布局UI设计页面一页面二源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F03%2F07%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%204%20%E5%85%83%E6%B0%94%E5%A4%A9%E6%B0%94APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 本程序共分为三个页面：欢迎页面，天气预览界面，城市天气查询界面。 需求天气预览界面：定位天气展示【1 获取当前经纬度位置 2 根据位置获取天气、城市信息 3将信息展示在视图】 城市天气查询界面：用户查询天气【1展示当前城市 2输入框输入查询城市的名称 3按下查询按钮-获取名称至页面1，销毁页面2 】 采用了MVC模式model部分负责数据，我们构建天气类，属性包括：温度、城市、condition，以及计算属性——icon、words，他们需要根据condition属性来确定。比如晴天对于icon为小太阳、文字对于“天晴是你的心情”。 controller负责两个页面中的业务逻辑：从model中取数据，然后返回给view。 最终在view上展示所需天气及其文字信息。 遇到的困难页面跳转传值页面跳转传值部分。【功能：按页面1右上角按钮，跳转到页面二，页面二展示当前city；用户输入目标city，按查询后跳转回页面一，展示查询city的天气信息】 segue导航正向传值较容易，3步骤。1在prepare函数部分获取segue的identifier【转换箭头】，2使用as!强制转化，实例化该segue的destination页面vc，3使用实例化的vc进行传值。这样就可以在下一个页面使用本页面中的“所在城市”的信息了。 而反向传值就不同。如果采用control+drag方式，从页面二的button到页面一加上转换箭头，这样只会再重新生成新的页面一，定位到本地天气；而不是预想的回到原先页面，重新展示所搜索城市的信息。 所以需要自定义protocol，使用delegate实现导航的反向传值。 在页面二需要：3个步骤来自定义协议portocol，实现【按下查找城市按钮，获取输入的city值】的功能。 1自定义协议，安排协议中的方法（获取输入的city，传给页面一），2 声明协议属于页面二中的delegate变量 3规定在哪里触发协议中的事件。 在页面一种需要：3个步骤来实现协议，实现【获取页面二中city的值，并展示于本页面】的功能。 1遵守协议 2 实现协议中的方法（获取city值，根据值获取温度对象的所有信息，展示与本页面）3 第二个页面vc的事件函数委托delegate给self实现。 获取当前位置的天气1 委托本页面，实现定位协议中的请求位置的方法，获得经纬度。（难点） 2 根据经纬度信息，使用Alamofire请求API来获取天气数据； 3 利用SwiftJSON解析生成数据； 4 给weather对象赋值； 5 再使用weather对象中的天气、文字信息更新页面。 – 使用了定位协议CLLocationManagerDelegate的方法。 1 遵守定位协议 2 实例化定位管理器CLLocationManager 3 实现协议中的方法（获取当前的经纬度）4locationManager委托本页面 当manager请求位置的时候，则系统自动调用manager方法，在该方法里获得经纬度。 知识点protocol-delegate：类似java中的接口与实现协议——工具间，协议中的方法——工具，实例化的对象——老板，本页面self——打工仔，委托——老板让打工仔干活 计算属性model中的计算属性——compute属性 某个属性需要根据另一个属性来确定，我们定义其为计算属性 如根据天气情况属性——晴天，得到对应的icon和words：icon为小太阳、wors为“天晴是你的心情”。 第三方库的CocoaPods安装的使用Alamofire：完成http请求天气数据 SwiftJSON：解析、生成数据 extension代码优化目的：提高代码可读性。为日后重构代码打下了良好的基础。 场景：1 私有的辅助函数 ；2 遵守协议（实现某个协议的方法放到一个 extension 中）；3 模型（Model用结构体， 使用extension 将 Model 的 属性 和 基于属性的计算计算属性分离 ） 项目布局UI设计 页面一创建项目的时候需要取消左右旋转 背景图约束： 上下左右相对于View都是0 背景图片填充方式为Aspect Fill拉伸 中间图片 Label 左边自适应 页面二StackView自适应页面的宽度： 选中StackView后control+drag至背景图 是的stackView：页面的比例为2：5 错误：该页面无法到达，需要添加跳转 需要按下按钮，跳转至新的页面：选中按钮，control+drag 至第二页面，选择show（直接跳转）/Present modally（从下往上弹出），生成连接。 启动页面同理自行设计 依赖管理工具CocoaPods介绍 什么是CocoaPods CocoaPods是OS X和iOS下的一个第三类库管理工具，通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 需要第三方库的时候，三个步骤： 0、安装cocoapos 1、command+N导入项目 2、自动创建podfile文件，在该文件写入pod ‘工具包名称’，点击instal下载 3、项目安装配置第三方库完成，点击r.xcworkspace文件进入项目 在CocoaPods中安装第三方库SVProgressHUD 导入 写需要的第三方库，安装 安装配置完成。安装配置过功能包之后，打开项目都是使用Weather.xcworkspace文件 获取经纬度请求用户给予权限的窗口未弹出，报如下错误 原因是：弹框弹出时，需要给到一个描述给用户，说明为什么需要该信息，在info.plist中设置 问题解决： https://swift.gg/2017/02/13/requesting-permissions-core-location-tutorial/ API 使用网络请求功能包Alamofire完成http请求获取天气数据https://study.163.com/course/courseLearn.htm?courseId=1208935831&amp;share=1&amp;shareId=1386037112#/learn/video?lessonId=1278405463&amp;courseId=1208935831 API:应用程序接口(API:Application Program Interface) https://openweathermap.org/api 选择合适的API 根据经纬度获取天气需要的信息 HTTP+字典Dictionary+JSON+第三方功能包SwiftyJSON字典类型：键值对构成 let dict:[String:Any] = [“name”:”zhangsan”,”age”:18] 创建Weather模型+把获取到的数据显示到页面+计算属性初探https://openweathermap.org/weather-conditions 代码优化-把功能块分离出来变成函数+extensionview连接controller+segue导航正向传值+三种as+delegate实现导航的反向传值view连接controller 选择cocoaTouch class，创建controller，选择页面二，建立连接。 segue导航正向传值1、选中转换箭头，设置该转换的id 2、通过在segue的函数中的segue.identifier找到究竟是哪一个【转换箭头】 3、根据转换箭头，使用 sugue.destination 找到箭头的目的地页面 4、使用as!强制转换获取页面vc（实例化的对象） 5、利用vc页面，传值 自定义protocol和delegate实现导航的反向传值页面二：selectCityController 自定义协议，安排了协议的方法 工具属于谁的——页面二中的delegate变量的 规定在哪里触发时间——按下查找城市按钮 页面一：viewController 遵守协议——领取工具 实现协议中规定的方法——去干活。原因：想要用协议的方法，获取里面的参数 委托——指导谁（vc）委托给本页面（self）的 转型——三种as as 向上转型：安全，一般直接使用Int(3.2)，所以不常用 3.2 as Int as? 向下转型：需要判断 if let，若转换不了，得到nil 1if let vc = segue.destination as? SelectCityController as! 向下转型 1let vc = segue.destination as! SelectCityController 完成用户查询天气的功能光标的出现和收起 1234567891011121314 override func viewDidLoad() &#123; super.viewDidLoad() currentCityLabel.text = currentCity //打开本页面，输入框成为第一个响应者，光标显示在输入框 inputCity.becomeFirstResponder() &#125;///该段代码放在退出页面处即可 // 让用户界面在主线程上进行——优先执行 // 经常用于使UI方面的操作提前执行，查询可以慢慢查，我们的键盘先收起来——用户体验更好 DispatchQueue.main.async &#123; // 3.收起键盘 让searchBar失去焦点(光标消失+软件盘收起) self.inputCity.resignFirstResponder() &#125; 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 3 一站到底APP]]></title>
    <url>%2F2019%2F03%2F06%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%203%20%E4%B8%80%E7%AB%99%E5%88%B0%E5%BA%95%20%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析与项目布局需求分析1用户答题——2比对答案——3刷新页面进入下一题 面试介绍首先我来介绍第一个项目——一站到底答题类APP。 其主要业务需求是【1用户答题——2比对答案——3刷新页面进入下一题】 我是使用的是MVC模式开发，保证了项目功能之间的低耦合。 首先我们的数据就是题库，题目类属性为题干和答案。 用户在View上看到题干，选择心中的答案，Controller将获取当前问题答案的请求发送给model，model将答案返回，在Controller与其正确答案比对，正确后计得分并显示在View上，Controller再获取下一个题目的题干和答案，刷新View的题干label和进度条进行下一个题目答题。 在所有题目加载完成后，弹出框显示分数，用户可重新开始游戏。 面向对象编程 OOP类：抽象 对象：具体 初始化方法、构造方法：实例化之后创建一个对象 eg. 类：人——属性：名字、性别 对象：Iris这个人——属性：iris、女 MVC模式控制器从model取得数据，然后返回给view——MVC Model 模型：负责数据找后台数据 View 视图：用户界面Controler控制器：业务逻辑负责传递视图需要表达的信息， 拿到数据后，传到视图 需求：打开微博个人页面，想要查看多少人关注自己 首先传到控制器，发现需要准备数据——关注人数 找到模型要数据 模型准备好数据之后，将数据给Controler，Controler拿到后传给View， 分工明确，高聚合，低耦合 功能实现弹出框 谷歌关键词： alert Apple documentation 方法：UIAlertController 使用第三方库在swift项目中调用objective-C语言的包 下载源码：https://github.com/relatedcode/ProgressHUD 拖入项目中的supporting files的组中 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 2 木琴APP]]></title>
    <url>%2F2019%2F03%2F05%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%202%20%E6%9C%A8%E7%90%B4APP%2F</url>
    <content type="text"><![CDATA[项目介绍按下不同的按键，发出不同的音调。 Tag // 3.1 通过tag获取被按下的buttonlet indexTag = sender.tag 多媒体播放器// 1.引入多媒体播放器import AVFoundation // 2.声明播放器，用于播放url的多媒体文件var player:AVAudioPlayer! // 3.4 将“音频”放入“播放器”player = try AVAudioPlayer(contentsOf: url!) // 3.5 播放音频player.play() url // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: “note(indexTag)”, withExtension: “wav”) 编组：可以帮助项目整理同类型，且不同使用文件，获取文件更方便 抛异常 // 抛异常: 播放器可能为空 do{}catch{print(error)} 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import UIKit// 1.引入多媒体播放器import AVFoundationclass ViewController: UIViewController&#123; // 2.声明播放器，用于播放url的多媒体文件 var player:AVAudioPlayer! // 音频资源 let sounds = ["note1","note2","note3","note4","note5","note6","note7"] override func viewDidLoad() &#123; super.viewDidLoad() &#125; // 3.根据按下的button，播放不同的声音 // 用户按下这个控件sender，按钮 @IBAction func notePressed(_ sender: UIButton) &#123; // 3.1 通过tag获取被按下的button 1-5,下标需要为0-4 let indexTag:Int = sender.tag - 1 // 3.2 播放音频 play(tag:indexTag) &#125; /* 创建一个发出声音的功能函数 输入为第几个声音Int */ func play(tag:Int)&#123; // 1 根据tag不同，获得不同“音频” // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: sounds[tag], withExtension: "wav") // 抛异常: 播放器可能为空 do&#123; // 2 将“音频”放入“播放器” player = try AVAudioPlayer(contentsOf: url!) // 3 播放音频 player.play() &#125;catch&#123; print(error) &#125; &#125;&#125;]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 1 摇色子APP]]></title>
    <url>%2F2019%2F03%2F05%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%201%20%E6%91%87%E8%89%B2%E5%AD%90APP%2F</url>
    <content type="text"><![CDATA[项目介绍点击按钮或者摇晃手机，两个骰子摇晃改变。 UI设计 IBOutlet和IBActionOutlet 插座 ：定义控件 Action 动作 ：控件动作 步骤control 拖拽定义控件IBOutlet和动作IBAction TIPS改名方式需要先断开连接，再修改变量名，再建立连接 否则运行时会抛异常：空指针问题 命名方法文件名 大驼峰 变量名 小驼峰 快捷键command+R:运行 随机数和数组实现图片使用数组存储String类型的图片文件名 随机数获取0-5的数字作为数组下标 将功能放进func函数中，代码更改性更强 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// ViewController.swift// Dicee//// Created by iris on 2019/3/5.// Copyright © 2019 IrisWang. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; // 一、随机数 var index1:Int = 0 var index2:Int = 0 // 二、数组 let diceArray = ["dice1","dice2","dice3","dice4","dice5","dice6"] @IBOutlet weak var diceeImageView1: UIImageView! @IBOutlet weak var diceeImageView2: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 初始的数字也是随机的 updateDiceImage() &#125; @IBAction func rollButton(_ sender: Any) &#123; // 更新骰子 updateDiceImage() &#125; // 三、函数:将功能放进函数中 // 更新骰子函数 func updateDiceImage()&#123; // 1.获取随机数 // 闭区间 0...5 取0-5这几个数 index1 = Int.random(in: 0...5) index2 = Int.random(in: 0...5) // 2.获取数组的某一个 // diceArray[index1] // 3.摇骰子功能 command+R:运行 diceeImageView1.image = UIImage(named: diceArray[index1]) diceeImageView2.image = UIImage(named: diceArray[index2]) &#125;&#125; 摇一摇功能谷歌关键词：shake apple documentation 给出结果：motionEnded 123456// 四、摇一摇功能// 手势结束之后，要进行的行为 motionEndedoverride func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; // 更新骰子 updateDiceImage()&#125; 练习——占卜球]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 7 定制Table Views]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%207%20%E5%AE%9A%E5%88%B6Table%20Views%2F</url>
    <content type="text"><![CDATA[项目简介开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。 12345import UIKitimport Foundationclass RestaurantTableViewController: UITableViewController&#123;//code&#125; 将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码： cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择打钩，且Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。 12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 位置和类型label设置 添加“Type”和“Location”。添加如下两个数组变量： 1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可： 12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 结果： 练习 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 ###]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%206%20%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84Table%20Based%20App%2F</url>
    <content type="text"><![CDATA[项目简介 table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。 出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击到UITableViewDataSource中查看： 1234567891011121314151617public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell's reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different //...&#125; UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有.有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 5 Stack View设计UI]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%205%20Stack%20View%E8%AE%BE%E8%AE%A1UI%2F</url>
    <content type="text"><![CDATA[项目介绍 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 步骤Assets.xcassetsXcode中添加图片 Lable布局用Stack View布局title的label 先拖入两个label。其一修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色；其二修改label的title为“Get help from experts in 15 minutes” 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出两个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label。 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution image布局 拖动三个image view对象。并修改其image属性为user1，user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 组合stack view后添加布局约束 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 选中大的stack view，添加space constraints，上，左右，分别为70，0，0 添加约束后，如果出现布局问题，可通过issue indicator解决：点击问题 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 3 傻瓜式制作APP图标]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%203%20%E5%82%BB%E7%93%9C%E5%BC%8F%E5%88%B6%E4%BD%9CAPP%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用真机测试的效果如下： 设计网址：https://www.canva.cn/ step1 自定义尺寸：1024 x 1024 step2 设计：拖入背景和元素 step3 下载得到png格式的图标 生成图标网址：https://appicon.co/ 将图片拖入网站，选择需要的格式，下载得到zip 解压后得到 图标拖入工程项目中需要各种大小的icon 进入Assets.xcassets的文件夹，删除AppIcon.appiconset文件夹 再将上步解压后的文件夹拖入 消除警告，直接键盘delete删除多余图片即可]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 每日一个Swift小程序]]></title>
    <url>%2F2019%2F03%2F04%2FIOS%E5%BC%80%E5%8F%91%20-%20%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AASwift%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[swift学习日记——每日一个小程序 名称：30DaysofSwift 工具： Xcode 10.1, Swift 4.2, UIKit 思路来源：samvlu ，Allen_朝辉，nimomeng 用例方面：主要参考nimomeng的case，也参考了Sam Lu的40个小项目，也参考了Allen_朝辉的项目 代码方面：前两个项目学习了Storyboard，然而实际上多人协作的项目中我们尽可能少用Storyboard，因为很容易出现冲突问题。况且从学习的角度，storyboard很难说清楚操作步骤是什么。因此以后的项目都尽量手写。 开源项目：暂未整理完成 Project 3 : 计时器 Change Custom Font 学习内容： 具体实现 SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 Project 2 : 改变字体 Change Custom Font 学习内容： 获取字体属性：UIFont.familyNames可以存储为数组，可以直接输出、或通过索引获取 随机获取字体：随机数arc4random()格式为UInt32，需转为Int，再对数组长度取余。获得范围随机数 字体设置：words.font=UIFont(name: “字体名称”, size: 20) 按钮边框设置：圆角cornerRadius，颜色borderColor，该颜色需要CGColor，因此需要将UIColor转为CGColor 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041//// ViewController.swift// ChangeCustomFont//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var words: UILabel! @IBOutlet weak var change: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 按钮的边框粗细、圆角、颜色 // 注：颜色需要CGColor，因此需要将UIColor转为CGColor change.layer.borderWidth = 1; change.layer.cornerRadius = 8; change.layer.borderColor = UIColor.blue.cgColor &#125; // 字体改变：根据随机数，随机获取系统字体的第i个 @IBAction func change(_ sender: Any) &#123; // 1.存储字体名称y为数组 let familyNames_arr = UIFont.familyNames let count:Int = familyNames_arr.count // 2.获取随机数 // 平常的随机数：0 ~ X,UInt32格式，需要转为Int let random1:Int = Int(arc4random()) // 限制长度的随机数，取余 ：0 ~ X let random2:Int = random1 % count // 3.设置字体为第 随机数 的字体 print(familyNames_arr[random2]) words.font=UIFont(name: familyNames_arr[random2], size: 20) &#125;&#125; Project 1 : 加法计算器 Calculation of Add 学习内容： 具体实现 IOS的UI布局：使用Storyboard和其辅助视图添加部件，且为部件定义，加上动作 值的转化：Option获取 -&gt; String -&gt; Float计算 -&gt; String展示]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 4 AutoLayout]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%204%20AutoLayout%2F</url>
    <content type="text"><![CDATA[项目介绍Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag 使用Auto Layout使label到中央Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Control-drag使得label到右下角用control+drag方法来添加spacing constraint。 按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。 所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束 使用Auto Layou\Control-drag使得label水平居中，距离上边40]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习整理 - 未完待续]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%AE%9E%E4%B9%A0%E6%95%B4%E7%90%86%20-%20%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[实习的资料整理。 包括银行、互联网公司。 包括各公司的福利整合。 农业银行截止日期：3.20日申请入口 宣传网页： https://i.eqxiu.com/s/iqd0XQ71?eqrcode=1&amp;share_level=5&amp;from_user=b819b53f-2d44-49e8-aa62-fa07f712a8ef&amp;from_id=c8995d88-6327-45bc-97dc-a4ad26ef27cb&amp;share_time=1551152498524&amp;from=timeline&amp;isappinstalled=0 福利工资17k。公积金5200。 农行总部编制 档案北京管理 北上广天成西 六地即可 扩招截止20年 这两年把握机会 进入顶级国企 全国统一待遇 当地公积金封顶 上海数据中心 部门 免费房子（一辈子） 招商银行时间：3.4-4.7内推网页： https://cmbjob.ccc.cmbchina.com/positionlistshare.html?v=3.0&amp;refereeId=847a71a8-f981-4d7a-abd3-d846ddef0634&amp;refereeCode=674440&amp;recruitType=3&amp;positionClass=&amp;deptId=003 福利180w行员贷款福利 招行有免费房子住的（只有一年） 花旗银行 发简历给HR 微信https://mp.weixin.qq.com/s/Yyxep9M6z525g-c6czt78Q 发简历给HR 快手实习招聘 腾讯时间：提前批3月9日，普招3.31 字节跳动时间：未知。一直在发布岗位，投递后5个工作日内安排面试内推码：6PFRDJMhttps://job.toutiao.com/2018/intern_referral/?token=5lT3rIxuAZuD18qmg3DYlg%3D%3D&amp;key=MjU4NDcsMzE5MTEsMzE5MTQsMzE5MTUsMzE5MTgsMzE5MjMsMzE5MzE%3D&amp;from=groupmessage&amp;isappinstalled=0 深信服时间：未知 华为 其他Google Girl Hackathon报名截止时间：2019年3月6日23:59分 报名： https://mp.weixin.qq.com/s/7H9NBuRYAqNnRciF3m3Cng]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。 UDP 面向无连接流媒体的协议：直播 实时游戏 移动通信领域 TCP 面向连接 分析： 源端口号和目标端口号：数据知道发给哪个应用。 包的序号：那个包先来，那个后来 确认序号：发出去的包应该有确认，无确认再发一次。 状态位：SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。是面向连接的，因而双方要维护连接的状态，这些带状态位的包的的发送，会引起双方的状态变更。 窗口大小：标识自己当前能够的处理能力，让对方根据自己窗口来确定发送速度。 拥塞控制：控制自己发送的快慢。 TCP 的三次握手作用：三次握手除了双方建立连接外，还获取TCP包的序号。 “请求 -&gt; 应答 -&gt; 应答之应答”A：您好，我是 A。 B：您好 A，我是 B。 A：您好 B。 状态时序图： 首先AB都是closed状态。 首先服务器监听某个端口，处于listen状态； 客户端主动发起SYN连接，之后处于SYN-SENT状态； 服务器收到发起的连接，返回SYN，并且ACK确认客户端的SYN连接，此时处于SYN-RECIVED状态； 客户端收到服务器端发起的SYN和ACK之后，发送ACK的ACK就，处于创建状态，一发一收成果了。 服务器端收到ACK之后，处于常见状态。因为其✌也一发一收了。 四次挥手A：B 啊，我不想玩了。 B：哦，你不想玩了啊，我知道了。（半关闭） B：A 啊，好吧，我也不玩了，拜拜。 A：好的，拜拜。 问题都说 TCP 是面向连接的，在计算机看来，怎么样才算一个连接？ 第一个问题:TCP连接是通过三次握手建立连接，四次挥手释放连接，这里的连接是指彼此可以感知到对方的存在，计算机两端表现为socket,有对应的接受缓存和发送缓存，有相应的拥塞控制策略]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合集 - 优秀iOS开发者博客]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%90%88%E9%9B%86%20-%20%E4%BC%98%E7%A7%80iOS%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[onevcat的博客 https://onevcat.com/#blog 唐巧的博客 http://blog.devtang.com/ ibireme的博客 https://blog.ibireme.com/ Kitten的时间胶囊 http://kittenyang.com/ 杨萧玉的博客 http://yulingtianxia.com/ Biso的技术博客 http://allluckly.cn/ 黄玄的博客 http://huangxuan.me Samir Chen的博客 http://www.samirchen.com/ Limboy‘sHQ http://limboy.me/category/tech.html 叶孤城的iOS杂货铺 https://zhuanlan.zhihu.com/zangqilong J_Knight https://knightsj.github.io/archives/ 雷纯峰的技术博客 http://blog.leichunfeng.com/blog/archives/ Halfrost-Field https://halfrost.com/ bang’s blog http://blog.cnbang.net/archives/ MrPeak杂货铺 http://mrpeak.cn/ Casa Taloyum https://casatwy.com/ Bestswifter https://juejin.im/user/57638ad8207703006b06e3ef/posts joy_xx的博客 https://juejin.im/user/5656f11760b28da566412f03/posts 大左的博客 https://draveness.me/index 没故事的卓同学 https://www.jianshu.com/u/88a056103c02 Andy矢倉 http://www.rockerhx.com/archives/ 老谭笔记 http://www.tanhao.me/archives/ 一叶博客 https://00red.com/archives/ 涂鸦的博客 http://www.beyondabel.com/blog/archives/ LeeWong的博客 http://www.leewong.cn/ 作者：海强_hq 链接：https://www.jianshu.com/p/89de5a2d3e63]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的计时器]]></title>
    <url>%2F2019%2F02%2F28%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目介绍 项目完全由代码所写，没有使用storyboard，代码更具有复现性。 手动部分：需要将图片拖入assets 项目知识SnapKit 布局经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达9340颗星。 作者仍然是写Objective-C的第三方库Masonry的大牛 - @Robert Payne。 SnapKit配置1.github下载：https://github.com/SnapKit/SnapKit 2.将下载下来的SnapKit项目的 SnapKit.xcodeproj 拖进自己的项目目录最外层中 3.工程文件 -&gt; General -&gt; Embedded Binaries 中点击加号，添加SnapKit库到项目中来 4.command+B 重新编译项目 SnapKit使用123456789101112131415161718192021import UIKitimport SnapKit class ViewController: UIViewController &#123; // 1.定义box var box = UIView() override func viewDidLoad() &#123; super.viewDidLoad() box.backgroundColor = UIColor.orange // 2.将box加入父视图，之后的布局是相对于父视图布局的 self.view.addSubview(box) // 3. 添加布局的约束：上下左右、中心、 box.snp.makeConstraints &#123; (make) -&gt; Void in make.width.equalTo(100) make.height.equalTo(100) make.center.equalTo(self.view) &#125; &#125;&#125; Timer 计时器初始化1234self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true ,block:&#123; (timer) in // withTimeInterval ： 的值0.1s 时间片后，执行的代码 // repeats : withTimeInterval的时间后，是否继续重复 &#125;) 启动：fire1self.timer.fire() 您可以使用此方法来触发重复计时器，而不会中断其常规的触发计划。 如果计时器不重复 repeats，则在触发后自动失效，即使其预定的触发日期尚未到达。 暂停：invalidate（移除计时循环）1self.timer.invalidate() 官方的解释是： This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes and releases the timer, either just before the invalidate method returns or at some later point. 这是唯一一个把一个定时器从NSRunLoop object运行循环中移除的方法。 NSRunLoop object这个对象移除，并且release掉这个的定时器，或者是在这个invalidate方法返回的之前或是在之后的某个时间段，再进行移除并release操作。 guardguard 打头只判断合理条件，保证判断条件简约 guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 详见 guard详解 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//// ViewController.swift// WatchDemo//// Created by iris on 2019/2/27.// Copyright © 2019 iris. All rights reserved.//// 学习：import UIKitimport SnapKitclass ViewController: UIViewController &#123; var timer:Timer! var resultLabel:UILabel! //计时器：文字显示 var resultNumber:Double = 0 //计时器：时间记录 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 1.计时器的数字显示 // 1.1 数字的背景 let resultView = UIView() resultView.backgroundColor = UIColor.init(red: 0.0, green: 0.0, blue: 0.1, alpha: 1) // 注意：使用snp.makeConstraints方法的元素必须事先添加到父元素的中，例如：self.view.addSubview(view) self.view.addSubview(resultView) resultView.snp.makeConstraints&#123; (make) in make.top.equalTo(0) make.left.equalTo(0) make.height.equalTo(300) // 长度 300 make.width.equalTo(self.view.frame.width) &#125; // 1.2 数字的显示 resultLabel = UILabel() self.view.addSubview(resultLabel) resultLabel.textColor = UIColor.black resultView.addSubview(resultLabel) resultLabel.snp.makeConstraints&#123; (make) in make.center.equalTo(resultView) make.width.height.equalTo(140) make.width.equalTo(400) &#125; resultLabel.font = UIFont.init(name: "Helvetica Neue", size: 60) resultLabel.text = "0.0" resultLabel.textColor = UIColor .white // 设置字体对齐方式 resultLabel.textAlignment = NSTextAlignment.center // 2.开始按钮 // 2.1 开始按钮：背景 let startView = UIView() startView.backgroundColor = UIColor.init(red: 0.1, green: 0.0, blue: 0.8, alpha: 0.8) self.view.addSubview(startView) startView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.left.equalTo(0) make.bottom.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 2.2 开始按钮：布局 let startButton:UIButton = UIButton() // startButton.setTitle("Start", for: UIControl.State.normal) startButton.setImage(UIImage (imageLiteralResourceName: "start"), for: UIControl.State.normal) startView.addSubview(startButton) startButton.snp.makeConstraints &#123; (make) in make.center.equalTo(startView) make.width.height.equalTo(50) &#125; // 2.3 开始按钮：点击事件添加 startButton.addTarget(self, action: #selector(startHander), for: UIControl.Event.touchUpInside) // 3 停止按钮 // 3.1 停止：背景 let stopView:UIView = UIView() stopView.backgroundColor = UIColor.init(red: 0.1, green: 0.8, blue: 0.0, alpha: 0.8) self.view.addSubview(stopView) stopView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.bottom.equalTo(0) make.right.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 3.2 停止：按钮 let stopButton:UIButton = UIButton()// stopButton.setTitle("Stop", for: UIControl.State.normal) stopButton.setImage(UIImage (imageLiteralResourceName: "pause"), for: UIControl.State.normal) stopView.addSubview(stopButton) stopButton.snp.makeConstraints &#123; (make) in make.center.equalTo(stopView) make.width.height.equalTo(50) &#125; // 3.2 停止：按钮事件添加 stopButton.addTarget(self, action: #selector(stopHander), for: UIControl.Event.touchUpInside) // 4 重置 // 4.1 重置按钮 let resetButton:UIButton = UIButton() resetButton.setTitle("Reset", for: UIControl.State.normal) resetButton.titleLabel?.font = UIFont.init(name:"Helvetica Neue",size:20) resultView.addSubview(resetButton) resetButton.snp.makeConstraints &#123; (make) in make.right.equalTo(-10) make.top.equalTo(10) make.width.equalTo(100) make.height.equalTo(50) &#125; // 4.1 重置：事件监听 resetButton.addTarget(self, action: #selector(resetHander), for: UIControl.Event.touchUpInside) &#125; // 3个按钮的事件函数 // 1.开始计时 @objc func startHander()&#123; if self.timer != nil&#123; self.stopHander() &#125; self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true,block:&#123; (timer) in self.resultNumber = self.resultNumber + 0.1 self.resultLabel.text = String(format:"%.1f",self.resultNumber) &#125;) self.timer.fire() &#125; // 2.暂停时间 @objc func stopHander()&#123; // 2.1 不进行判断的方法，可能出现异常，内存可能泄露// var timerForDistory:Timer!// timerForDistory = self.timer// timerForDistory.invalidate() // 2.2 进行判断的方法，可能出现异常，内存可能泄露 // guard 打头只判断合理条件，保证判断条件简约 // guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 guard let timerForDistory = self.timer else &#123; return &#125; timerForDistory.invalidate() &#125; // 3.重置计时器 @objc func resetHander()&#123; self.resultNumber = 0 self.resultLabel.text = "0.0" &#125;&#125;]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的加法计算器swift版本]]></title>
    <url>%2F2019%2F02%2F26%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8swift%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[近日开始学习IOS开发。想找一个简单版本较新的IOS开发教程都很难：（1）现在找的很多都是object-C的，不是swift的，（2）老版与最新版本swift中很多语法也不适配，（3）Xcode版本和用法也不一样。 因此，今天自己写一个最简单的教程，用于swift入门，记录自己的学习。 基础步骤基础步骤就是项目类型、项目名称、项目位置的选取。 1.创建APP 2.项目类型为 简单的view 3.项目名称：加法计算器 4.结果 界面拖拽1、打开故事版，找到UI部件框，搜索需要的部件——输入框、Label、按钮 2、拖拽部件、部件位置布局、部件更名，右边为其结果 3、选择展示设备、选择运行设备、运行程序查看结果 4、运行结果，布局已经实现 功能实现输入框定义1、左右展示storyboard与ViewController文件，用于拖拉式实现部件定义和部件功能添加。 2、方式1：text部件定义，按住control，鼠标拖拽至ViewController对应空白处，接着添加名称以及修改属性。 方式2：输入语句，将代码前的空心点拖拽左边的UITextField @IBOutlet weak var sum: UITextField! 3、定以后的结果如下。 使用方式1拖拽num1，num2定义，使用代码和空心圈绑定至左边UITextField。 按钮功能1、添加Action作为响应 生成如下的代码，我们可以将功能函数写在calculate方法的代码内 2、编写计算的代码和清空的代码 1234567891011121314151617181920212223//计算方法//sum = num1+num2@IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125;//重置方法@IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = ""&#125; 3、结果，可以实现浮点数相加的功能 项目源码ViewController代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//// ViewController.swift// Calculation_add//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; //UITextField的定义 @IBOutlet weak var num1: UITextField! @IBOutlet weak var num2: UITextField! @IBOutlet weak var sum: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; //计算方法 //sum = num1+num2 @IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125; //重置方法 @IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = "" &#125;&#125; 下载资源 CSDN资源https://download.csdn.net/user/katherine_java/uploads]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统下使用Hexo在Github上搭建博客]]></title>
    <url>%2F2019%2F02%2F23%2FMac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、安装环节二、Hexo部署三、github仓库四、git代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的Web服务器搭建]]></title>
    <url>%2F2019%2F02%2F19%2FNode.js%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[服务器搭建 12345//安装服务区npm install http-server -g//启动服务器http-server 打开浏览器，进入指定端口访问： 问题：查看所需端口是否被占用 lsof -i tcp:8080 删除该PID，则该端口号就不会被占用 kill 7826]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具整理 - 设计类工具]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%20-%20%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[设计icon：https://www.canva.cn/ 生成icon：https://appicon.co/ 海报： 阿里矢量图标：https://www.iconfont.cn/ 矢量图标：https://www.easyicon.net/update/ 机器学习：https://mp.weixin.qq.com/s/F_AvAtITyQHWhXgi2K02Ag 快捷键 command+shift+g ：跳出窗口，进入地址 Cammand+i :格式化 简历：]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期实习面试 - 阿里数据中台前端可视化]]></title>
    <url>%2F2019%2F02%2F11%2F%E9%98%BF%E9%87%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[三面准备职业规划这个问题其实我自己在选择保研到可视化方向的时候就有想过。 首先，我认为可视化并不是像别人所说只是展示数据的工具，他可以帮助用户探索到自动化方法分析数据无法发现的的特征和模式。 所以我选择了数据可视分析的方向，在研究生阶段从可视化的算法和理论方面先充实自己。 我的职业规划阶段主要分为三个部分，实习之前、入职1~2年、入职2~5年。 实习之前：我会从把红宝书、犀牛书等书籍刷一遍，在实习之前了解所需前端技术；根据团队的技术路线需要，自己实现一些react框架的项目。争取在实习的时候能够按时按量完成导师给的任务。 入职1~3年内：如果有幸前端可视化方向的顶尖团队。 1工作方面：之前的面试官有说过做工程和论文是不一样的，导师对于学术研究是提出一个新的方法去解决问题，需要在短时间内做出case；而前一位面试官说的是工程需要考虑更多的东西，比如大数据渲染的效率。所以我希望能过接触接触业务，多培养工程能力和工程思维。 2学习方面：非常希望学习一些框架和库。“不要重复的造轮子”这句话，我认为初学者都应该无视，不了解轮子怎么知道这个轮子好不好用呢？我们做论文分析的时候也需要做实验比较算法的优越性。 所以我希望从学习熟练使用轮子开始，到看轮子，理解如何造轮子，如果够厉害的话，或许在业务的实践中自己也能成为造轮子团队的一员。 3爱好方面：工作之余还希望能像字体日记APP的开发者一样，做一些自己喜欢iOS开发。之前在react论坛上看到说阿里有的iOS开发是使用前端技术rn weex，希望学习之后帮助自己的从native开发转变为混合开发——做一些Hybrid APP；或者是做一个针对没有计算机课程的县城中学生的在线教育的前端产品。 3~5应该算一个有经验的前端工程师了：1 数据分析能力、交互视觉能力、研发能力 //3同时努力成为一个一专多长的人才。因为制作一个性能高、交互好、视觉美的页面，需要从前端框架选型、架构设计、构建工具，到后端通信机制、设计与交互、网络和浏览器优化等各方面的知识。 2这时候可以通过发表技术博客，提交和参与开源项目，参加业界会议。保持技术交流。 远期规划：这时候的方向其实很难预估。会根据自身情况去调整。 // 但是我有一个比较梦幻的希望，关于前端的教学产品。 因为我小时候在湘西(沈从文写的边城)那边的一个小县城长大，经济和师资其实比起大城市真的有很大差距，接触计算机是在本科。而我看很多大城市长大的同学都是在高中初中就接触过这些前沿课程了。 我希望能在我有一定的技术和社会资源之后，能够推出面向县城无法接触计算机的学生的，类似极客时间、慕课这类的免费的学习数据结构、编程的前端教学产品。让县城的孩子也能早早接触这个世界的前沿科技。这个除了网页端还可能需要一个安卓端，因为县城的家长大部分用的都是oppo、vivo手机。 更宏大的理想就是可以帮助师资力量非常弱的村镇里面的小学生和乡村教师（我老家那种基本就几个村在一个镇上学，老师也是一个人教2、3门课），全镇购置为每个班计算机设备+投影仪，就可以利用互联网课堂学习基础课程。没有生物化学实验室，可以使用可视化技术在web端模拟实验；地理也可以用3D可视化技术帮助理解。 以上的想法老师您可能觉得比较幼稚，因为这还需要考虑很多课程版权、社会实践等因素。但是这是我作为一个来自少数民族地区学生的一点想法。 谢谢。 你理解的 Web 前端未来的发展我认为随着 HTML、CSS 等的发展，网页上能做的事情越来越丰富了，包括更酷炫的前端呈现方式、音视频的处理，更趋向于能够做 Native 应用能做的事情了，可能以后 Web 和 Native 的边界会越来越模糊。 比如说现在的开发中很多都是用 Hybrid APP。比如微信在钱包里面的理财就是网页，但是基础的聊天、朋友圈都是原生（Native) APP。框架是原生的，但是其他的详细内容就是网页封装。 优势和缺点人其实比较难正确认识自己，但是基于一些师长朋友的评价和日常总结，我觉得我的优点是： 1、可视化背景：虽然我研究的是高维数据可视化，可能初期没有研究交通信息可视化、时序数据可视化的同学的项目更适合于工程。但是现如今很多数据都是高维多元数据，如商品数据、人脸图像数据等。 而直接使用一些很成熟的方法可视化这些高维数据不一定是最好的，我们或许可以从可视化顶级会议IEEE VIS上面去阅读一些新的方法，来试着更新可视化流程、降维方法和交互手段。 2、热爱学习新事物：在Coursera上自习Andrew ng的ML，拿了97分；在Java上面写的小游戏、也会在自学安卓、iOS的时候再写一遍；同时自己对iOS的开发很感兴趣，觉得能推出一些对受众有用的产品就会很酷。后期希望学习混合开发APP。 3、有坚持精神且身体好之前因为每次跨栏只有银牌和铜牌，最后气不过就坚持晨跑，最后终于拿下了金牌。同时坚持锻炼也让我的身体素质很好，可以接受高强度的工作。 4、缺点是：个人爱好有时候比较广泛，如本科时期喜欢爵士舞、话剧、乐器、运动，还喜欢去做学生干部工作，就有一些会影响自己的学习时间，成绩只保持到刚好保研的边缘。但是研究生时候算是改正了一些，只保留了每周去学爵士的兴趣。但是这个缺点我能保证，以后绝对不影响我的工作。 我是如何面试一位前端工程师：https://zhuanlan.zhihu.com/p/30487025 Q1 过去的思考和总结最有难度的事情：项目一自己写论文比跟着导师写难度大多了。基本没两天都会有新的问题出现。然后又要去看论文想方法。 之前面试的总结一面： 主要是表达逻辑的不足，高维数据可视分析科研项目在没有图表支撑的情况下，是比较难描述清楚的。所以我再次整合了逻辑，从背景、目的、方法以及困难三个方面总结了自己的项目。 二面： 把自己项目的逻辑讲的较通顺了。 发现了对图表有时候思考不够深入。 问面试官的问题可以了解一下团队对于实习生的培养吗？如果有幸接到offer后，是否可以联系组内前辈去问一下需要学习哪些技能，因为现在距离暑期实习还有一两个月时间，是否可以预备学习一些组内的必备技能？ 您是我一个位BOSS面的面试官，可以了解一下作为高级前端工程师的一些工作的日常吗？之前总听说架构这些词，但是在校园里面确实没有接触过您这样的高级工程师。谢谢！ 位图和矢量图1.位图图像(bitmap)亦称为点阵图像或绘制图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。 矢量图：矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。 数据中台阿里中台主要由业务中台和数字中台并肩构成了双中台，并肩扛起了所有前台业务。 业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用共享的核心能力，实现了后端业务资源到前台易用能力的转化。 数据中台从后台及业务中台将数据流入，完成海量数据的存储、计算、产品化包装过程，构成企业的核心数据能力，为前台基于数据的定制化创新和业务中台基于数据反馈的持续演进提供了强大支撑。业务中台与数据中台，相辅相成，互相支撑，一起构建起了战场强大的后方炮火群。 二面可视化项目，及相关展开可视化的流程data transformation、visual structure、view transformation + 交互 如果类别多、数据大有遮挡该如何解决？ data transformation： 数据采样 visual structure：已有方式——散点图、三维散点图、平行坐标。我研究的方式——。 view transformation：如果以上方式还是会产生遮挡问题，可以采用一些通道编码，如颜色深浅、透明度、大小——表示该位置的相同类型数据的多少； 热力图、透明度、汇合 交互： 在散点矩阵中使用动画来减轻重叠（Using Animation to Alleviate Overdraw in Multiclass Scatterplot Matrices） 数据预处理——数据缺失和异常缺失值处理：造成数据缺失的原因是多方面的，主要可能有以下几种： 有些信息暂时无法获取，致使一部分属性值空缺出来。 有些信息因为一些人为因素而丢失了。 有些对象的某个或某些属性是不可用的。如一个未婚者的配偶姓名。 获取这些信息的代价太大，从而未获取数据。 空值处理的重要性：空值的存在，造成了以下影响： 系统丢失了大量的有用信息； 系统的不确定性更加显著，系统中的确定性成分更难把握； 包含空值的数据会使挖掘过程陷入混乱，导致不可靠的输出。 空值处理的方法：一、删除元组将存在遗漏信息属性值的对象（记录）删除，从而得到一个完备的信息表。这种方法在对象有多个属性缺失值、被删除的含缺失值的对象与信息表中的数据量相比非常小的情况下是非常有效的。然而这种方法丢弃了大量隐藏在这些对象中的信息。在信息表中对象很少的情况下会影响到结果的正确性，可能导致数据发生偏离，从而引出错误的结论。 二、数据补齐这类方法是基于统计学原理用一定的值去填充空值，从而使信息表完备化。数据挖掘中常用的有以下几种补齐方法： 人工填写这个方法产生数据偏离最小，是填充效果最好的一种。当数据规模很大、空值很多的时候，该方法是不可行的。 特殊值填充将空值作为一种特殊的属性值来处理，它不同于其他的任何属性值。如所有的空值都用“unknown”填充。这样将形成另一个概念，可能导致严重的数据偏离，一般不使用。 平均值填充如果空值是数值属性，就使用该属性在其他所有对象的取值的平均值来填充该缺失的属性值.如果空值是非数值属性，就根据统计学中的众数原理，用该属性在其他所有对象出现频率最高的值来补齐该缺失的属性值。 热卡填充（就近补齐）对于一个包含空值的对象，热卡填充法在完整数据中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。不同的问题选用不同的标准来对相似进行判定。 K最近邻法先根据欧式距离或相关分析来确定距离具有缺失数据样本最近的K个样本，将这K个值加权平均来估计该样本的缺失数据。 使用所有可能的值填充这种方法是用空缺属性值的所有可能的属性取值来填充，能够得到较好的补齐效果。但是当数据量很大或者遗漏的属性值较多时，其计算的代价很大，可能的测试方案很多。 回归基于完整的数据集，建立回归方程（模型）。对于包含空值的对象，将已知属性值代入方程来估计未知属性值，以此估计值来进行填充。 期望值最大化方法（EM）在缺失类型为随机缺失的条件下，假设模型对于完整的样本是正确的，通过观测数据的边际分布可以对未知参数进行极大似然估计。它一个重要前提：适用于大样本。有效样本的数量足够以保证ML估计值是渐近无偏的并服从正态分布。但是这种方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂。 三、不处理——使用深度学习、数据挖掘方式填补直接在包含空值的数据上进行数据挖掘。这类方法包括贝叶斯网络和人工神经网络等。 异常处理异常值的判别方法： 简单统计分析对属性值进行一个描述性的统计（规定范围），从而查看哪些值是不合理的（范围以外的值）。 3δ原则若数据服从正态分布：根据正态分布的定义可知，距离平均值3δ之外的概率为 P(|x-μ|&gt;3δ) &lt;= 0.003 ，这属于极[小概率事件]，在默认情况下我们可以认定，距离超过平均值3δ的样本是不存在的。因此，当样本距离平均值大于3δ，认为该样本为异常值。 使用距离检测多元离群点当数据不服从正态分布时，可以通过远离平均距离多少倍的标准差来判定，多少倍的取值需要根据经验和实际情况来决定。 可视化结果后的判定 异常值的处理方法： 删除含有异常值的记录 将异常值视为缺失值，使用缺失值处理方法来处理 用平均值来修正 不处理 经典可视化图标的优缺点饼图的缺点 玫瑰图的缺点，视觉干扰是什么 场景应用解决分类数据可视化中类别过多、数据量过多的遮挡问题。 数据部分： 可视化部分： 交互部分： 面向对象思维绘制折线图和柱状图的代码大部分相似，可以写在一个类中。 一个平面n个圆有多少个相交的圆1 遍历的方法。时间复杂度较高。 2 对每一个圆计算其变上有多少个交点，交点数除以2就位改圆的相交圆的个数。将所有相交个数加起来除以2(2个圆相交会有一个相交个数，遍历后算了两遍)，结果为一共有多少个相交的圆。 一面t-SNE没回答完整。 高维数据可视分析研究有哪些？ 子空间聚类？ 常问问题Q1：基础知识Q2可视化图表：比如在没写过图表的前提下，怎么抽象数据与图形的映射，怎么去组合不同的图表部件。 要从图表类型的隐喻上进行区分饼图表达的是一个整体和局部的关系，也就是一个部分占据整体的多少比例。柱状图和折线图较为接近，通常前者表示不同对象数据的对比，后者更常用作表示同一对象数据在不同（时间）维度上的趋势。 首先，饼图中的类目不应太多，否则信息很分散，不知道作者想表达什么信息。 其次，饼图的颜色不要五颜六色，除了用以区分类目之外，颜色还可以传递更多有效信息。比如上图用绿色表示正确，灰色表示错误，是符合一般对颜色的认知的，并且绿色的类目更醒目，第一眼就能关注到；相反，如果用普通的三种颜色表示三个类目，则读者很难一眼从图中解读出有效信息。 第三，区分出想表明特定意思的类目。比如上图将正确的类目和错误的类目分隔开，读者很容易抓取到关键信息。 南丁格尔玫瑰图：误导在于，数据的比值为到底是半径比、面积比、还是角度比？ 第一种图将数据映射到半径；第二种图将数据映射到半径和角度；第三将图将数据映射到角度。 何时使用？ Q3前端设计：常问的一个校招问题，有一块区域要展示一组数据，但数据需要请求 3 个接口才能计算得到，请问前端是怎么做的，如何优化，前端什么情况下可以放弃合并接口的要求。这个地方至少会考察到异步，本地缓存，延展下会问下并发，竞态，协程等。 HR面试准备1、为什么想加入这家公司？你需要了解下这家公司的文化和氛围。 2、为什么离开上一家公司？钱少，不能实现梦想，还是有哪些不爽的地方。如果是换工作为了实现梦想，那么你的梦想是什么。不爽的地方如果在新公司再遇到怎么处理。 3、你的职业规划是什么？ 4、当你遇到瓶颈的时候你怎么办？ 5、这些年你每年的成长是什么？怎么能体现你的进步？ 6、谈谈你对阿里的企业文化理解？ 7、你的期望薪资？ 8、项目中遇到的最大挑战是什么？怎么解决的？ 9、最有成就感的事情是？ 10、怎么看待加班（你能接受996、997、007吗）？ 11、说说自己性格上的优缺点（描述一下自己的性格） 12、自己觉得自己工作上的短板/优点是什么？ 13、可以接受降薪吗？ 作者：阅跑影财者 链接：https://www.jianshu.com/p/a1863ef1610f 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历 - 简历要点]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%AE%80%E5%8E%86%20-%20%E7%AE%80%E5%8E%86%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[简历命名除了姓名是一定要有的，最好还有这几个信息：岗位方向、学校、几几届（不是几几级），后两个是针对校招简历 排版排版是简历给面试官的第一印象，正所谓人靠衣装……但是排版其实是需要审美的，有人说那我不会穿衣打扮怎么办，不会打扮不要紧，但是要会打理，可以不会搭配，但是需要打理得干净、整洁、大方，不能给人邋遢的感觉，简历也是这个道理 第一是行间距，不知道大家有没有看过一些简历字迹是挤在一起一坨一坨的，这种情况下，稍稍加大一点行间距，就可以美观很多，单倍行距太小了，1.5倍太宽，一页纸写不下多少东西，比较合适的参考值是1.2和1.25倍 第三是字体，字体可以通篇一致（指中文一致，英文数字一致，并不是中英文都一致），也可以根据分级目录选字体，字体颜色大小粗细都可以根据审美自行调整，但核心还是要整洁大方 第四是标点，尤其注意列项的时候，切忌有的加标点有的没加，还要注意半角全角等 内容个人信息个人信息里面，三项必填的，姓名、电话、邮箱，几项选填的，性别、年龄、学历、所在地、政治面貌等，有些没必要填的，学校专业班级，学校专业可以放在教育经历那一栏，还有，如果有技术博客和GitHub，建议都写上 实习工作经历、项目经验除了公司和时间，重要的是做的是啥，项目经验也是一样，做了啥，才是整个简历面试官想看的主要部分，个人觉得这块可以尝试这么去写，先是简单介绍整体项目，再说一说用到的技术栈，再是自己在项目中的角色，承担的部分，也可以把遇到的最大的挑战、难点写上去，前提是你得想好应对政策，面试的一大套路是让面试官往你铺设的道上走 如果你做的项目很多，挑最熟悉的写，难度最大的，收获成长最多的，这些你有的讲 一般挑两到三个细写就可以了 基本技能这个常规写就好，不要太夸张，也不要太笼统，一句熟悉C、C++、Java，就没有展开了，可以稍微具体一点 获奖经历、科研成果挑重点写，获奖经历最好写含金量比较大的，小规模的比赛其实没必要写，奖学金的话可以写国奖，校级院级的个人觉得也没什么必要，有论文专利之类要写上 自我评价这块其实是最虚的东西，写得好与坏差距挺大的，但基本套话比较多，所以自己衡量 自我评价真的很虚，写得好和坏差距挺大的，如果你觉得写得好的，往上放，这是亮点]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F01%2F06%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%205%20%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析iOS原生风格的极简的日程管理工具。 现有的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打：界面使用iOS原生风格，随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 功能需求浏览任务页面：可以在tableview查看所有任务及其完成状态；可以在编辑状态下批量删除任务、移动任务顺序；按下navigation的+进入添加任务页面；按下&gt;进入修改任务页面。 添加修改页面：判断当前任务是添加还是修改。使用自定义protocol和delegate反向传值，将文字传回浏览页面。 遇到的困难知识点主线程https://www.jianshu.com/p/f042432e2d7d TableView的使用1.我们知道tableView是IOS中的高级视图，其继承与ScrollView，具有ScrollView的功能，还扩展了许多。 2.tableView的表现格式分两种Plain和Grouped两种风格 3.tableView的两种代理类delegate和dataSource.这两种代理至关重要，我们在做tableView和这些代理是分不开的。 4.代理中比较常用的代理方法： (1)dataSource的两个必须使用的代理 显示UITableView的Cell的个数：一共有多少个格子 Cell和model的数据的交互：根据数据，获取每一个数据的值 5.增删改查需要做的：第一步获取需要操作的行数（增加不需要），第二步对数据库进行处理，第三部更新视图 6.更新视图的2种方式：beginUpdates、endUpdates之前操作（如一行一行的删除数据）；tableView.reloadData()刷新TableView了。 在使用数据库之后，我就直接reloadData()刷新TableView了。比较方便 123456// 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() Navigation使用，sugue实现跳转常用控件：相当于一个扑克盒子，里面的页面是出栈和入栈来实现试图切换。 利用segue界面跳转一共有两种方式： 第一种就是以上我的例子，利用button组件，拖拽添加segue，直接运行就可以用。 第二种是利用ViewController与ViewController之间，拖拽添加segue。不过，这种方法就需要在相应需要跳转的方法内写入代码，手动去设置它的跳转。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： 项目布局UI设计页面一页面二步骤配置tableview数据重用单元格的形式，数据成千上万行，最终渲染个数为屏幕上显示的数目。 往下拉的时候，最上面的cell到最下面来，放置重复渲染，提高手机性能。 使用tableview cellCell定一个class为TodoCell，Cell使用as!强制转换为TodoCell。 model结构体使用Struct初探结构体：不需要写初始化构造器，直接可以构造出来；轻量级的class indexPath动态配置每行数据确定位置：第几行indexPath.row、第几段indexPath.session cell切换打勾和取消使用static单元格，grouped风格。 navigation controller压栈(入栈)和出栈navigation controller类似扑克盒子 跳转实现 主页面标题设置为大标题，需要在选中navigation页面，设置大标题 新页面需要设置小标题，添加item当做标题，再修改名称，改为大标题为never 返回按钮的名称需要在页面一的任务清单UINavigationItem中修改 添加任务功能✨流程如下： 使用：(自定义protocol和delegate反向传值)+出栈 添加新任务：反向传值 确定之后页面消失：出栈，navigation老大让他出栈 编辑任务✨1 正向传值segue将选中的cell中的（1 任务文本todo；2选中的行数row）传到编辑页面 2 编辑页面根据输入框判断是否有文本，定下title。若不为空，title为编辑任务；为空title为添加任务 3 修改后按下navigate bar button确认后，将（1修改后的文字；2之前选中的行数）传回主页面 4 主页面中实现协议的函数中：修改mode数组中的数据，根据行数row找到cell，再将cell的文字改为新的任务 左滑删除已经预置代码，直接取消注释； 添加上删除某一行的数据； 更新页面已经写了，不需要添加。 批量选择+批量删除navigation自带了添加编辑button的代码，取消注释，将button改到左边即可，还需要批量功能 由于需要批量的对象是table view，选中他，找到edit选择multiple 编辑即可 实现批量选中的效果： 批量删除需要重新放一个”删除“按钮； 在按下按钮后：获取选中的indexPath存储于数组，通过循环删除数据对应行数indexPath.row，使用table view的delete方法删除存于数组中的行数 1234567891011121314// 获取所有被选中的indexPath，若为空则不进行删除操作if let indexPaths = tableView.indexPathsForSelectedRows&#123; //1 Model 数据删除 for indexPath in indexPaths&#123; todos.remove(at: indexPath.row) &#125; //2 View 视图更新—— table View的删除方法 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能 tableView.beginUpdates() tableView.deleteRows(at: indexPaths, with: .automatic) tableView.endUpdates() // 方式二：从新load数据更新页面；但没有动画效果 //tableView.reloadData()&#125; ps 更新视图 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() 发现无法选择，原因是：原先的设置选择后，立即变成未选中状态，使得页面保持白色，不会保持变成灰色。需要：在原先的选择代码中，使用flag——isEditing，判断若在editing状态，则可以选中、打钩等一系列操作。 1234// 如果不是在编辑的情况下，选择打勾才有用、取消选中等才有用 if !isEditing&#123; //选择的代码——选择后原数据状态改变、重新mark为相反的、判断mark绘制√，取消选择背景变回白色 &#125; 按钮的默认文字汉化左滑时候的delete —— 变成 ”删除“的关键词：tableView、title、delete、button后出现需要重写的方法 批量选择edit、done改成中文——1 通过command+点击获取方法、2通过三元运算符+isEditing确认是”编辑“还是”确定“ 移动单元格已有该方法，重写to support rearranging the table view 首先使用临时变量temp交换两个数据，接着更新视图moveRow（不写这一句也可以移动，即自动调用）。 但是这里存在一个小bug，当编辑状态下，当选中数据，被移动后，该数据将一直处于选中状态，且无法删除。结局方法为：移动数据后，reloadData，取消选中状态，就不会导致setEditing函数自动调用该函数，导致混乱。 1234567891011121314// 移动单元格功能// Override to support rearranging the table view.override func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to: IndexPath) &#123; // 1 移动数据 let temp = todos[fromIndexPath.row] todos[fromIndexPath.row] = todos[to.row] todos[to.row] = temp print(todos) // 2 更新数据:自动更新,可以不用下面的代码 tableView.moveRow(at: fromIndexPath, to: to) // 3 移动后，刷新 tableView.reloadData()&#125; 简单数据存储userDefaultsAppDelegate文件+轻量级本地存储userDefaults+编码解码 1 AppDelegate文件：APP的声明周期：打开：APP启动、激活 按下home健：由于某种原因被挤到后台、进入后台 再次进入：即将激活、激活 退出：（APPlist 中）进入后台、（退出后）完全退出 2 数据数据存储在沙盒里面，信息安全，本APP只能访问本APP的数据 沙盒数据中只能存储基本的数据类型，我们的数据是存储对象的Array，无法存储进沙盒plist，因此需要写一个存储函数来编码数据为.data 3 使用userDefaults写好储存数据的方法（编码为data格式+存入沙盒）和解码方法（通过forKey获取数据，解码至todos数组）： 1234567891011121314151617181920212223242526// 数据存储——编码数据func saveData()&#123; // 可能会抛出错误 do&#123; // 编码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 let data = try JSONEncoder().encode(todos) // 得到data类型的数据，存入沙盒 UserDefaults.standard.set(data, forKey: "todos") &#125;catch&#123; print(error) &#125;&#125;//取数据——解码func getData()&#123; // 获得data类型的数据，由于可能为空，则使用if let：不为空的时候获取本地数据，为空则不获取 if let data = UserDefaults.standard.data(forKey: "todos") &#123; // 解码固定格式 do&#123; // 解码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 todos = try JSONDecoder().decode([Todo].self, from: data) &#125;catch&#123; print(error) &#125; &#125;&#125; 再把写数据的函数在所有操作数据处理调用； 在程序load时候调用取数据。 本地存储coredata和realm了解cs和bs+什么是数据库+为什么App需要本地存储 cs：client-server —— QQ、微信——聊天记录存在本机 bs：browser-sever —— 网页论坛——数据存储在服务器 IOS本地存储数据库： userdefaults——轻量级的数据 coredata——苹果自带的，学习成本高，代码多、不够快——了解 realm：速度快 realm安装与示例使用由于cocoapods无法pod，我选择下载安装法，自行配置： 先去 Realm 的官网去下载最新框架： https://realm.io/cn/docs/swift/latest/#prerequisites 接着拖拽 RealmSwift.framework 和 Realm.framework 文件到”Embedded Binaries”选项中。选中 Copy items if needed 并点击 Finish 寻找应用的 Realm 文件：Swift using Realm Swift:(lldb) po Realm.Configuration.defaultConfiguration.fileURL command+shift+g ：跳转窗口，进入沙盒 在model中新建模型User.swift，import包，定义模型 1234567import Foundationimport RealmSwift// 定义模型的做法和定义常规 Swift 类的做法类似class User: Object &#123; @objc dynamic var name = "" @objc dynamic var age = 0&#125; 进入AppDelegate，找到启动的方法，在该方法中： 1 数据实例化 do - catch中 2 创建数据库、3 存储数据 1234567891011121314151617181920212223func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. print("APP启动") // 0 输出沙盒地址 print(Realm.Configuration.defaultConfiguration.fileURL) // 1 实例化需要存储数据 —— 实例化user对象 let user = User() user.name = "Iris" user.age = 18 do&#123; // 2 创建一个数据库 let realm = try Realm() // 3将对象存入数据库 try realm.write &#123; realm.add(user) &#125; &#125;catch&#123; print(error) &#125; return true&#125; 查看数据：print(Realm.Configuration.defaultConfiguration.fileURL) command+shift+g ：输入得到的地址，跳转窗口，进入沙盒，查看的结果 realm操作1 在主页面处实例化数据库，为全局变量123// 使用数据库后，todo相当于一个中间人的角色// 实例化realm数据库 —— 强制try，确定不会出异常 （一般不这样写，可能会出现网络等异常）let realm = try! Realm() 2 创建RealmSwift的类 class Todo1234567import Foundationimport RealmSwift//定义模型的做法和定义常规 Swift 类的做法类似class Todo: Object &#123; @objc dynamic var name = "" @objc dynamic var checked = false&#125; 2 写数据新增数据功能： 新增数据后，创建一个类Todo的todo对象，传入saveData 3 取数据现在viewLoad()的时候，读取数据。发现需要results类型，所以下一步更改todos的类型 12// 从Realm数据库中读取数据 todos = realm.objects(Todo.self) 声明todos由数组类型改为复合类型，接受取出来的 result array的数据，定义为可选性，可能为空 123456789//定义为esults类型todos -- 定义复合数据类型 -- 名字:复合类型&lt;类型&gt; ——1种方式var todos: Results&lt;Todo&gt;? //定义空数组L：需要指明数组内存的类型。—— 3种方式//var Todos: Array&lt;Todo&gt;=[]//var todos:[Todo] = []//var todos = [Todo]()//定义空字典的方法：指明key和value的类型; [:]表明m空字典。—— 2 种方式//var dict:[String:Any] = [:]//var dict = [String:Any]() 可选性（todos为空），则初始的时候判断。 为此，进行初始判断：当todos取出来为空的时候，数组的行数为0，且出现文字——请添加任务 12345678910111213141516171819// 二、每段有几行：第i个session的行数override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows // todos?.count ：?表示，该符号前面为空，则不执行后面的，整个则为 nil // 空合运算符 xxx ?? ooo ,xxx为空，则执行ooo // 若tosos为空，则ession的行数 返回1 return todos?.count ?? 0&#125;// 三、每行显示什么override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 想要用到的到TodoCell下面的属性，向下z强制转型 let cell = tableView.dequeueReusableCell(withIdentifier: "todo", for: indexPath) as! TodoCell // 若取出的todos不为空，我们赋值给 这里的todos，可以在下面用 if let todos = todos&#123; //确定位置 第几行indexPath.row、第几段indexPath.session // Configure the cell... cell.todo.text = todos[indexPath.row].name cell.checkMark.text = todos[indexPath.row].checked ? "✓" : " " &#125; 在存储数据的时候，把更新页面直接改为reload()方法。 修改数据1 修改任务部分 ：获取当前行数，修改todos![indexPath.row].name = name；更新视图 2 状态更改部分：按下，状态取反，修改todos![indexPath.row].checked =取反；更新视图 删数据删除数据 更新视图 12345678910111213// Override to support editing the table view.override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; // 数据操作 do&#123; try realm.write &#123; realm.delete(todos![indexPath.row]) &#125; &#125;catch&#123; print(error) &#125; // 更新视图 tableView.reloadData()&#125; Realm-搜索和排序+searchBar+收起软键盘+主线程点击search bar 搜索，发生什么事情。 想到需要一个delegate协议。先遵守协议UISearchBarDelegate，再委托。告诉Todos Controller，search bar是老板（委托人），一会他有些申请会委托给controller做。 12345678910111213// 实现搜索功能// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 todos = todosData.filter("name CONTAINS %@", searchBar.text!) // 2 更新视图 tableView.reloadData()&#125; 当searchBar内容改变的时候，查看其是否为空，若为空，则‘’‘ 搜索之后，根据创建时间排序。先在class 中添加时间属性为当前时间，搜索的时候按照时间倒叙： 123456789101112// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 // 排序：时间倒叙 todos = todosData.filter("name CONTAINS %@", searchBar.text!).sorted(byKeyPath: "createdAT", ascending: false) // 2 更新视图 tableView.reloadData()&#125; 收起键盘：学习：https://www.jianshu.com/p/f042432e2d7d 1234567891011121314151617// 二、在搜索栏清空后，需要显示所有数据，且收起键盘 func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) &#123; // 看是否为空 if searchBar.text!.isEmpty&#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) todos = todosData // 2 更新视图 tableView.reloadData() // 让用户界面在主线程上进行——优先执行 // 经常用于使UI方面的操作提前执行，查询可以慢慢查，我们的键盘先收起来——用户体验更好 DispatchQueue.main.async &#123; // 3.收起键盘 让searchBar失去焦点(光标消失+软件盘收起) searchBar.resignFirstResponder() &#125; &#125; &#125; 未完成： //需求：打√之后，就放置在最后，取消打钩，放置在最前 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发 - 老虎机]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E5%BC%80%E5%8F%91%20-%20%E8%80%81%E8%99%8E%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[老虎机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package test.iris; import java.awt.Color; import java.awt.FlowLayout;import java.awt.Font;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Random; import javax.swing.BorderFactory;import javax.swing.ImageIcon;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.SwingConstants;import javax.swing.border.EmptyBorder; public class UI extends JFrame&#123; private static UI ui = null; static String[] paths = &#123; "1.png", "2.png", "3.png" &#125;; private MyLabel labelLeft = new MyLabel(paths[0], 0);// 左图 private MyLabel labelCenter = new MyLabel(paths[1], 1);// 中图 private MyLabel labelRight = new MyLabel(paths[2], 2);// 右图 private JButton button = new JButton("开始");// 开始按钮 private JLabel labelMessage = new JLabel("");// 结果标签 private UI() &#123; setTitle("老虎机"); setBounds(200, 200, 500, 500); JPanel panel = new JPanel(); setContentPane(panel); panel.setLayout(new GridLayout(3, 1)); panel.setBorder(new EmptyBorder(50, 50, 50, 50)); // 上中下三块面板 JPanel panelTop = new JPanel(); JPanel panelCenter = new JPanel(); JPanel panelBottom = new JPanel(); panel.add(panelTop); panel.add(panelCenter); panel.add(panelBottom); // 三张图片显示区域 panelTop.setLayout(new FlowLayout()); panelTop.add(labelLeft); panelTop.add(labelCenter); panelTop.add(labelRight); // 开始按钮面板 panelCenter.setLayout(new GridLayout(1, 1)); panelCenter.setBorder(new EmptyBorder(30, 100, 30, 100)); button.addActionListener(new MyListener()); panelCenter.add(button); // 抽奖结果面板 panelBottom.setLayout(new GridLayout(1, 1)); labelMessage.setBorder(BorderFactory.createLineBorder(Color.BLACK)); labelMessage.setFont(new Font("微软雅黑",0 , 40)); labelMessage.setForeground(Color.red); labelMessage.setHorizontalAlignment(SwingConstants.CENTER); panelBottom.add(labelMessage); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); &#125; public static UI getInstance() &#123; return UI.ui; &#125; public static String[] getPaths() &#123; return paths; &#125; public MyLabel getLabelLeft() &#123; return labelLeft; &#125; public MyLabel getLabelCenter() &#123; return labelCenter; &#125; public MyLabel getLabelRight() &#123; return labelRight; &#125; public JButton getButton() &#123; return button; &#125; public JLabel getLabelMessage() &#123; return labelMessage; &#125; public static void main(String[] args) &#123; UI.ui = new UI(); &#125;&#125; class MyListener implements ActionListener&#123; private boolean buttonFlag = false;// 按钮点击状态，默认未点击 public static boolean threadFlag = true;//线程中断标志 @Override public void actionPerformed(ActionEvent e) &#123; UI ui = UI.getInstance(); JButton button = ui.getButton(); JLabel labelMessage = ui.getLabelMessage(); MyLabel labelLeft = ui.getLabelLeft(); MyLabel labelCenter = ui.getLabelCenter(); MyLabel labelRight = ui.getLabelRight(); if (buttonFlag) &#123; threadFlag = false; buttonFlag = false; button.setText("开始"); synchronized (labelLeft) //等待三个线程释放锁 &#123; synchronized (labelCenter) &#123; synchronized (labelRight) &#123; int leftId = labelLeft.getId(); int centerId = labelCenter.getId(); int rightId = labelRight.getId(); String result = getResult(leftId, centerId, rightId); labelMessage.setText(result); &#125; &#125; &#125; &#125; else &#123; threadFlag = true; buttonFlag = true; new MyThread(220, labelLeft).start(); new MyThread(150, labelCenter).start(); new MyThread(60, labelRight).start(); labelMessage.setText(""); button.setText("暂停"); &#125; &#125; public static String getResult(int leftId, int centerId, int rightId) &#123; String result = null; if (leftId == centerId &amp; leftId == rightId) result = "一等奖"; else if (leftId == centerId || leftId == rightId || centerId == rightId) result = "二等奖"; else result = "未中奖"; return result; &#125;&#125; class MyLabel extends JLabel&#123; private int id;// 标签id public MyLabel(String path, int id) &#123; ImageIcon icon = new ImageIcon(path); setIcon(icon); this.id = id; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class MyThread extends Thread&#123; private long time; private MyLabel label; private Random random = new Random(); public MyThread(long time, MyLabel label) &#123; this.time = time; this.label = label; &#125; @Override public void run() &#123; synchronized (label) //锁住lable对象 &#123; while (MyListener.threadFlag) &#123; try &#123; Thread.sleep(time); int id = random.nextInt(3); label.setId(id); ImageIcon icon = new ImageIcon(UI.paths[id]); label.setIcon(icon); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极客iOS课程 - 2 APP启动优化与监控]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%9E%81%E5%AE%A2iOS%E8%AF%BE%E7%A8%8B%20-%202%20APP%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[APP启动 冷启动： 热启动：]]></content>
      <categories>
        <category>iOS课程</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 散列表]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%203%20%E4%BA%8C%E5%8F%89%E6%A0%91%20%2F</url>
    <content type="text"><![CDATA[二叉树树存储：一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法 链式存储法：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点 顺序存储法：完全二叉树适合，不浪费空间，堆其实就是一种完全二叉树。 高度、深度、层数：“高度”这个概念，其实就是从下往上度量，3-0 “深度”这个概念在生活中是从上往下度量的，0-3 “层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点从1开始。 二叉树遍历 前序遍历：打印顺序为本节点、左节点、右节点 中序遍历：打印顺序为左节点、本节点、右节点 后序遍历：打印顺序为左节点、右节点、本节点 时间复杂度是 O(n)。 123456789101112131415161718192021222324252627282930前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 真实代码void preOrder(Node* root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印 root 节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;void inOrder(Node* root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印 root 节点 inOrder(root-&gt;right);&#125;void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印 root 节点&#125; 按层遍历：使用队列。 根节点入队列，此时队列不为空。取出队列第一个元素打印出来，若其左节点存在就存入队列，否组什么也不做，右节点同理。 直至队列为空，表示数的层次遍历结束，层次遍历也是一个广度优先遍历算法。 二叉查找树支持：快速插入、删除、查找一个数据 要求：树中的任意一个节点，其左子树中的每个节点值都小于该节点，有字数节点值大于该节点。 查找、插入和删除首先取根节点，两者相等则返回，数小于该节点则在其左子树中递归；大于则在右边递归查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 节点类class static class Node&#123; private int data； private Node left; private Node right; // 初始化方法 public Node(int data)&#123; this.data = data; &#125;&#125;// 二叉树类public class binarySeachTree&#123; // 声明一棵树，根节点为 tree private Node tree; // 1.查找函数 public Node find(int data)&#123; //复制 Node p = tree; // 不为空则继续查找 while(data != null)&#123; // 是否相等 if(data &lt; p.data) p = p.left else if(data &gt; p.data) p = p.right else return p； &#125; // 为空返回空，表示没找到 return null; &#125; // 2.插入函数 public void insert(int data)&#123; // 若根节点为空,根节点为该数据，实例化 if (tree == null)&#123; tree = new Node(data) return; &#125; Node p = tree; // 若不为空 while(p != null)&#123; // 小于，查看节点左边是否有节点，没有就实例化，有就继续判断下一个 if(data &lt; p.data) &#123; if(p.left = null)&#123; p.left = new Node(data) &#125; p = p.left; &#125;else if(data &gt; p.data)&#123; if(p.right == null)&#123; p.right = new Node(data) &#125; p = p.right; &#125; &#125; &#125; public class Question_39 &#123; //----递归求二叉树深度---- public static int treeDepth(BinaryTreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = treeDepth(root.left); int right = treeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125; &#125; 其他操作：最大最小、前驱后继节点中序遍历（左中右）二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效率。 因此，二叉查找树也叫作二叉排序树。 支持重复数据的二叉查找树方式一：一个节点不仅存储数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据存储于一个节点上。 方式二：更优雅。相等的时候看做大于该值。 二叉查找树的时间复杂度分析最差情况：二叉查找树，根节点的左右子树极度不平衡，已经退化成链表。O(n)。 时间复杂度其实都跟树的高度成正比，也就是 O(height)。 两个极端情况的时间复杂度分别是 O(n) 和 O(logn)。 而对于完全二叉树： 问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？ 完全二叉树的层数小于等于 log n +1，也就是说，完全二叉树的高度小于等于 （log n）。 平衡二叉树是 O(logn)。 散列表和二叉查找树比较排序：散列表无序排序，输出有序数据前需要排序；二叉查找树有序，中序遍历可以在时间复杂度O(n)中，输出有序序列。 稳定性：散列表扩容耗时多、散列冲突的时候性能不稳定；平衡二叉查找树较稳定，时间稳定在 O(logn)。 构造复杂：散列表更加复杂，需要考虑散列函数、负载因子动态扩容、冲突解决。平衡二叉树只需要考虑平衡性。 空间：对于散列表的开放寻址法，装载因子不能太大，需要更多的空间。 平衡二叉树 AVL 红黑树Question：动态数据结构支持动态地数据插入、删除、查找操作，除了红黑树，还有哪些？比较优劣和场景。 动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。 而且，这些操作都非常高效动态数据结构有链表，栈，队列，哈希表等等。 链表适合遍历的场景，插入和删除操作方便； 栈和队列可以算一种特殊的链表，分别适用先进后出和先进先出的场景。 哈希表适合插入和删除比较少（尽量少的扩容和缩容），查找比较多的时候。 红黑树对数据要求有序，对数据增删查都有一定要求的时候。 ###]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 散列表]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%202%20%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[来源来源于数组支持按下表访问的特性，是数组的拓展。 构造：首先根据数据确定哈希函数，接着选择冲突解决方法，最后构造散列表，再写上需要的增加、查找、删除的方法。 插入：根据key键值，经过哈希函数，得到哈希值，插入表中。 查找：根据key值查找。 三个问题：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。 设计散列函数定义key值通过哈希函数之后，数据散列到列表中。 4个要求 哈希之后，值为大于0的整数，对应到数组的下标 同一个key的哈希结果相同 哈希之后的值均匀分布 哈希方法不能太复杂 根据装载因子动态扩容 rehash原因装载因子——给定一个能存放n个元素的、具有m个槽位的散列表T： 定义T的装载因子：α = n / m 对于动态的数据集，一开始无法知道其大小，其频繁的插入和删除，可能导致装载因子过大或者过小。此时我们需要动态扩容。 方式 一次扩容 插入数据的时间复杂度O(1)，但是某次达到装载因子阈值的插入时需要重新对原来数据进行hash操作，再放入新元素。非常耗时，需要优化放入分批扩容。 分批扩容 对于插入：获取一个新的2倍大小的哈希表，将新元素哈希之后插入，同时选择原哈希表中的一个数据插入新表，直至原哈希表为空。 对于查找：现在新表中查询，再查找旧表。 选择冲突解决的办法定义不同的key值散列之后，有可能获得同样的值，发生散列冲突 2个方法 空间寻值法：1 种类： 线性寻址：index + i 平方寻址：index + i^2 二次哈希：经过两次哈希函数得到的值 2 对应方法 增加：冲突后，往后找寻空位置放置元素 查找：哈希之后的值不是要找寻的元素时，往后面继续寻找。找到返回true；若找到空，则说明不存在该元素。 删除：注意。删除后标记delete，而不知直接删除。否则查找方式受影响。 3 缺点 装载因子不能过大，因此要求的空位要足够，需要较大的内存 会发生一次集群、二次集群，经过哈希之后的值都分布在某一段，插入和查找的时间成本变多 链接法 方法：将冲突元素装在以h(k)开头的链表 查找时间：为Θ(1 + α)，查找操作最坏情况下，需要常数时间。 优点：装载因子可以较大，要求的内存少 优化：如果链表中元素较多的时候，我们可以使用改造为其他高效的动态数据结构（树等），及时最极端情况下也只是退化为一棵树，查找时间还是0(log n)。 例子工业散列表：Java 中的 HashMap1 初始大小：默认16，预先知道数据大小可以设计出适合大小避免rehash 2 装载因子和动态扩容：0.75，自动扩容为2倍 3 散列冲突：链接法。jdk1.8版本中，优化链表，如果链表&gt;8，则转化为红黑树，查找更快；&lt;8时，变为链表，因为树结构平衡维护。 word的拼写检查1 数据存储的数据结构：50w个英文单词不超多10M，存储于哈希表中。 2 单词比对：对于每次输入的单词，作为key值，hash之后，查找哈希表，若查找不到，则标注拼写错误。 总结当数据量比较小、装载因子小的时候，适合采用开放寻寻址法。 数据量大，空间不足，使用链表法。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的简历V1]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[教育经历2017.09 - 2020.06 硕士 中南大学 计算机科学与技术 专业排名未知研究方向：可视化与可视分析、高维数据可视分析。成果：发表专利一项、参与发表A类论文一篇、主持中南大学研究生自主探索项目一项 2013.09 - 2017.06 本科 中南大学 计算机科学与技术 专业排名1%~5%保研本校研究生；国家励志奖学金、中南大学大学生关怀奖学金、班长奖学金、学年一等学金；“优秀毕业生”；多次获“优秀学生”、“优秀团员”、“优秀学生干部”；校运会跨栏金牌 学术研究 “基于强声凝聚的PM2.5减排装置的复合式消声系统”专利 参与论文被A类会议IEEE Visualization Conference接受，现已推荐发表在《IEEE Transactions on Visualization and Computer Graphics》期刊 项目经历2019.01 - 2019.02 iOS——元气天气APP 项目负责人需求：展示当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 实现：采用了MVC设计模式。获取当前位置的天气：利用 Cocoa 框架中的protocol-delegate设计模式，实现定位协议获得当前经纬度；Pod第三方库，使用Alamofire请求、SwiftJSON解析数据；将数据赋值给model，更新页面。查询页面跳转传值：使用segue导航正向传值，自定义protocol、委托代理delegate实现导航反向传值。 知识点：protocol-delegate、计算属性、第三方库的CocoaPods安装的使用、extension代码优化 2019.02 - 2019.03 iOS——去做吧！APP 项目负责人需求：Todo list 实现： 知识点： 2018.10 - 2018.12 Android——《延禧攻略》连连看、五子棋游戏、绘图板 项目负责人需求： 实现： 知识点： 2018.05 - 2018.08 Java——多线程弹球游戏、欢乐抽奖、AI五子棋、趣味画板 项目负责人需求： 实现： 趣味画板： 使用JPanel对主界面JFrame分区，绘制组件；为事件源（组件）上添加鼠标监听器； 重绘功能：定义shape类，绘制时将坐标、颜色存入对象，再对象存入数组；主函数继承JPanel，重写panit()函数时，绘制shapeArray[]数组中所有的Shape对象。 2018.01 - 2018.04 自由探索项目——面向高维时序数据的可视分析 项目负责人1、T LAMP在数据上应用一个滑动窗口方法，并为每个窗口计算一个一维LAMP。随后，一维LAMP映射的结果序列沿着时间轴进行排列：x轴表示时间，而y轴表示LAMP的相似性值。类似的事件随着时间的推移被聚合，分析人员可以通过视觉特征有效识别特定模式。2、为了分析高维数据中属性的性质，我们用一个序列的多元矩阵来揭示了各个属性贡献程度随时间变化。此外，我们还引入了一种新的算法，根据用户的选择来寻找相似的模式。3、对齐一维投影序列，现有大多数现有的时序数据投影方法都采用二维投影。TLAMP依赖于一维LAMP投影，利用图中的第二维度来显示高维数据随时间推移的变化。 2017.08 - 2017.08 前端项目——‘互联网+’走基层追寻红色文化”社会实践 策划、技术支持1、负责活动主题策划。活动亮点在于利用专业技术创建“红色信息平台”、科技普及2、龙洞红色旅游网站搭建、微信二维码语音导航助手3、项目新闻稿撰写，新媒体推送撰写，项目总结答辩工作成果：国家级、地区级别、校级网站报道13篇、新媒体微信推送13篇、电视台报道1次]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 二分查找]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[针对有序数据集合的查找算法 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 该功能不要占用太多的内存空间，最多不要超过 100MB。 二分思想O(logn) 惊人的查找速度 二分查找的递归与非递归实现最简单的情况就是有序数组中不存在重复元素。 循环条件：low&lt;=high mid取值： low 和 high 比较大的话，mid=(low+high)/2和可能会溢出。 改进方式1为，mid=low+(high-low)/2 改进方式2为，除以 2 操作转化成位运算 mid = low+((high-low)&gt;&gt;1) low和high更新 low=mid+1，high=mid-1 1234567891011121314151617181920212223242526272829303132333435# 循环二分查找def search(arr, n, value): low = 0 high = n - 1 while low &lt;= high: mid = int((high + low) / 2) if arr[mid] == value: return mid elif arr[mid] &lt; value: low = mid + 1 else: high = mid - 1 return -1# 递归二分查找def Binarysearch(arr, low, high, value): if low &gt; high: return -1 # 位操作，防止溢出 mid = low + ((high - low) &gt;&gt; 1) if arr[mid] == value: return mid elif arr[mid] &lt; value: return Binarysearch(arr, mid + 1, high, value) else: return Binarysearch(arr, low, mid - 1, value)a = [1, 2, 3, 4, 6, 8, 9]n = len(a)value = 1print(search(a, n, value))print(Binarysearch(a, 0, n - 1, value))]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化 - 可视化基础]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20-%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[有些人认为可视化只是把计算分析的结果图形化。 实则不然，可视化是人类认识、分析复杂数据的重要途径。 数据可视分析数据可视化的挑战计算能力有限、感知和认知的局限、显示能力的局限 大数据可视化以人为中心的探索式可视分析(关注)可视化框架可视化循环模型 可视分析流程数据转化、可视映射、视图转化 原数据-&gt;转化后的数据-&gt;可视结构-&gt;视图 如：我们选择线性投影将30维的原数据降为5维度的转化数据，再使用平行坐标视觉映射转为可视结构，然而数据有相互遮挡，则选择PCP方法视图转化至视图上。最后呈现热力图式的平行坐标。 基本图表原始数据数据轨迹、柱状图（x轴为类别型，主要用于统计值）、直方图（x轴为数据型，主要用于频率）、饼图(比例)、散点图与散点图矩阵(属性对的关系、热力图(颜色编码二维数据值的大小) 统计值标绘制盒须图，上面最大值、下面最小值、盒子表示数据大致范围25-75% 多视图协调关联选择后高亮 交互技术选择 selection数据过多视觉混乱：堆叠区域和对象放大选择后展示提示信息：字符串在有限空间排列，不选择的时候隐藏，选择后展开 导航 navigation人眼观察到区域可见空间有限缩放平移旋转 重配 reconfigure提供观察数据的不同视角重组视图重排列 编码 encode颜色编码、大小、方向、字体、性状 抽象 abstraction不同等级的信息，交互控制获得更多或更少的细节 过滤 filter设置约束条件进行信息查询eg.选定价格房型，地图上出现复合房子动态过滤：滑动框、按钮、组合框，过滤条件之间不相关 关联 connection高亮显示对象之间关系链接与刷动 刷选对象，其余都可高亮 概览+细节 overview+details谷歌地图右下角全局，主页面当前区域 焦点+上下文 focus+context高维数据可视化高维多元数据——独立属性、相关数据 可视分析——维度太高，难以提取可理解的维度关联信息。高于10维的数据 空间映射法散点图与散点图矩阵平行坐标降维(重要)线性方法和非线性方法，将高维数据投影project或嵌入embed至低维空间(通常为2、3维)，并尽量在低维空间保持多元空间中的关系和特征。 最后展示的方法一般为散点图。 主元分析 PCA(无监督)减少维度，保持数据集方差贡献最大的特征。（在低维空间找一个观察角度，以便最大限度观察多维数据的差异。） 第一个新坐标轴选择的是原始数据中方差最大的方向，第二个新坐标轴选择的是与第一个新坐标轴正交且方差次大的方向。 通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值及特征向量，选择特征值最大（也即包含方差最大）的N个特征所对应的特征向量组成的矩阵，我们就可以将数据矩阵转换到新的空间当中，实现数据特征的降维（N维）。 123456去除平均值计算协方差矩阵计算协方差矩阵的特征值和特征向量将特征值排序保留前N个最大的特征值对应的特征向量将数据转换到上面得到的N个特征向量构建的新空间中（实现了特征压缩） 线性判别分析 LDA(有监督)也叫Fisher线性判别。 抽取分类信息和压缩特征空间维数，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离，即模式在该空间中有最佳的可分离性。 优化目标J最大，获得最优投影向量w：使用矩阵分解，得到特征值最大的特征矩阵的第一行。 多维尺度分析 MDS multimensioanal scaling### 图标星状图 基于像素的可视化方法]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学术]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[自由探索项目——面向分类的感知驱动的可视化监督降维方法成绩：自由探索项目，预计4月-5月投稿。（负责人） 目标：分类数据的分析。 方法：本文提出了一种感知驱动的线性降维方法，寻求生成具有最大视觉分离程度、最少数量的最优二维投影集合。 （1）子空间表达：对于类别两两之间利用分离度量求最优分离向量，然后在各个维度上找出在这个度量上能够达到分离度量阈值的范围，各个维度上的范围构成了一个包围盒。 （2）子空间求交：包围盒如果有交集，则代表它们之间可以用一条向量进行区分。 我们将包围盒看做点，两个包围盒有交，则在对应的点之间连边，若存在一个完全图，则代表这些包围盒所代表的点对都可以用一条向量进行区分，用最少数量的团对这张图进行覆盖，这些团就对应了最少数量的包围盒集合。 （3）组合优化：我们取包围盒的中心所对应的向量作为投影的坐标轴，将坐标轴进行组合，得到最少数量的投影集合。 困难1：一开始构建单个视图，发现类别多的时候无法构建 目标函数：为了最大化非线性目标函数dDSC。优化方法：使用模拟退火算法，通过比较随机生成的投影结果的costFuction，找出全局最优值。得到最优的投影结果展示分类数据。 发现：真实数据中可能存在很多类，如骑车包括： 困难2： 方式2：几何的方式优化 方法：要得到一个最优的向量w，步骤如下： 1）得到使方差很小的Pa、Pb两个子空间基本功能已经完成。 矩阵分解得到将得到两个特征矩阵Pa、Pb（n*k），其k个特征向量均为正交矩阵，则该矩阵为正交矩阵。 2）Pa、Pb两个子空间求交基本功能已经完成。 解线性方程组得到基础解系{x,y}，Ax为基向量，再将Ax化为模等于1的单位向量。 得到验证结果，类别A的数据在本空间Va的标准差和在交空间的方差标准差数值接近。 类别A的data在Va、Vb、AB交空间vec的方差：0.0088525953414772470.0114245457684850630.00896923772901887类别A的data在Va、Vb、AB交空间vec的标准差：0.095043466648306780.10797082829987120.09566756711110631 数据A投影到Va、Vab中的结果如下： 3）最大化两个类别中心点的距离的特征向量distVec由于方式2为几何的方法，我们得到的该特征项就是两个类别中心的连线 v_{dist} = u_a-u_b 这一步很简单，直接可以得到的为：n*1的特征向量 v_dist A、B可视化为图中绿色点，中心点为红色点、distVec则为蓝色线段的方向，我们将其化作单位向量如橙色线段。 4）将2）中的交空间和3）中的子空间（向量）组合，得到最终的子空间范围 V方式1：直接看做两个子空间求交 对于该方式，大概率会求出空集。 方式2：线性组合。 这里提出enegeFuction = distAB- Sa-Sb(A、B的方差) 最大化enegeFuction，得到参数k。 得到newV= {vec+k1α1，vec+k2α2，…，vec+knαn} 纯代数无法得到结果。 目标函数：为了最大化非线性目标函数dDSC。优化方法：使用模拟退火算法，通过比较随机生成的投影结果的costFuction，找出全局最优值。得到最优的投影结果展示分类数据。技术：所有可视分项目基本是后端python实现降维算法，前端D3.js来进行交互展示。负责： 高维数据中的低维结构的可视探索成绩：并推荐可视化顶级刊 TVCG。非学生一作 问题：高维数据集中往往含有不同结构的低维结构，当未知数据集中的低维结构与当前的可视化方法的假设不匹配时，可视化结果将难以理解。解决：可视分析方法帮助用户有效地识别低维结构及关键特征，为进一步分析提供关键结构信息。方法：t-SNE初步提供初始聚类信息，局部切空间-测地距离视图用来发现子空间，2个滚石图拐点为子空间维度， 高维多元数据——独立属性、相关数据 可视分析——维度太高，难以提取可理解的维度关联信息 高维数据低维结构 P1——二维S1、一维S2、S3 P2—— 一、选题意义和研究价值 分析高维数据集的许多方法都假设数据集包含特定结构，例如聚类位于线性子空间中或位于非线性流形上。这需要反复的实验去验证适当的模型和参数。本文提出了一个探索性的界面，支持识别高维数据集中的低维结构，并有助于选择最优的数据模型和参数配置。我们的关键思想是从潜在的低维结构的邻居图表示中提取一组全局和局部特征描述符，例如点间的测地距离(GD)以及点的局部切空间(LTS)中点间的局部切空间散度(LTSD)。我们提出了一个新的LTSD-GD视图，它通过多维标度分析方法(MDS[6])分别将LTSD和GD映射到x轴和y轴。与保留点之间各种距离的传统降维方法不同，LTSD-GD视图展示了点LTS(x轴)的分布和结构中LTS的变化(x轴和y轴的组合)。我们设计并且实现了一系列可视化工具，用于探索高维数据中的内在结构 二、国内外研究现状和发展动态 2.1可视化高维数据 高维数据可视化引起了广泛关注[18]。包括平行坐标图[14]，散点图矩阵和雷达图[11]等的常规可视化技术被设计去呈现数据的统计，例如维度中的数据分布或两个维度之间的相关性。然而，这些方法基本不可能去揭示潜在的聚类模式和潜在的特征。 基于DR的投影方法是可视化方法中的重要组成部分。通常，将点投影到二维或三维空间，并且同时保留一定的结构。广泛使用的PCA方法尽力去保留数据的方差。经典的多维标度分析(MDS)[6]，在投影过程中保留了高维空间中数据间的欧几里德距离。这些方法假定点位于单个的低维线性子空间中。如果当点位于非线性流形中，同样也已经提出了几种流形学习方法来检测潜在流形，例如ISOMAP[34]，LLE[24]，LE[4]和LTSA[44]。然而，基于DR的投影结果可能难以理解和解释[31]。首先，这些点被盲目地减少到二维或三维空间，由于维度的限制，这些空间可能不能准确地捕捉到数据间的内在结构[13]。第二，分析者可能缺乏DR方法与内在结构之间是否合适的相关知识[13]。分析者可能对DR模型的理解有限，或者在初始阶段对数据的了解有限。 在现实世界的高维数据集中，数据点通常位于多个子空间或多个流形中。子空间聚类[40]和流形聚类[8]方法被设计用于检测潜在的多个低维结构。通常的策略是首先采用DR模型，然后有序地可视化检测到的低维结构。VISA[2]系统根据全局视图中的聚类和维度的大小提出了聚类之间的相似性。它还在详细视图中显示了各个聚类的属性。Tatu等人[33]开发了一个可视化界面来探索SURFIN[3]发现的大量子空间。基于相似度函数来探索子空间，其重点在于子空间之间的拓扑和维度重叠。Liu等[19]用谱法提取子空间，并将子空间用可视化技术呈现出来。然而，子空间聚类和流形聚类模型通常强烈依赖于本质结构的假设，例如聚类的数量[7]，聚类的维度[36]和结构之间的是否相交。在不了解本质结构的情况下，很难选择合适的模型。 在这些可视化方法中，t-SNE[39]对内在结构做了一个温和的假设。在低维嵌入中，它保留了对不同结构(如多个流形)的k-Nearest-Neighbors(kNN)图的统计数据。t-SNE不仅保留了局部结构而且还显示了全局信息[22]，因此我们将其作为高维数据集中内在结构的初始指标之一，并在可视化探索过程中优化它。为了计算效率，在t-SNE中可以采用层次化策略[21]。 2.2 探索高维数据 探索高维数据比自动模型更需要含有交互功能的预处理工具[42]。传统的方法，如平行坐标图，散点图矩阵[12]和各种投影[25]已经得到了很好的研究。 通常，分析者需要在探索期间以交互方式产生许多视图。为减轻手工负担，Voyager[41]提出自动生成可视化的建议。接下来，出现了大量关于质量测量[5,32]和排名[29]的可视化文献。DimScanner[42]提出构建可视化来发现不同视图之间的信息感知关系。Sarvghad等[27]可视化了维度覆盖以记录探索的历史。为了探索显著的子空间，Yuan等[43]提出了一个矩阵/树结构，以便在探索过程中组织数据和维度的子集。 为了增强发现潜在结构的能力，自动化的DR模型被集成到探索界面中。因为数据的潜在结构往往是未知的，所以这些方法利用混合模型[23]来匹配潜在的结构。DimStiller[13]提出了用于维度分析和减少组合的自动化DR模型的工作流程。通常，只能选择比较容易理解的模型，如PCA和MDS。当处理包含多个低维结构的数据时，这些模型和工作流程产生可解释的结果是基本不可能的。在本文中，我们试图在构建具体模型之前对其内在结构和特征进行表征。结构的特征和可视化揭示了潜在的低维结构。 三、主要研究思路、研究内容和在学术方面的创新点 3.1 低维结构的表示 我们将子空间定义为一个聚类低维表示的基础[40]。给定一组线性或仿射子空间的点，子空间可以通过奇异值分解(SVD)或主成分分析(PCA)来计算得出。还有一点需要注意的是数据可以是轴对齐的，也可以是非轴对齐的。 在一般情况下，点大多位于非线性流形上。我们可以把流形认为是一个“软”和“弯曲”的子空间。d维流形的每一个点都有一个与d维的欧几里得空间同胚的小邻域，在一个流形中，点的局部子空间的方向是逐渐变化的。另一方面，子空间是流形的一般情况。对于位于相同子空间中的聚类，点的局部子空间的方向是相同的。 受流形学习方法的启发，我们建立了一个邻居图，一个kNN图，用来表示位于潜在流形或子空间中的聚类。这个表示是基于一个局部假设[16]，即每个点都有一个小的邻域，在这个邻域里，每个点都属于同一流形，近似地位于一个低维的仿射子空间中。这意味着即使在全维空间中，每个点的局部子空间也可以从局部领域中获取。给定一个不熟悉的数据集，分析者总是可以从一个统一的表示开始。 在本文中，我们使用Shared-Nearest-Neighbor (SNN)图[9]，它是一个kNN图的子图，用来表示本质结构。在SNN图中，当且仅当p和q位于彼此的kNN邻域时，两者之间才存在一条边。SNN图形倾向于生成多个分区，这非常适合用于呈现聚类特征。 三、4.5.1 kNN Graph与SNN Graph 首先我们构建出Shared-NearNeighbors(SNN) Graph，来表示高维数据的内蕴结构。SNN Graph是kNN Graph的子图，他要求两点互为k近邻时，两点之间才存在边；数据存在异常值时，与其他部分相互分隔开。与kNN Graph相比，SNN Graph中心和边界的数据分布得到了增强。接着，我们用节点链接布局SNN Graph。本文提供了两种方式来交互地从SNN Graph中提取内蕴轴：点选和自由绘制曲线。 4.5.2 点选 用户可以选择一系列数据点来解释他的点选的趋势。我们根据用户点选的顺序，通过Dijkstra算法得到最短路径，并连接数据点，得到原始路径。当所选点的数量超过两个时，构建的原始路径中可能存在回路。当原始路径中存在回路时，算法将会移除该回路，如图4-5-2。如果在点选列表中相继的两个点处于两个不相连接的图中部分，我们将会寻找两部分中最近的两个点，并添加一条边来连接两个部分。 随着选定点的增加，解释知识从宽泛到细致。因此，路径中的回路反映了人类知识的不确定性。视觉特征，如聚类，路径趋势和异常值，往往可以作为用户交互的感知线索。 图4-5-2 从原始路径中移除回路（a）点选两点的最短路径（b）选择多个点时，路径不确定性增加（c）原始路径存在回路（d）从路径中移除回路]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 链表]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%202%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LRU 缓存淘汰策略内存管理的一种页面置换算法。LRU全称是Least Recently Used,即最近最久未使用的意思，最久未使用的数据，下次被访问的可能最小，我们需要删除它。 链表实现维护一个有序单链表，靠近尾部是最早访问，头部为最新访问。当有新数据被访问，我们从头开始遍历链表： 若此数据之前已有，从原来的位置删除，再将数据放在头结点； 若之前没有：缓存未满，直接放在头部；缓存已满，删除尾部数据，将其放在头部。 时间复杂度：时间复杂度为 O(n)，需要遍历。 散列表实现1.上面所讲的几个散列表和链表组合的例子里，我们都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？2.假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作：1）根据猎头ID查收查找、删除、更新这个猎头的积分信息；2）查找积分在某个区间的猎头ID列表；3）查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。 以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。 1）ID 在散列表中所以可以 O(1) 查找到这个猎头；2）积分以跳表存储，跳表支持区间查询；3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。 12]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 数组]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%2F</url>
    <content type="text"><![CDATA[两种数据结构：链表和数组。 数组占据随机访问的优势，却有需要连续内存的缺点。 链表具有可不连续存储的优势，但访问查找是线性的。 散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。 我们可以得出数据结构和算法的重要性排行榜：连续空间 &gt; 时间 &gt; 碎片空间。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 排序]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)排序算法 冒泡排序 插入排序 选择排序 选择排序不稳定，相同元素可能会变化，因此这三种不选择选择排序。 代码中，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。 因此三种最好的方法就是：插入排序。 O(nlogn) 排序算法归并排序 方法：利用了分治思想，用递归代码来实现归并排序。先分，再合。 时间复杂度： T(n)=Cn+nlog2n。非常稳定，所有情况都是O(nlogn)。 空间复杂度：不是原地排序算法，每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时空间释放。 O(n)。 处理过程：是由下到上的，先处理子问题，然后再合并。 快速排序方法：利用主元分区，每次分为左边小区，右边大区。直至区内只有一个元素之后，排序完成。 时间复杂度：分区每次右边都没有元素。就从 O(nlogn) 退化成了 O(n2)。 处理过程：是由上到下的，先分区，然后再处理子问题。 堆排序10 亿个搜索关键词的日志文件，Top 10 最热门的搜索关键词用户搜索的关键词，有很多可能都是重复的，散列表先记录次数。 用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出次数，若次数多&gt;顶堆，则删除顶堆。遍历完成后得到top10。 然而10亿太大了。 哈希之后，将 10 亿条搜索关键词先通过哈希算法分到10个文件。在进行上述步骤，然后得到10x10个关键字。租后排序得到top10。 问题10 个接口访问日志文件，每个日志文件大小约 300MB，日志都是按照时间戳从小到大排序的 将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后也是从小到大排序。 机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这10 个日志文件合并吗？ 每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。 线性排序桶排序（Bucket sort）要求： 容易划分为m个桶，且天然有序 分布均匀，若分布不均匀全在一个桶里会退化为log（n/m log(n/m)) = log(n logn) 外部排序。数据大，内存有限，无法将数据全部加载到内存，存放于外部磁盘中。 10GB数据，如何按照订单金额排序？ 扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 1… 将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内，第二个1001-2000，类推。每个桶按照范围命名。 理想状态均匀分布，则划分为100个100M文件。按文件编号，依次将文件放入内存快排，在写入同一个文件。 若部分文件很大，无法写入内存，继续划分，直到对所有文件都可读入内存为止，再依次快排。 计数排序（Counting sort）要求： 数据量大，数据区间小 非负整数。若为不符合该条件，则转化即可。 如何根据年龄给 100 万用户排序？年龄的范围最小 1 岁，最大不超过 120 岁； 遍历这 100 万用户，根据年龄将其划分到这 120 个桶里； 依次顺序遍历这 120 个桶中的元素。 高考查分系统，省内50万名考生，分数范围为900-0。数据范围小，我们划分为901个桶，桶内为分数相同的学生。 此时不需要在排序，而是只需要依次输出到数组即可，只需一次扫描操作，时间复杂度O(n)。 ps. 若考生分数有小数点后一位，则需要所有分数乘10，转为整数，再放进9010个桶内。 基数排序（Radix sort）要求： 数据可以分割出独立的“位”来比较，位之间有递进的关系（高位优先） 每一位的数据范围不能太大，要可以用线性排序算法来排序 10万个11位电话号码排序（等长） 规律：比较两个号码a、b，若前几位a已经大于b，则后面不用看。 方法：先按照最后一位排序，再按照倒数第二位，以此类推。最后按照第一位来排序。11排序之后，手机号码有序。 时间复杂度：按照每一位排序，数字只有0-10，可以使用桶排序，时间复杂度可以做到 O(n)。排序的数据有 k 位，时间为O(k*n)。k不大的时候，近似为O(n)。 排序牛津字典中的20 万个英文单词（非等长1-45） 解决非等长：把所有的单词补齐到相同长度，位数不够的可以在后面补“0”。根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响排序。 接着使用基数排序 是否用过代码同步？（我说的用过github）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 数组]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%205%20%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[有向图 带权图 邻接矩阵存储方法存储费空间，使用方便 领结表存储方法节省空间、使用耗时 如何存储微博、微信等社交网络中的好友关系？判断用户A是否关注用户B 判断用户A是否是用户B的粉丝 邻接表 逆邻接表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 1 基础语法]]></title>
    <url>%2F2017%2F02%2F19%2FJavaScript%20-%202%20%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[第1章 系好安全带,准备启航第2章 你要懂的规则(JS基础语法)第3章 一起组团(数组)第4章 跟着我的节奏走(流程控制语句)第5章 小程序，大作用（函数）第6章 事件响应，让网页交互第7章 JavaScript内置对象第8章 浏览器对象第9章 DOM对象，控制HTML元素第10章 编程挑战###]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 1 基础语法]]></title>
    <url>%2F2017%2F02%2F19%2FJavaScript%20-%201%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20%2F</url>
    <content type="text"><![CDATA[第一章 入门本章节主要讲解如何在HTML文件中添加JavaScript代码，掌握必备的基础语法，为以后来章学习打下基础。 第二章 请和我互动本章节主要讲解如何向网页中输入内容，如何与浏览器窗口进行交互，通过简单的对象方法就可以轻松实现。 JavaScript-警告（alert 消息对话框）12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;alert&lt;/title&gt; &lt;script type="text/javascript"&gt; function rec()&#123; var mychar="I love JavaScript"; alert(mychar); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input name="button" type="button" onClick="rec()" value="点击我，弹出对话框" /&gt;&lt;/body&gt;&lt;/html&gt; JavaScript-确认（confirm 消息对话框）confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 1234567891011function rec()&#123; var mymessage= confirm("你是女士吗？"); if(mymessage==true) &#123; document.write("你是女士!"); &#125; else &#123; document.write("你是男士!"); &#125; &#125; JavaScript-提问（prompt 消息对话框）12345678910111213141516 function rec()&#123;var score; //score变量，用来存储用户输入的成绩值。score = prompt("同学输入成绩",null) ;if(score&gt;=90)&#123; document.write("你很棒!");&#125;else if(score&gt;=70) &#123; document.write("不错吆!");&#125; else&#123; document.write("要努力了!");&#125; &#125; JavaScript-打开新窗口（window.open）open() 方法可以查找一个已经存在或者新建的浏览器窗口。 1window.open([URL], [窗口名称], [参数字符串]) 123function Wopen()&#123; window.open('http://www.imooc.com','_blank','width=600,height=400,top=100,left=0')&#125; JavaScript-关闭窗口（window.close）用法： 1window.close(); //关闭本窗口 或 1&lt;窗口对象&gt;.close(); //关闭指定的窗口 例如:关闭新建的窗口。 1234&lt;script type="text/javascript"&gt; var mywin=window.open("http://www.imooc.com"); mywin.close()&lt;/script&gt; 综合练习1234567891011function openWindow()&#123; // 1.新窗口打开时弹出确认框，是否打开 var msg_confirm = confirm("是否打开窗口？") if(msg_confirm==true)&#123; // 2.通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/ var msg_url = "http://www.imooc.com/" var msg_prompt = prompt("输入网址",msg_url) //3.打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。 window.open(msg_url,"_blank",'width=400,height=500') &#125; &#125; 第3章 你也有控制权(DOM操作)如何用JavaScript去操作HTML元素和CSS样式，实现简单的动态操作。 认识DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: HTML文档可以说由节点构成的集合，三种常见的DOM节点: 1. 元素节点：上图中、、等都是元素节点，即标签。 2. 文本节点:向用户展示的内容，如…中的JavaScript、DOM、CSS等文本。 3. 属性节点:元素属性，如标签的链接属性href=”http://www.imooc.com&quot;。 看下面代码: 1&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt; 通过ID获取元素学过HTML/CSS样式，都知道，网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。 语法: 1document.getElementById(“id”) 结果:null或[object HTMLParagraphElement] 注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。 innerHTML 属性：获取替换内容innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: 1Object.innerHTML 注意: 1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。 2.注意书写，innerHTML区分大小写。 我们通过id=”con”获取 元素，并将元素的内容输出和改变元素内容，代码和结果如下: 改变 HTML 样式HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？ 语法: 1Object.style.property=new style; 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 基本属性表（property）: 注意:该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。 显示和隐藏（display属性）网页中经常会看到显示和隐藏的效果，可通过display属性来设置。 语法： 1Object.style.display = value 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 value取值: 看看下面代码: 控制类名（className 属性）className 属性设置或返回元素的class 属性。 语法： 1object.className = classname 作用: 获取元素的class 属性 为网页内的某个元素指定一个css样式来更改该元素的外观 看看下面代码，获得 元素的 class 属性和改变className： 12345678function add()&#123; var p1 = document.getElementById("p1"); p1.className = "one" &#125; function modify()&#123; var p2 = document.getElementById("p2"); p2.className = "two" &#125; 综合练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" Content="text/html; charset=utf-8" /&gt;&lt;title&gt;javascript&lt;/title&gt;&lt;style type="text/css"&gt;body&#123;font-size:12px;&#125;#txt&#123; height:400px; width:600px; border:#333 solid 1px; padding:5px;&#125;p&#123; line-height:18px; text-indent:2em;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 id="con"&gt;JavaScript课程&lt;/H2&gt; &lt;div id="txt"&gt; &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt; &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt; &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt; &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt; &lt;/div&gt; &lt;form&gt; &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt; &lt;input type="button" value="改变颜色" onClick = "colorChange()"&gt; &lt;input type="button" value="改变宽高" onClick="sizeChange()"&gt; &lt;input type="button" value="隐藏内容" onClick="hide()"&gt; &lt;input type="button" value="显示内容" onClick="display()"&gt; &lt;input type="button" value="取消设置" onClick="cancel()"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt;//定义"改变颜色"的函数 function colorChange()&#123; var obj = document.getElementById("txt"); obj.style.color = "red"; obj.style.backgroundColor = "gray"; &#125;//定义"改变宽高"的函数 function sizeChange()&#123; var obj = document.getElementById("txt"); obj.style.height = "300px"; obj.style.width = "300px"; &#125;//定义"隐藏内容"的函数 function hide()&#123; var obj = document.getElementById("txt"); obj.style.display = "none"; &#125;//定义"显示内容"的函数 function display()&#123; var obj = document.getElementById("txt"); obj.style.display = "block"; &#125;//定义"取消设置"的函数 function cancel()&#123; var message = confirm("是否还原？") if(message==true)&#123; txt.removeAttribute('style'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础 - 1 HTML]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%201%20HTML%2F</url>
    <content type="text"><![CDATA[第1章 Html介绍本章节主要讲解html和css样式的关系，以及html标签、html文件结构、head标签,最后讲解了在html中的注释代码的作用。 关系： 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的： HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 下面给大家布置一个任务，在完成任务的时候，每输入一行代码，代码窗口就会立即显示出效果。 第2章 你要懂的规则(JS基础语法)第3章 一起组团(数组)第4章 跟着我的节奏走(流程控制语句)第5章 小程序，大作用（函数）第6章 事件响应，让网页交互第7章 JavaScript内置对象第8章 浏览器对象第9章 DOM对象，控制HTML元素第10章 编程挑战###]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
