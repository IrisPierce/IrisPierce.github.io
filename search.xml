<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[七面阿里全过程记录，已经上岸]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E4%B8%83%E9%9D%A2%E9%98%BF%E9%87%8C%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%B7%B2%E7%BB%8F%E4%B8%8A%E5%B2%B8%2F</url>
    <content type="text"><![CDATA[个人情况：非C9的985本硕，数据可视分析方向，项目包括科研、前端、iOS 面试时间：3月15日实习申请，4月26日晚上10点收到实习生录用意向书。 面试情况：第一个部门面试四次，评级B+未能入选；第二个部门面试三次，成功上岸。 面经记录：由于没有录音，且面试的时候问题大部分根据项目展开，面经的题目并不齐全，但是我会在最后整理出面试的知识点。 「天猫超市」七面具体情况：4月22日晚上，1个小时，两位技术面试官，一位HR老师。科研项目介绍的时候可能不是很能引起技术面试官的兴趣，考察除了技术基础还包括了一些场景问题，HR老师的问题会考察我的校园生活和个人性格、不足等。最后未来leader非常耐心的介绍了一些组内的技术栈。 项目介绍，难点和优化部分。跨域请求JSONP的实现原理？服务器http header实现跨域？CDN是什么？如何实现该功能？Java的内存机制是什么？介绍MVC模式，react和MVC模式的关系？HTTP请求的流程？DNS解析的过程？浏览器的缓存存在哪里？情景题：设计师给出设计图，如何100%还原设计图？如何布局？六面具体情况：4月21日晚上，54min，交叉面。这次面试不是很理想，部分问题没能回答好，但是在最后面试官老师提出了非常多的阿里前端的必备技能。 建议：需要了解服务端中的数据库、node等，缓存处理高并发的请求，跨域要非常了解，前端工程的优化等 ES6的set和map。组件之间的通信？react是否可以实现基于事件 event的组件通信？前端如何上传图片至服务器？如何跨域？304状态码的过程？浏览器渲染过程？五面具体情况：4月17日晚上，1h15min，组长面，组长非常耐心的介绍了新部门和岗位职责，同时给我的面试提出了一些建议。 建议：前端基础知识；性能：操作系统、CPU；框架及相应的工具webpack、babel；客户端+前端 canvas和svg区别D3.js和antV的区别？react的性能优化「数据中台」四面具体情况：3月26日晚上，54min，交叉面，Echart作者林峰老师，从基础到项目都很细致的对我进行了考察。 数学问题数据结构：数据结构的理解算法：排序的场景三面具体情况：3月25日中午，58min，来自北京的交叉面面试官老师。面试官老师的基础问题部分没说好，还好最后老师对项目比较感兴趣，最后也是关于建议和学习跟我聊了10min左右，非常耐心。 数据结构：为什么需要二叉树？B+树？跳表？操作系统：进程通信方式？拥塞。数据库：了解的数据库？算法：找出小于k的所有质数二面具体情况：3月20日中午，1h多，组长面，是知乎上的流形大神，问了非常多可视化的场景问题。最后评价是可视化算法基础比较好，项目能力需要提高。 可视化项目，及相关展开可视化的流程data transformation、visual structure、view transformation + 交互 场景应用：如果类别多、数据大有遮挡该如何解决？ data transformation： 数据采样 visual structure：已有方式——散点图、三维散点图、平行坐标。我研究的方式——。 view transformation：如果以上方式还是会产生遮挡问题，可以采用一些通道编码，如颜色深浅、透明度、大小——表示该位置的相同类型数据的多少； 热力图、透明度、汇合 交互： 在散点矩阵中使用动画来减轻重叠（Using Animation to Alleviate Overdraw in Multiclass Scatterplot Matrices） 数据预处理——数据缺失和异常异常数据处理经典可视化图标的优缺点：饼图的缺点；玫瑰图的缺点，视觉干扰是什么面向对象思维：绘制折线图和柱状图的代码大部分相似，可以写在一个类中。一个平面n个圆有多少个相交的圆1 遍历的方法。时间复杂度较高。 2 对每一个圆计算其变上有多少个交点，交点数除以2就位改圆的相交圆的个数。将所有相交个数加起来除以2(2个圆相交会有一个相交个数，遍历后算了两遍)，结果为一共有多少个相交的圆。 一面具体情况：3月16日下午，50min多，可是分析算法工程师，问了非常多科研相关的问题，面试官老师非常专业，谷歌后发现老师还会写歌，超级厉害。 高维数据可视分析研究有哪些？t-SNE没回答完整。子空间聚类？知识点计算机基础前端知识可视化]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里天猫超市面试]]></title>
    <url>%2F2019%2F04%2F22%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E9%98%BF%E9%87%8C%E5%A4%A9%E7%8C%AB%E8%B6%85%E5%B8%82%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2018年11月，阿里巴巴天猫和新零售相关战略调整，成立了「天猫超市事业群」，与「天猫事业群」并驾齐驱，是升级版「大天猫」的一大重要板块。 新启航的「天猫超市事业群」，将重回零售本质，致力于创造消费者可感知的价值。新的天猫超市，将超越过往线上的工作方式，融入线下的“新蓝海”， 强化商品、消费者、线下伙伴、供应链的各项能力，整合原有天猫超市和淘鲜达业务，并和阿里大生态内的大卖场、超市等合作伙伴紧密合作， 推进线上线下一体化的超市新零售模式，共同实现“天下超市”的理想。 附相关PR网址： - 阿里巴巴组织架构调整：天猫升级为“大天猫”_事业群 - 搜狐 http://www.sohu.com/a/277841560_561670 - 天猫超市模式生变：架构一划为三代销、采销并行 https://tech.sina.com.cn/i/2019-01-13/doc-ihqfskcn6611066.shtml 三面具体情况：4月22日 晚上 两位技术面试官，一位HR老师。 项目介绍，难点和优化部分。跨域请求JSONP的实现原理？服务器http header实现跨域？CDN是什么？如何实现该功能？Java的内存机制是什么？介绍MVC模式，react和MVC模式的关系？HTTP请求的流程？DNS解析的过程？浏览器的缓存存在哪里？情景题：设计师给出设计图，如何100%还原设计图？如何布局？二面ES6的set和map。组件之间的通信？react是否可以实现基于事件 event的组件通信？可以。bind(this,index)即可以完成。 前端如何上传图片至服务器？如何跨域？ JSONP：原理：为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许。方法：可以通过动态创建script，再请求一个带参网址实现跨域通信。 跨域资源共享（服务端设置http header） 304状态码的过程？第一次访问 200；按F5刷新（第二次访问） 304；按Ctrl+F5强制刷新 200。 304 的标准解释是：客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用。 客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。200后会更改 Last Modified 时间。 一面canvas和svg区别D3.js和antV的区别？react的性能优化部门基本信息]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React - 4 Redux高级]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FReact%20-%205%20Redux%20%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[UI组件和容器组件无状态组件 普通组件： UI组件：UI负责渲染 容器组件：负责逻辑 无状态组件：当普通组件只有render函数的时候，可以使用无状态组件替换该组件。 普通组件的性能比不上无状态组件的性能高 。无状态组件就是一个函数；普通组件是JS的类，类生成的对象里面还有生命周期函数，执行的时候既要执行函数，又要执行render。 如何使用：一般UI组件只负责页面渲染，不负责逻辑，可以定义为一个无状态组件 ajax数据请求12345678910111213141516171819import axios from 'axios';import MockAdapter from 'axios-mock-adapter';// 设置模拟调试器实例const mock = new MockAdapter(axios);mock.onGet('/list.json').reply(200, &#123; list:["iris","jay","gd"]&#125;);//生命周期函数 mount完成时componentDidMount()&#123; axios.get('/list.json').then((res)=&gt;&#123; // 获取模拟调试器上的mock本地数据 const data =res.data.list; // 创建ation，传入data；将action传给store const action = initListAction(data); console.log(action); store.dispatch(action); &#125;)&#125; Redux-thunk中间件实现ajax数据请求配置Redux-thunk：同时使用两个中间件：thunk+devtools(调试工具) 1234567891011121314//使得store既支持window下的devtools，调式stor；同时引入了Redux-thunk//高级配置：若存在该方法，则调用，否则使得其为一个compose函数const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123; &#125;) : compose;// 上述的变量存储一下，顺便将中间件[redux]通过applyMiddleware执行一下，传入进去const enhancer = composeEnhancers( applyMiddleware(thunk),);const store = createStore(reducer, enhancer // applyMiddleware(thunk) ); 把异步操作的代码从组件中移除，移除到action中去。之前actionCreator 里面的任意一个creator一个都是函数，该函数返回的内容是一个对象。 使用redux-thunk后，你的action可以是一个函数了。正常来说是return一个对象，使用redux-thunk后，return的结果可以为一个函数。函数中可以做异步操作。 使用redux-thunk后，action不仅可以是一个action对象（JS对象）了，还可以是一个函数。 构建了一个action，为一个函数，调用dispatch，该action会被自动执行。 123456789101112131415161718192021// ./store/actionCreator.JS// 构建了一个action，返回函数，函数的参数是dispatch，函数内进行异步操作，获取ajax请求，创建action，dispatch action到store，更新storeexport const getTodoList = () =&gt; &#123; //return一个函数，在函数中执行异步ajax操作 return (dispatch) =&gt; &#123; axios.get('/list.json').then((res)=&gt;&#123; // 获取模拟调试器上的mock本地数据 const data =res.data.list; // 创建ation，传入data；将action传给store const action = initListAction(data); dispatch(action); &#125;) &#125;&#125;// TodoList.js // 生命周期函数内，创建action函数，dispatch后执行该函数 componentDidMount()&#123; const action = getTodoList(); store.dispatch(action); &#125; 原因： 把异步函数放在生命周期函数中去做，该生命周期函数会越来越复杂且多，组件会越来越大。 好处1：应该把复杂的业务逻辑和异步函数拆分到一个地方去管理。借助redux-thunk，放在actionCreator去管理。 好处2：放在actionCreator的时候，自动化测试时，测试getTodoList方法，比测试生命周期函数要简单的多。 Redux中间件 action和store之间。 对store的dispatch方法的封装、升级。根据参数不同，执行不同的操作。 原始：接收对象后，将对象直接传递给store。 升级后：传递对象和之前一样；传递函数，不会直接传递，而是先执行，执行完后，若需要调用store，该函数内再调用store。 例子： redux-logger中间件，在传递过程中，将action打印。 redux-thunk异步问题：将异步放在actionCreator中 redux-saga异步问题：将异步单独放在文件中 ✨使用React-Redux重写TodoList安装：yarn add react-redux 提供：Provider组件：核心组件，把store提供给每一个内部组件，也叫提供器 123456789101112import &#123; Provider &#125; from 'react-redux';import store from './store';// DOM返回APP组件，组件内容是一个Provider// Provider 关联store后，将store提供给其内部的所有的组件const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt;);ReactDOM.render(App, document.getElementById('root')); 连接：connect方法，前两个参数为连接的规则，最后的参数为本组件TodoList。 mapStateToProps：store里的数据、和组件里的数据关系关联 mapDispatchToProps：组件里props如何对store里的数据做修改、和store里的dispatch方法做关联。 123456789101112131415161718192021222324252627//把store里的数据，映射到组件，变成组件里的props,将store里的inputValue，赋值给props的inputValueconst mapStateToProps = (state) =&gt; &#123; return &#123; inputValue: state.inputValue &#125;&#125;// 将store.dispatch 方法，挂载到 propsconst mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const action = &#123; type: 'change_input_value', value: e.target.value &#125;; dispatch(action) &#125; &#125;&#125;// 谁和谁连接：本组件TodoList和store做连接// 怎么做链接：规则在mapStateToProps中，把store里的数据，映射到组件，变成组件里的props// TodoList和store关联，store的数据映射到组件的props上；想修改store，通过store的props。export default connect(mapStateToProps, mapDispatchToProps)(TodoList);// 实际上：todoList是一个UI组件，connect把UI组件和业务逻辑（数据、派发）结合，返回的结果为一个容器组件。// 导出的内容就是connect的执行结果：容器组件 ###]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器+前端知识]]></title>
    <url>%2F2019%2F04%2F18%2F%F0%9F%98%BA%E6%B5%8F%E8%A7%88%E5%99%A8%2B%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[浏览器多进程到JS单线程，JS运行机制最全面的一次梳理浏览器内核进程——渲染引擎：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎线程——JS引擎：解析和执行JavaScript来实现网页的动态效果。 http和浏览器的工作原理和内部机制要巩固一下，特别是涉及到性能、进程线程、同步异步什么的 浏览器是多进程的1 浏览器都包含哪些进程？ Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 页面渲染，脚本执行，事件处理等 重点：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 优点：1避免单个page crash影响整个浏览器；2避免第三方插件crash影响整个浏览器；3方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 2 重点：浏览器内核（渲染进程）对于普通的前端操作来说，最终要的是渲染进程，浏览器的渲染进程是多线程的 可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。 GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 浏览器渲染流程 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 从Event Loop谈JS的运行机制为什么JS引擎是单线程的？1.只需要运行JS脚本；2多线程的复杂性，譬如多线程操作一般要加锁。因此最初设计时选择了单线程。 属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。 JS引擎是单线程:1 JS引擎线程；2事件触发线程；3定时触发器线程 事件循环机制 JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 （如此循环；注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件） 定时器调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 前端工程webpack作用：webpack会将不同类型的静态资源，打包成一个JS，在HTML引用该JS的时候，其可以正常运行。 好处：希望零碎的JS打包在一起，减少HTTP请求；使用模块依赖，更新某一模块的时候只需要改一次即可。 开发APP的时候，是一整个JS加载到浏览器中来渲染。可以以该JS文件作为入口。 entry：入口为src/index.js；出口为文件名bundle.js和路径；module的rules webpack会将不同类型的静态资源（index.js文件及其所依赖的Vue、App等），打包成一个JS（完整的bundle.js），在HTML引用该JS的时候，其可以正常运行（且打包出来的是可以在浏览器中直接运行的JS代码）。 XSSXSS 全称 Cross Site Scripting ，跨站脚本攻击。 转义：是让用户的输入不要变成程序，输入的什么就让它输出成什么。 CSP：内容安全策略，Content Security Policy：定义页面上哪一些内容是可被信任的，哪一些内容是不被信任的。比较灵活。 CSRFCSRF： Cross Site Request Foggy，即跨站请求攻击。从别的网站发起一个请求到我们的网站的。 当一个用户登录我们的网站后，在 Cookies 中会存放用户的身份凭证。在大部分时候，就是一个 SessionId 。当用户下次访问我们的网站的时候，我们用这个凭证识别出用户是谁，有没有登录态。 攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 POST\GET请求：如果这个地址是一个发表文章、发布微博甚至转账之类的链接，那用户就在不知情的情况下进行了一些操作。这也是比较严重的安全问题。 判断来源：比较简单，主要是判断referer这个头，如果不是自己的网站，就返回错误。 加 token ：即同样的随机 token，在 cookies 中放一份，在表单中再放一份。这样第三方网站就无法获取到这个 token 是什么。 验证码：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串， 项目上线npm run build 前端的目的搭建前端工程 网络优化 API定制 nodejs层 html14.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 JS12.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS） 回答出概念即可，下面是几个要点 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件 mousedown事件触发后，开始拖拽 mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置 mouseup时，拖拽结束 需要注意浏览器边界的情况]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+Redux+AntD - 0 极简事项.md]]></title>
    <url>%2F2019%2F04%2F16%2F%F0%9F%98%8AReact%2BRedux%2BAntD%20-%200%20%E6%9E%81%E7%AE%80%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[项目介绍阿里交叉面的面试官介绍了技术框架React+Redux+AntD，使用新技术把自己的iOS极简事项改写为前端版本。 ### 项目优化其实项目本身比较简单，我自己就从优化的方面去进行了思考。 1 React本身的性能优化方法： 使用虚拟DOM。减少生成真实DOM时间，且DOM对象比对加快。 虚拟DOM的比对。同层比对+使用key值比对，提升虚拟DOM比对速度 react16，setState性能提升机制，使用异步函数：多次数据改变结合成一次来做，降低虚拟DOM频率 2 性能优化：渲染优化： 1 作用域修改放在constructor构造函数内，保证作用域绑定操作只执行一次 + 避免子组件的无谓渲染。 1this.handleClick = this.handleClick.bind(this); 2 借助生命周期函数：shouldComponentUpdate，提高react组件性能，避免无谓的组件render渲染。 异步优化： 3 发送ajax请求，放在componentDidMount 原因：ajax只需要请求1次，需要在渲染前获取数据。场景：使用ajax异步请求的方式，从我的一个接口上，请求一个远程的todolist数据，将远程数据加载到本地，渲染到页面上。 4 Redux-thunk中间件实现ajax数据请求。 把异步操作的代码从组件中移除，移除到action中去。使用redux-thunk后，action不仅可以是一个action对象（JS对象）了，还可以是一个函数。 原因： 把异步函数放在生命周期函数中去做，该生命周期函数会越来越复杂且多，组件会越来越大。 好处1：应该把复杂的业务逻辑和异步函数拆分到一个地方去管理。借助redux-thunk，放在actionCreator去管理。 好处2：放在actionCreator的时候，自动化测试时，测试getTodoList方法，比测试生命周期函数要简单的多。 异步组件react-loadable：一个动态导入加载组件的高阶组件。页面异步，分割成多个js文件。按需加载 （懒加载） loadable.js：loader：本页面。loading：加载时候显示的内容。 App.js，from修改loadable.js，使用withRouter，让detail有能力获取Rounter的所有参数和内容，即可以获取id。 3 维护性优化，方便测试和找BUG： React是函数式编程，使用前端自动化测试：只需要给函数一个数值，查看输出是否符合预期。 propTypes:组件要接受外部传过来的值，进行类型校验。验证传值。DefaultProps:若父组件未向子组件传值，定义属性默认值。设置默认值 ActionTypes的拆分：action判断的时候，若常量写错了会报异常，字符串不会报异常。方便找出bug。 使用actionCreators统一创建action：自动化测试，有利于代码维护，不然每一个绑定事件的函数都要写一个生成的action，不利于大型项目的维护。 使用UI组件和容器组件，分离UI操作和逻辑操作。 无状态组件：当普通组件只有render函数的时候，可以使用无状态组件替换该组件。 普通组件的性能比不上无状态组件的性能高 。无状态组件就是一个函数；普通组件是JS的类，类生成的对象里面还有生命周期函数，执行的时候既要执行函数，又要执行render。 React-Redux重写TodoList： Provider组件：核心组件，把store提供给每一个内部组件，也叫提供器 连接： connect方法，前两个参数为连接的规则，最后的参数为本组件TodoList。 结果=》todoList是一个UI组件，connect把UI组件和业务逻辑（数据、派发）结合，返回的结果为一个容器组件。 项目对比目标相同：展现UI，监听用户。js单线程。ios主队列=刷新页面。 UI设计： storyboard和纯代码（snp布局）实现 react组件化来实现 传值： 前端是属性传值、子组件调用父组件方法传值。 iOS使用segue正向传值，自定义protocal-delegate反向传值 耗时操作：HTTP等放在异步操作。 ✨需要优化性能： 知识点Redux：数据层框架。将组件中的数据放在一个公用存储区域去存储，组件改变数据，其他组件会感知Redux的改变，再去取数据更新组件。 AntD：统一中台项目的前端 UI 设计，减少设计成本(大型前端项目可能不适用，适合管理系统) React：构建用户界面的JS库。用于构建UI， 是 MVC 中的 V（视图）。 需求分析功能：1 新增任务功能：输入inputValue+添加Item ；2 删除任务功能： 组件：1父组件：新增任务、浏览任务； 2子组件：单个任务的item。 步骤初始实现：一开始是没有使用Redux来存储数据，主要用于父子组件传值来实现功能。 父组件向子组件传值：父组件的属性父组件通过属性的方式向子组件传递参数 子组件通过props的形式接收父组件传递的参数 子组件向父组件传值：通过调用父组件的方法改变数据父组件将方法传递给子组件，子组件调用该方法，需要传的值作为输入参数 Redux实现功能：1 Store的创建 1 创建reducer，把reducer传递给创建store的函数： 输入为state和action，返回为NewState 有一个default值 2 创建store，使用reducer作为参数 2 组件发送需要改变state的action 1 方法内现写action要做什么的那句话(对象) 2 将action传递给store 1store.dispatch(action); 3 store不操作，将action传递给reducer 4 在reducer中，判断action+操作 reducer中判断type 深拷贝原来的state为newState，更新newState 返回newState给store 5 store接受后会替换之前的state 3 组件监听state的改变123456// 1. 组件去订阅store.subscribestore.subscribe(this.hanleStoreChange);// 2. store同步：感知到变化的时候，调用store.getState()重新取数据，再用setState更新组件内容hanleStoreChange()&#123; this.setState(store.getState());&#125;]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+Redux+AntD - 0 极简事项.md]]></title>
    <url>%2F2019%2F04%2F16%2F%F0%9F%98%8AReact%2BRedux%20-%20%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[http和浏览器的工作原理和内部机制要巩固一下，特别是涉及到性能、进程线程、同步异步什么的 1 关于React特点声明式开发减少大量dom操作代码量 可以和其他框架并存react只去管理id=”root”的div的渲染。jQuery可以管理其他div操作。 组件化 区分组件和标签 xxx 组件之间通信：父向子：属性，接收用props。子向父：调用父组件的方法 单向数据流父组件可以向子组件传值（只读），子组件不能去改变这个值。 why单项数据流：防止其中一个改变时出现bug，难以定位是哪一个组件改变导致的错误。 视图层框架只解决数据和渲染的问题，不解决react复杂传值问题，可以借助其他redux等数据传递框架 函数式编程代码逻辑清晰：拆分函数，各司其职； 前端自动化测试便捷：只需要给函数一个数值，查看输出是否符合预期。 3 Redux知识点Redux设计和使用的三大原则 store是唯一的 只有store只有自己能够改变自己的内容 Redux的核心API createStore 创建store store.dispatch 派发action，传递给store store.getState 获取store中所有数据内容 store.subscribe 订阅store的改变。只要store改变，其接收的回调函数就会被执行 Redux中间件 在action和store之间。 对store的dispatch方法的封装、升级。根据参数不同，执行不同的操作。 原始：接收对象后，将对象直接传递给store。 升级后：传递对象和之前一样；传递函数，不会直接传递，而是先执行，执行完后，若需要调用store，该函数内再调用store。 例子： redux-logger中间件，在传递过程中，将action打印。 redux-thunk异步问题：将异步放在actionCreator中 redux-saga异步问题：将异步单独放在文件中 React-ReduxRedux的官方React绑定库 使react组件从redux store中读取数据，并且向store分发actions来更新数据。 提供：Provider组件：核心组件，把store提供给每一个内部组件，也叫提供器功能：从最外部封装了整个应用，并向connect模块传递store。 连接： connect方法，前两个参数为连接的规则，最后的参数为本组件TodoList。mapStateToProps：store里的数据、和组件里的数据关系关联(组件获取store数据) mapDispatchToProps：组件里props如何对store里的数据做修改、和store里的dispatch方法做关联。(组件通过dispatch修改store) // 实际上：todoList是一个UI组件，connect把UI组件和业务逻辑（数据、派发）结合，返回的结果为一个容器组件。// 导出的内容就是connect的执行结果：容器组件 前端知识构建工具webpack]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React - 4 Redux]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FReact%20%20-%20%204%20Redux%2F</url>
    <content type="text"><![CDATA[Redux：数据层框架概念 Redux = Reducer + Flux(数据存储框架，过时了) 将组件中的数据放在一个公用存储区域去存储，组件改变数据，其他组件会感知Redux的改变，再去取数据更新组件。 工作流程 react component：借书的用户 action creators：那句话”我要借什么书” store：图书馆管理员 reducers：管理员的记录本 借书的人说”要借什么书”，图书馆管理员去查阅记录本，记录本上显示这本书在哪里，根据书的位置找到书，并给借书人。 Store的创建引入：yarn add redux 创建reducer，把reducer传递给创建store的函数 使用reducer作为参数，创建store的时候，(创建管理员的时候要把记录本给他 ) Action和reducer的编写主动改变： 方法内现写action要做什么的那句话(对象) 将action传递给store 1store.dispatch(action); store不操作，将action传递给reducer， reducer中判断type 深拷贝原来的state为newState，更新newState 返回newState给store store接受后会替换之前的state Store数据发生改变的时候，组件会感知改变，重新取数据，更新组件内容 12345678// 组件去订阅storethis.handleBtnClick = this.handleBtnClick.bind(this);store.subscribe(this.hanleStoreChange); //store同步：感知到变化的时候，调用store.getState()重新取数据，再用setState更新组件内容 hanleStoreChange()&#123; this.setState(store.getState()); &#125; 删除功能ActionTypes的拆分常量写错了会报异常，字符串不会报异常。方便找出bug 使用actionCreators统一创建action自动化测试，有利于代码维护 AntD的cssRedux知识点Redux设计和使用的三大原则 store是唯一的 只有store只有自己能够改变自己的内容 Reducer必须是个纯函数： 给定固定的输入， 会有固定的输出，(不能有异步操作、不能有和时间相关的操作) 且不会有任何副作用(不能修改参数) Redux的核心API createStore 创建store store.dispatch 派发action，传递给store store.getState 获取store中所有数据内容 store.subscribe 订阅store的改变。只要store改变，其接收的回调函数就会被执行]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期实习面试 - 阿里数据中台前端可视化]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E9%98%BF%E9%87%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[三面准备自我介绍三个部分。 基本信息，中南大学研二王雨思，研究方向是数据可视分析，项目中有专利一项、参与A类会议论文一篇、主持自由探索项目一项，该项目论文预计4月投稿，投稿完成后即可到岗实习。 项目经历，可视分析项目有三项，主要是关于高维数据可视分析的。同时自己对iOS开发有些兴趣，申请了开发者账号，目前审核中APP有两款。 详细介绍我的项目。 首先是自由探索项目：面向分类的感知驱动的可视化监督降维方法。 1背景：大数据时代，涌现出无数复杂的有标签的高维数据：如手写数据、汽车数据、人脸数据等。 2困难：难以分析标签HD数据。降维是分析有标签的高维数据的常用方法。高维数据的低维表示可以帮助用户探索有标签数据中类的分离程度和数据的空间分布。【非监督降维方法PCA：没有考虑类的分离程度；监督降维方法LDA：事先假设数据符合高斯分布，对于复杂的类结构无效；】 3降维方法和直接映射法是帮助分析HD数据的方法：降维方法来源于机器学习。提出优化目标，选择优化方法。我们可以使用基于人类感知的度量DSC。 4本文方法：感知驱动降维PDD：单个投影可能会导致重要的类结构被忽略。 第二个是A类会议IEEE VIS项目：适用于不清楚数据内部特征与结构时候，帮助有效识别低维结构(维度和是否为线性子空间)。当我们指导数据的真实维度之后，则可以使用合适的方式去进行可视化或者数据挖掘等工作。该文章我是帮助师兄做了user study的具体case、discussion部分的对比试验，与其他工作降维方法（包括线性PCA\MDS，非线性tsne等方法）的对比。 第三个是基于 kNN Graph 的内蕴特征抽取可视分析： 内蕴特征-是指底层属性的语义解释。例子：国家生活质量数据集，数据点美国到数据点古巴是如何变化的。得到其解释就特征抽取。data-view-knowledge。 三步骤：初始布局，交互获取路径（点选），结构化投影（使用测地距离）。 例子：国家：趋势美国到古巴、异常：赞比亚。 适合数据中台可视化的原因： 1研究方向是这个，找到如此契合的部门比较难；高维数据可视分析虽然听起来较理论，但是实际上大数据时代，这样的数据确实非常多，需要一些理论的方式去进行可视分析； 2身体素质好，有恒心。为了拿到校运会跨栏金牌，每天坚持晨跑。因此可以接受高强度的工作。 职业规划这个问题其实我自己在选择保研到可视化方向的时候就有想过。 首先，我认为可视化并不是像别人所说只是展示数据的工具，他可以帮助用户探索到自动化方法分析数据无法发现的的特征和模式。 所以我选择了数据可视分析的方向，在研究生阶段从可视化的算法和理论方面先充实自己。 我的职业规划阶段主要分为三个部分，实习之前、入职1~2年、入职2~5年。 实习之前：我会从把红宝书、犀牛书等书籍刷一遍，在实习之前了解所需前端技术；根据团队的技术路线需要，自己实现一些react框架的项目。争取在实习的时候能够按时按量完成导师给的任务。 入职1~3年内：1工作方面：之前的面试官有说过做工程和论文是不一样的，导师对于学术研究是提出一个新的方法去解决问题，需要在短时间内做出case；而前一位面试官说的是工程需要考虑更多的东西，比如大数据渲染的效率。所以我希望能过实现业务，培养工程能力和工程思维。 2学习方面：非常希望学习一些框架和库。“不要重复的造轮子”这句话，我认为初学者都应该无视，不了解轮子怎么知道这个轮子好不好用呢？我们做论文分析的时候也需要做实验比较算法的优越性。 所以我希望从学习熟练使用轮子开始，到看轮子，理解如何造轮子，如果够厉害的话，或许在业务的实践中自己也能成为造轮子团队的一员。 3爱好方面：工作之余还希望能像字体日记APP的开发者一样，做一些自己喜欢iOS开发。之前在react论坛上看到说阿里有的iOS开发是使用前端技术rn weex，希望学习之后帮助自己的从native开发转变为混合开发——做一些Hybrid APP；或者是做一个针对没有计算机课程的县城中学生的在线教育的前端产品。 3~5应该算一个有经验的前端工程师了：1 数据分析能力、交互视觉能力、研发能力 //3同时努力成为一个一专多长的人才。因为制作一个性能高、交互好、视觉美的页面，需要从前端框架选型、架构设计、构建工具，到后端通信机制、设计与交互、网络和浏览器优化等各方面的知识。 2这时候可以通过发表技术博客，提交和参与开源项目，参加业界会议。保持技术交流。 远期规划：这时候的方向其实很难预估。会根据自身情况去调整。 // 但是我有一个比较梦幻的希望，关于前端的教学产品。 因为我小时候在湘西(沈从文写的边城)那边的一个小县城长大，经济和师资其实比起大城市真的有很大差距，接触计算机是在本科。而我看很多大城市长大的同学都是在高中初中就接触过这些前沿课程了。 我希望能在我有一定的技术和社会资源之后，能够推出面向县城无法接触计算机的学生的，类似极客时间、慕课这类的免费的学习数据结构、编程的前端教学产品。让县城的孩子也能早早接触这个世界的前沿科技。这个除了网页端还可能需要一个安卓端，因为县城的家长大部分用的都是oppo、vivo手机。 更宏大的理想就是可以帮助师资力量非常弱的村镇里面的小学生和乡村教师（我老家那种基本就几个村在一个镇上学，老师也是一个人教2、3门课），全镇购置为每个班计算机设备+投影仪，就可以利用互联网课堂学习基础课程。没有生物化学实验室，可以使用可视化技术在web端模拟实验；地理也可以用3D可视化技术帮助理解。 以上的想法老师您可能觉得比较幼稚，因为这还需要考虑很多课程版权、社会实践等因素。但是这是我作为一个来自少数民族地区学生的一点想法。 谢谢。 你理解的 Web 前端未来的发展我认为随着 HTML、CSS 等的发展，网页上能做的事情越来越丰富了，包括更酷炫的前端呈现方式、音视频的处理，更趋向于能够做 Native 应用能做的事情了，可能以后 Web 和 Native 的边界会越来越模糊。 比如说现在的开发中很多都是用 Hybrid APP。比如微信在钱包里面的理财就是网页，但是基础的聊天、朋友圈都是原生（Native) APP。框架是原生的，但是其他的详细内容就是网页封装。 优势和缺点人其实比较难正确认识自己，但是基于一些师长朋友的评价和日常总结，我觉得我的优点是： 1、可视化背景：虽然我研究的是高维数据可视化，可能初期没有研究交通信息可视化、时序数据可视化的同学的项目更适合于工程。但是现如今很多数据都是高维多元数据，如商品数据、人脸图像数据等。 而直接使用一些很成熟的方法可视化这些高维数据不一定是最好的，我们或许可以从可视化顶级会议IEEE VIS上面去阅读一些新的方法，来试着更新可视化流程、降维方法和交互手段。 2、热爱学习新事物：在Coursera上自习Andrew ng的ML，拿了97分；在Java上面写的小游戏、也会在自学安卓、iOS的时候再写一遍；同时自己对iOS的开发很感兴趣，觉得能推出一些对受众有用的产品就会很酷。后期希望学习混合开发APP。 3、有坚持精神且身体好之前因为每次跨栏只有银牌和铜牌，最后气不过就坚持晨跑，最后终于拿下了金牌。同时坚持锻炼也让我的身体素质很好，可以接受高强度的工作。 4、缺点是：个人爱好有时候比较广泛，如本科时期喜欢爵士舞、话剧、乐器、运动，还喜欢去做学生干部工作，就有一些会影响自己的学习时间，成绩只保持到刚好保研的边缘。但是研究生时候算是改正了一些，只保留了每周去学爵士的兴趣。但是这个缺点我能保证，以后绝对不影响我的工作。 我是如何面试一位前端工程师：https://zhuanlan.zhihu.com/p/30487025 Q1 过去的思考和总结最有难度的事情：项目一自己写论文比跟着导师写难度大多了。基本没两天都会有新的问题出现。然后又要去看论文想方法。 之前面试的总结一面： 主要是科研项目表达逻辑的不足。 高维数据可视分析科研项目在没有图表支撑的情况下，是比较难描述清楚的。所以我再次整合了逻辑，从背景、目的、方法以及困难三个方面总结了自己的项目。在二面的时候，项目表述就比较完善了。 二面： 理论研究还行，包括高维数据可视分析流程和降维方法，对工业级别项目了解不足，这也是以后我会努力的方向。近期看了18年云溪大会上的企业中台架构，大中台小前台的展示；也翻阅了《阿里巴巴大数据实践》的总览第一章、和日志采集第二章。但是我觉得有的部分还是没那么容易理解。这一点希望能在工作中去实践。 《大数据之路：阿里巴巴大数据实践》 三面： 操作系统调度 进程通信方式？——几种 线程 数据库了解吗？——不了解 操作系统：B+树 判断是否为质数 可视分析流程数据转化、可视映射、视图转化 原数据-&gt;转化后的数据-&gt;可视结构-&gt;视图 如：我们选择线性投影将30维的原数据降为5维度的转化数据，再使用平行坐标视觉映射转为可视结构，然而数据有相互遮挡，则选择PCP方法视图转化至视图上。最后呈现热力图式的平行坐标。 D3.js源码阅读： 把输入的原始数据转化成为标准的D3可接受的数据格式 根据原始数据定义好x轴函数、y轴函数和定义好作图方式(如d3.line) 在SVG上面画出x轴y轴、根据原始数据结合x轴及y轴函数作线状图 再画出标题等细节的东西 最后，给已经完成的图形添加动画效果 D3力导向图。 模块1：center.js 设置力导图点阵中心 虽然每个节点的坐标都是计算得到的，但总有开始状态。开始状态下的坐标设置的是获取的随机数，这个随机数可以根据当前 View 的宽高来限定。 遍历所有 FNode，给每个 FNode 设置一个随机获取的坐标。遍历所有 FLink，计算每条 FLink 的 sourceNode 和 targetNode 的距离 d，利用 α 值和 FLink 的拉力，计算 sourceNode 和 targetNode 的距离的减少量。 遍历所有 FNode，使每个节点向 View 中心聚拢。 模块3：jiggle.js 微小晃动随机数 模块4：collide.js 碰撞 https://segmentfault.com/a/1190000008578391 问面试官的问题可以了解一下团队对于实习生的培养吗？如果有幸接到offer后，是否可以联系组内前辈去问一下需要学习哪些技能，因为现在距离暑期实习还有一两个月时间，是否可以预备学习一些组内的必备技能？ 您是我一个位BOSS面的面试官，可以了解一下作为高级前端工程师的一些工作的日常吗？之前总听说架构这些词，但是在校园里面确实没有接触过您这样的高级工程师。谢谢！ 位图和矢量图1.位图图像(bitmap)亦称为点阵图像或绘制图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。 矢量图：矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。 数据中台阿里中台主要由业务中台和数字中台并肩构成了双中台，并肩扛起了所有前台业务。 业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用共享的核心能力，实现了后端业务资源到前台易用能力的转化。 数据中台从后台及业务中台将数据流入，完成海量数据的存储、计算、产品化包装过程，构成企业的核心数据能力，为前台基于数据的定制化创新和业务中台基于数据反馈的持续演进提供了强大支撑。业务中台与数据中台，相辅相成，互相支撑，一起构建起了战场强大的后方炮火群。 二面可视化项目，及相关展开可视化的流程data transformation、visual structure、view transformation + 交互 如果类别多、数据大有遮挡该如何解决？ data transformation： 数据采样 visual structure：已有方式——散点图、三维散点图、平行坐标。我研究的方式——。 view transformation：如果以上方式还是会产生遮挡问题，可以采用一些通道编码，如颜色深浅、透明度、大小——表示该位置的相同类型数据的多少； 热力图、透明度、汇合 交互： 在散点矩阵中使用动画来减轻重叠（Using Animation to Alleviate Overdraw in Multiclass Scatterplot Matrices） 数据预处理——数据缺失和异常缺失值处理：造成数据缺失的原因是多方面的，主要可能有以下几种： 有些信息暂时无法获取，致使一部分属性值空缺出来。 有些信息因为一些人为因素而丢失了。 有些对象的某个或某些属性是不可用的。如一个未婚者的配偶姓名。 获取这些信息的代价太大，从而未获取数据。 空值处理的重要性：空值的存在，造成了以下影响： 系统丢失了大量的有用信息； 系统的不确定性更加显著，系统中的确定性成分更难把握； 包含空值的数据会使挖掘过程陷入混乱，导致不可靠的输出。 空值处理的方法：一、删除元组将存在遗漏信息属性值的对象（记录）删除，从而得到一个完备的信息表。这种方法在对象有多个属性缺失值、被删除的含缺失值的对象与信息表中的数据量相比非常小的情况下是非常有效的。然而这种方法丢弃了大量隐藏在这些对象中的信息。在信息表中对象很少的情况下会影响到结果的正确性，可能导致数据发生偏离，从而引出错误的结论。 二、数据补齐这类方法是基于统计学原理用一定的值去填充空值，从而使信息表完备化。数据挖掘中常用的有以下几种补齐方法： 人工填写这个方法产生数据偏离最小，是填充效果最好的一种。当数据规模很大、空值很多的时候，该方法是不可行的。 特殊值填充将空值作为一种特殊的属性值来处理，它不同于其他的任何属性值。如所有的空值都用“unknown”填充。这样将形成另一个概念，可能导致严重的数据偏离，一般不使用。 平均值填充如果空值是数值属性，就使用该属性在其他所有对象的取值的平均值来填充该缺失的属性值.如果空值是非数值属性，就根据统计学中的众数原理，用该属性在其他所有对象出现频率最高的值来补齐该缺失的属性值。 热卡填充（就近补齐）对于一个包含空值的对象，热卡填充法在完整数据中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。不同的问题选用不同的标准来对相似进行判定。 K最近邻法先根据欧式距离或相关分析来确定距离具有缺失数据样本最近的K个样本，将这K个值加权平均来估计该样本的缺失数据。 使用所有可能的值填充这种方法是用空缺属性值的所有可能的属性取值来填充，能够得到较好的补齐效果。但是当数据量很大或者遗漏的属性值较多时，其计算的代价很大，可能的测试方案很多。 回归基于完整的数据集，建立回归方程（模型）。对于包含空值的对象，将已知属性值代入方程来估计未知属性值，以此估计值来进行填充。 期望值最大化方法（EM）在缺失类型为随机缺失的条件下，假设模型对于完整的样本是正确的，通过观测数据的边际分布可以对未知参数进行极大似然估计。它一个重要前提：适用于大样本。有效样本的数量足够以保证ML估计值是渐近无偏的并服从正态分布。但是这种方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂。 三、不处理——使用深度学习、数据挖掘方式填补直接在包含空值的数据上进行数据挖掘。这类方法包括贝叶斯网络和人工神经网络等。 异常处理异常值的判别方法： 简单统计分析对属性值进行一个描述性的统计（规定范围），从而查看哪些值是不合理的（范围以外的值）。 3δ原则若数据服从正态分布：根据正态分布的定义可知，距离平均值3δ之外的概率为 P(|x-μ|&gt;3δ) &lt;= 0.003 ，这属于极[小概率事件]，在默认情况下我们可以认定，距离超过平均值3δ的样本是不存在的。因此，当样本距离平均值大于3δ，认为该样本为异常值。 使用距离检测多元离群点当数据不服从正态分布时，可以通过远离平均距离多少倍的标准差来判定，多少倍的取值需要根据经验和实际情况来决定。 可视化结果后的判定 异常值的处理方法： 删除含有异常值的记录 将异常值视为缺失值，使用缺失值处理方法来处理 用平均值来修正 不处理 经典可视化图标的优缺点饼图的缺点 玫瑰图的缺点，视觉干扰是什么 场景应用解决分类数据可视化中类别过多、数据量过多的遮挡问题。 数据部分： 可视化部分： 交互部分： 面向对象思维绘制折线图和柱状图的代码大部分相似，可以写在一个类中。 一个平面n个圆有多少个相交的圆1 遍历的方法。时间复杂度较高。 2 对每一个圆计算其变上有多少个交点，交点数除以2就位改圆的相交圆的个数。将所有相交个数加起来除以2(2个圆相交会有一个相交个数，遍历后算了两遍)，结果为一共有多少个相交的圆。 一面t-SNE没回答完整。 高维数据可视分析研究有哪些？ 子空间聚类？ 常问问题Q1：基础知识Q2可视化图表：比如在没写过图表的前提下，怎么抽象数据与图形的映射，怎么去组合不同的图表部件。 要从图表类型的隐喻上进行区分饼图表达的是一个整体和局部的关系，也就是一个部分占据整体的多少比例。柱状图和折线图较为接近，通常前者表示不同对象数据的对比，后者更常用作表示同一对象数据在不同（时间）维度上的趋势。 首先，饼图中的类目不应太多，否则信息很分散，不知道作者想表达什么信息。 其次，饼图的颜色不要五颜六色，除了用以区分类目之外，颜色还可以传递更多有效信息。比如上图用绿色表示正确，灰色表示错误，是符合一般对颜色的认知的，并且绿色的类目更醒目，第一眼就能关注到；相反，如果用普通的三种颜色表示三个类目，则读者很难一眼从图中解读出有效信息。 第三，区分出想表明特定意思的类目。比如上图将正确的类目和错误的类目分隔开，读者很容易抓取到关键信息。 南丁格尔玫瑰图：误导在于，数据的比值为到底是半径比、面积比、还是角度比？ 第一种图将数据映射到半径；第二种图将数据映射到半径和角度；第三将图将数据映射到角度。 何时使用？ Q3前端设计：常问的一个校招问题，有一块区域要展示一组数据，但数据需要请求 3 个接口才能计算得到，请问前端是怎么做的，如何优化，前端什么情况下可以放弃合并接口的要求。这个地方至少会考察到异步，本地缓存，延展下会问下并发，竞态，协程等。 HR面试准备1、为什么想加入这家公司？你需要了解下这家公司的文化和氛围。 2、为什么离开上一家公司？钱少，不能实现梦想，还是有哪些不爽的地方。如果是换工作为了实现梦想，那么你的梦想是什么。不爽的地方如果在新公司再遇到怎么处理。 3、你的职业规划是什么？ 4、当你遇到瓶颈的时候你怎么办？ 5、这些年你每年的成长是什么？怎么能体现你的进步？ 6、谈谈你对阿里的企业文化理解？ 7、你的期望薪资？ 8、项目中遇到的最大挑战是什么？怎么解决的？ 9、最有成就感的事情是？ 10、怎么看待加班（你能接受996、997、007吗）？ 11、说说自己性格上的优缺点（描述一下自己的性格） 12、自己觉得自己工作上的短板/优点是什么？ 13、可以接受降薪吗？ 作者：阅跑影财者 链接：https://www.jianshu.com/p/a1863ef1610f 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期实习面试 - 阿里数据中台前端可视化总结]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E9%98%BF%E9%87%8C%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[三面数据结构：为什么需要二叉树？ B+树？ 跳表？ 操作系统：进程通信方式？ 拥塞 数据库：数据库了解吗？ 算法：找出小于k的所有质数 可视分析流程数据转化、可视映射、视图转化 原数据-&gt;转化后的数据-&gt;可视结构-&gt;视图 如：我们选择线性投影将30维的原数据降为5维度的转化数据，再使用平行坐标视觉映射转为可视结构，然而数据有相互遮挡，则选择PCP方法视图转化至视图上。最后呈现热力图式的平行坐标。 D3.js源码阅读： 把输入的原始数据转化成为标准的D3可接受的数据格式 根据原始数据定义好x轴函数、y轴函数和定义好作图方式(如d3.line) 在SVG上面画出x轴y轴、根据原始数据结合x轴及y轴函数作线状图 再画出标题等细节的东西 最后，给已经完成的图形添加动画效果 D3力导向图。 模块1：center.js 设置力导图点阵中心 虽然每个节点的坐标都是计算得到的，但总有开始状态。开始状态下的坐标设置的是获取的随机数，这个随机数可以根据当前 View 的宽高来限定。 遍历所有 FNode，给每个 FNode 设置一个随机获取的坐标。遍历所有 FLink，计算每条 FLink 的 sourceNode 和 targetNode 的距离 d，利用 α 值和 FLink 的拉力，计算 sourceNode 和 targetNode 的距离的减少量。 遍历所有 FNode，使每个节点向 View 中心聚拢。 模块3：jiggle.js 微小晃动随机数 模块4：collide.js 碰撞 https://segmentfault.com/a/1190000008578391 问面试官的问题可以了解一下团队对于实习生的培养吗？如果有幸接到offer后，是否可以联系组内前辈去问一下需要学习哪些技能，因为现在距离暑期实习还有一两个月时间，是否可以预备学习一些组内的必备技能？ 您是我一个位BOSS面的面试官，可以了解一下作为高级前端工程师的一些工作的日常吗？之前总听说架构这些词，但是在校园里面确实没有接触过您这样的高级工程师。谢谢！ 位图和矢量图1.位图图像(bitmap)亦称为点阵图像或绘制图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。 矢量图：矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。 数据中台阿里中台主要由业务中台和数字中台并肩构成了双中台，并肩扛起了所有前台业务。 业务中台将后台资源进行抽象包装整合，转化为前台友好的可重用共享的核心能力，实现了后端业务资源到前台易用能力的转化。 数据中台从后台及业务中台将数据流入，完成海量数据的存储、计算、产品化包装过程，构成企业的核心数据能力，为前台基于数据的定制化创新和业务中台基于数据反馈的持续演进提供了强大支撑。业务中台与数据中台，相辅相成，互相支撑，一起构建起了战场强大的后方炮火群。 二面可视化项目，及相关展开可视化的流程data transformation、visual structure、view transformation + 交互 如果类别多、数据大有遮挡该如何解决？ data transformation： 数据采样 visual structure：已有方式——散点图、三维散点图、平行坐标。我研究的方式——。 view transformation：如果以上方式还是会产生遮挡问题，可以采用一些通道编码，如颜色深浅、透明度、大小——表示该位置的相同类型数据的多少； 热力图、透明度、汇合 交互： 在散点矩阵中使用动画来减轻重叠（Using Animation to Alleviate Overdraw in Multiclass Scatterplot Matrices） 数据预处理——数据缺失和异常缺失值处理：造成数据缺失的原因是多方面的，主要可能有以下几种： 有些信息暂时无法获取，致使一部分属性值空缺出来。 有些信息因为一些人为因素而丢失了。 有些对象的某个或某些属性是不可用的。如一个未婚者的配偶姓名。 获取这些信息的代价太大，从而未获取数据。 空值处理的重要性：空值的存在，造成了以下影响： 系统丢失了大量的有用信息； 系统的不确定性更加显著，系统中的确定性成分更难把握； 包含空值的数据会使挖掘过程陷入混乱，导致不可靠的输出。 空值处理的方法：一、删除元组将存在遗漏信息属性值的对象（记录）删除，从而得到一个完备的信息表。这种方法在对象有多个属性缺失值、被删除的含缺失值的对象与信息表中的数据量相比非常小的情况下是非常有效的。然而这种方法丢弃了大量隐藏在这些对象中的信息。在信息表中对象很少的情况下会影响到结果的正确性，可能导致数据发生偏离，从而引出错误的结论。 二、数据补齐这类方法是基于统计学原理用一定的值去填充空值，从而使信息表完备化。数据挖掘中常用的有以下几种补齐方法： 人工填写这个方法产生数据偏离最小，是填充效果最好的一种。当数据规模很大、空值很多的时候，该方法是不可行的。 特殊值填充将空值作为一种特殊的属性值来处理，它不同于其他的任何属性值。如所有的空值都用“unknown”填充。这样将形成另一个概念，可能导致严重的数据偏离，一般不使用。 平均值填充如果空值是数值属性，就使用该属性在其他所有对象的取值的平均值来填充该缺失的属性值.如果空值是非数值属性，就根据统计学中的众数原理，用该属性在其他所有对象出现频率最高的值来补齐该缺失的属性值。 热卡填充（就近补齐）对于一个包含空值的对象，热卡填充法在完整数据中找到一个与它最相似的对象，然后用这个相似对象的值来进行填充。不同的问题选用不同的标准来对相似进行判定。 K最近邻法先根据欧式距离或相关分析来确定距离具有缺失数据样本最近的K个样本，将这K个值加权平均来估计该样本的缺失数据。 使用所有可能的值填充这种方法是用空缺属性值的所有可能的属性取值来填充，能够得到较好的补齐效果。但是当数据量很大或者遗漏的属性值较多时，其计算的代价很大，可能的测试方案很多。 回归基于完整的数据集，建立回归方程（模型）。对于包含空值的对象，将已知属性值代入方程来估计未知属性值，以此估计值来进行填充。 期望值最大化方法（EM）在缺失类型为随机缺失的条件下，假设模型对于完整的样本是正确的，通过观测数据的边际分布可以对未知参数进行极大似然估计。它一个重要前提：适用于大样本。有效样本的数量足够以保证ML估计值是渐近无偏的并服从正态分布。但是这种方法可能会陷入局部极值，收敛速度也不是很快，并且计算很复杂。 三、不处理——使用深度学习、数据挖掘方式填补直接在包含空值的数据上进行数据挖掘。这类方法包括贝叶斯网络和人工神经网络等。 异常处理异常值的判别方法： 简单统计分析对属性值进行一个描述性的统计（规定范围），从而查看哪些值是不合理的（范围以外的值）。 3δ原则若数据服从正态分布：根据正态分布的定义可知，距离平均值3δ之外的概率为 P(|x-μ|&gt;3δ) &lt;= 0.003 ，这属于极[小概率事件]，在默认情况下我们可以认定，距离超过平均值3δ的样本是不存在的。因此，当样本距离平均值大于3δ，认为该样本为异常值。 使用距离检测多元离群点当数据不服从正态分布时，可以通过远离平均距离多少倍的标准差来判定，多少倍的取值需要根据经验和实际情况来决定。 可视化结果后的判定 异常值的处理方法： 删除含有异常值的记录 将异常值视为缺失值，使用缺失值处理方法来处理 用平均值来修正 不处理 经典可视化图标的优缺点饼图的缺点 玫瑰图的缺点，视觉干扰是什么 场景应用解决分类数据可视化中类别过多、数据量过多的遮挡问题。 数据部分： 可视化部分： 交互部分： 面向对象思维绘制折线图和柱状图的代码大部分相似，可以写在一个类中。 一个平面n个圆有多少个相交的圆1 遍历的方法。时间复杂度较高。 2 对每一个圆计算其变上有多少个交点，交点数除以2就位改圆的相交圆的个数。将所有相交个数加起来除以2(2个圆相交会有一个相交个数，遍历后算了两遍)，结果为一共有多少个相交的圆。 一面t-SNE没回答完整。 高维数据可视分析研究有哪些？ 子空间聚类？ 常问问题Q1：基础知识Q2可视化图表：比如在没写过图表的前提下，怎么抽象数据与图形的映射，怎么去组合不同的图表部件。 要从图表类型的隐喻上进行区分饼图表达的是一个整体和局部的关系，也就是一个部分占据整体的多少比例。柱状图和折线图较为接近，通常前者表示不同对象数据的对比，后者更常用作表示同一对象数据在不同（时间）维度上的趋势。 首先，饼图中的类目不应太多，否则信息很分散，不知道作者想表达什么信息。 其次，饼图的颜色不要五颜六色，除了用以区分类目之外，颜色还可以传递更多有效信息。比如上图用绿色表示正确，灰色表示错误，是符合一般对颜色的认知的，并且绿色的类目更醒目，第一眼就能关注到；相反，如果用普通的三种颜色表示三个类目，则读者很难一眼从图中解读出有效信息。 第三，区分出想表明特定意思的类目。比如上图将正确的类目和错误的类目分隔开，读者很容易抓取到关键信息。 南丁格尔玫瑰图：误导在于，数据的比值为到底是半径比、面积比、还是角度比？ 第一种图将数据映射到半径；第二种图将数据映射到半径和角度；第三将图将数据映射到角度。 何时使用？ Q3前端设计：常问的一个校招问题，有一块区域要展示一组数据，但数据需要请求 3 个接口才能计算得到，请问前端是怎么做的，如何优化，前端什么情况下可以放弃合并接口的要求。这个地方至少会考察到异步，本地缓存，延展下会问下并发，竞态，协程等。 HR面试准备1、为什么想加入这家公司？你需要了解下这家公司的文化和氛围。 2、为什么离开上一家公司？钱少，不能实现梦想，还是有哪些不爽的地方。如果是换工作为了实现梦想，那么你的梦想是什么。不爽的地方如果在新公司再遇到怎么处理。 3、你的职业规划是什么？ 4、当你遇到瓶颈的时候你怎么办？ 5、这些年你每年的成长是什么？怎么能体现你的进步？ 6、谈谈你对阿里的企业文化理解？ 7、你的期望薪资？ 8、项目中遇到的最大挑战是什么？怎么解决的？ 9、最有成就感的事情是？ 10、怎么看待加班（你能接受996、997、007吗）？ 11、说说自己性格上的优缺点（描述一下自己的性格） 12、自己觉得自己工作上的短板/优点是什么？ 13、可以接受降薪吗？ 作者：阅跑影财者 链接：https://www.jianshu.com/p/a1863ef1610f 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发和研究合集]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%BC%80%E5%8F%91%E4%B8%8E%E7%A0%94%E7%A9%B6%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[包括研究项目和开发的APP。（更新ing） 研究项目合集自由探索——面向分类的感知驱动的可视化监督降维方法成绩：自由探索项目，预计4月-5月投稿TVCG。（负责人） 背景：有标签的高维数据大数据时代，涌现出无数复杂的有标签的高维数据：如手写数据、汽车数据、人脸数据等。 困难：难以分析标签HD数据降维是分析有标签的高维数据的常用方法。 高维数据的低维表示可以帮助用户探索有标签数据中类的分离程度和数据的空间分布。 非监督降维方法PCA：没有考虑类的分离程度；监督降维方法LDA：事先假设数据符合高斯分布，对于复杂的类结构无效；感知驱动降维PDD：单个投影可能会导致重要的类结构被忽略。 方法：本文提出了一种感知驱动的线性降维方法，寻求生成具有最大视觉分离程度、最少数量的最优二维投影集合。 困难1：发现单个视图降维方法的不足一开始构建单个视图，发现类别多的时候无法构建 目标函数：为了最大化非线性目标函数dDSC。优化方法：使用模拟退火算法，通过比较随机生成的投影结果的costFuction，找出全局最优值。得到最优的投影结果展示分类数据。 发现：真实数据中可能存在很多类，如服装数据包括：睡衣、风衣、内衣等各种内容。 技术：D3是Data-Driven Document的缩写，从字面上理解就是数据驱动文本。 基于 kNN Graph的内蕴特征抽取可视分析背景高维数据(High-Dimensional Data)，是指向每个数据有多个属性的数据。现实世界中的高维数据中的样本点，往往是分布在一个或者多个低维度的非线性的流形结构之中，如何找出隐藏在高维数据中的低维结构与特征是目前我们所面临的问题。 特征抽取是获取数据特征的重要方式。分为线性和非线性方式，线性提取方式是简单的原始维度线性组合，用户根据自己的喜好选择正向负向的点；非线性为点选绘制自由曲线，产生一个贴合用户认知的非线性模型的内蕴特征轴。 选取点对、选取点序列、画自由曲线等三种指定内蕴轴的交互式方法 例子图 5-3(a)表示了全球生活质量形状趋势(图中箭头方向)，按照其趋势绘制自由曲线，将在散点图中得到新的坐标轴，图 5-3(b)显示了直方图和河流图。 趋势：在图中可看出从左到右,正向的指数降低,如购买力指数(蓝色)，安全指数(浅蓝色)，和医疗指数(橙色)，而负向指数增加，如交通通勤时间指数(浅绿色)和污染指数(红色)，随着X 轴增加，国家生活质量下降，该轴代表了生活质量下降的趋势。 异常：卢旺达，购买力低，然而，安全与卫生保健较高，印证了它是非洲排名第一的国家，政府效率高的信息。委内瑞拉购买力低远远低于其他国家，发现其正面临经济危机的。 有 698 个图像和 4096 个维度，每个维度都表示为一个像素值。为了方便可视化，数据预处理，使用 PCA 将维数减少到 35 维。 节点-链接布局呈现了一个圈的形状(图 5-4(a))。用户想知道圆圈的方向是否为全局模式。于是，他沿着圆的方向画了一条自由的线，但是发现有脸部姿势和光线的两个变化，同时他注意到交互绘制的草图的中心部分只呈现出左右姿势变换。他决定探索这个圈的主要部分。首先，他沿着第一个主要方向画了草图 (在图(a)的红色路径)， 生成的轴显示了从左到右脸部姿势的变化(对应图 5-4(c)中的 x 轴)。接着，他沿着第 二个主要方向 (图 5-4(a)中的绿色路径)绘制了自由曲线，所构造的轴是脸部从上到 下的姿势变化(对应图(c)中的 y 轴)。最后，他沿着其余部分绘制自由曲线(图(a))，改方向表征了光线由暗到明的变化。 高维数据中的低维结构的可视探索成绩：并推荐可视化顶级刊 TVCG。非学生一作，负责user study和对比试验。 问题：高维数据集中往往含有不同结构的低维结构，当未知数据集中的低维结构与当前的可视化方法的假设不匹配时，可视化结果将难以理解。 解决：可视分析方法帮助用户有效地识别低维结构及关键特征，为进一步分析提供关键结构信息。 方法：t-SNE初步提供初始聚类信息：当我们想对高维数据集进行分类，但又不清楚这个数据集有没有很好的可分性（同类之间间隔小、异类之间间隔大）时，可以通过t-SNE将数据投影到2维或3维空间中观察一下：如果在低维空间中具有可分性，则数据是可分的；如果在低维空间中不可分，则可能是因为数据集本身不可分，或者数据集中的数据不适合投影到低维空间。 局部切空间-测地距离视图用来发现子空间 2个滚石图拐点为子空间维度 考勤管理系统成绩：中南大学学报审稿中，EI期刊。负责需求设计： 主页面： 细节视图： 成员当日考勤部分： 个人多日考勤细节以及交互： 考勤统计视图： APP项目合集编码工具： Xcode 10.1，Swift 4.2，UIKit 设计工具：Adobe Inllustrator， 设计icon ， 生成icon 第三工具：移动端火热数据库 Realm，天气API等 思路来源：平时喜欢在APP store里面下载一些独立开发者的APP。这些APP部分思路来自于优秀的APP（如羡辙-2019字体日历、素记 等），部分是自己生活需要的简单小功能。 代码方面：大部分使用了Storyboard，UI设计需要；纯手写代码在 每日一个swift小程序内 开源项目：暂未整理完成 上架中： Project : Todos 极简事项 需求分析：iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 技术： 数据存储：先学习了userDefault，再改为时下火热的移动端数据库Realm存储数据 TableView 具体实现 Project : Weather 元气天气 需求分析：让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 技术： 页面传值 第三方库管理器 具体实现 Project 3 : Quizzler 奇怪问答 需求分析：该问答APP可以修改为任意主题的答题APP。目前想法是改为数据结构基础知识的APP，因为我自己可以用该APP为了实习面试而刷题。 技术： SVM模式 题库存储：realm移动端数据库 具体实现 Project 4 : Piano 木琴 按下不同的按键，发出不同的音调。 Project 3 : Dicee 麻将骰子模拟器 技术： 具体实现 Project 2 : Magic 8 Ball 问答魔力球 Project 1 : 计时器 技术： SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 具体实现]]></content>
      <categories>
        <category>可视分析</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>可视分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化 - 经典的图表分析]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20-%20%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[柱状图 Bar Chart - 比较其中一个轴表示需要对比的分类维度，另一个轴代表相应的数值。 柱状图描述的是分类数据，回答的是每一个分类中“有多少？”这个问题。 类别 纵向柱状图：&lt;12条数据，类别最好使用不同颜色表示 横向柱状图：&lt;30条数据, 适合场景 - 类别对比适合应用到分类数据对比。 不适合场景 分类太多不适合使用纵向柱状图。 不适合表示趋势 对比 柱状图适合多个类别的大小、数值对比 折线图用于连续数值(时间)或有序分类的变化趋势 饼图展示分类占比情况 南丁格尔玫瑰图通过半径比较，柱状图通过矩形长度比较 折线图 Line chart - 趋势显示数据在一个连续的时间间隔或者时间跨度上的变化，它的特点是反映事物随时间或有序类别而变化的趋势。 适合的场景例子：有序的因变量，比如：时间。 折线图可以很好地表现数据递减、增减的速率、增减的规律、峰值等特征。 不适合的场景当水平轴的数据类型为无序的分类或者垂直轴的数据类型为连续时间时，不适合使用折线图。 当折线的条数过多时不建议将多条线绘制在一张图上，可以控制仅显示一条线来解决这个问题。 对比 - 折线图和面积图 折线图和面积图都可以表示一段时间（或者有序分类）的趋势，相比之下面积图的表现力更强一些 面积图还可以表示数据的上下限，例如可以表示温度的最小值、最大值 层叠面积图：河流图，清晰的反应每个数值所占百分比随时间或类别变化的趋势线 饼图 - 经常被滥用优点： 显示部分到整体的关系 熟悉的形状 缺点： 难以阅读，因为它更容易区分长度差异而不是角度差异 它很容易被滥用 因为人类大脑可以更容易地比较长度而不是角度。 适合的场景例子1: 展示 2 个分类的占比情况。 例子2：多个但不超过 9 个分类的占比情况。 不适合的场景例子1：分类过多的场景。推荐使用横向柱状图。 例子2: 分类占比差别不明显的场景 对比 - 饼图和南丁格尔玫瑰图 饼图通过弧度的大小来对比数据。 南丁格尔图通过半径的大小来对比数据。 直方图 Histogram - 分布形状类似柱状图却有着与柱状图完全不同的含义。直方图牵涉统计学的概念，首先要对数据进行分组，然后统计每个分组内数据元的数量。 首先要对数据进行分组，然后统计每个分组内数据元的数量。 在平面直角坐标系中，横轴标出每个组的端点，纵轴表示频数，每个矩形的高代表对应的频数，称这样的统计图为频数分布直方图。 类别 非标准的直方图：纵轴表示数量 频数分布直方图：纵轴为频数 适合的场景 - 数据分布 用于表示分布情况 用于观察异常或孤立数据 不适合的场景抽取的样本数量过小，将会产生较大误差，可信度低，也就失去了统计的意义。因此，样本数不应少于 50 个。 直方图与柱状图对比 柱状图是以矩形的长度表示每一组的频数或数量，其宽度(表示类别)则是固定的，利于较小的数据集分析。 直方图是以矩形的长度表示每一组的频数或数量，宽度则表示各组的组距，因此其高度与宽度均有意义，利于展示大量数据集的统计结果。 由于分组数据具有连续性，直方图的各矩形通常是连续排列，而柱状图则是分开排列。 ###]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React - 基础和TodoList]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FReact%20-%201%20%E5%9F%BA%E7%A1%80%E5%92%8CTodoList%2F</url>
    <content type="text"><![CDATA[React基础React环境下载安装or更新node更新node和npm至新版(要求：Node &gt;= 6 and npm &gt;= 5.2) 创建 React App123npx create-react-app my-appcd my-appnpm start 项目代码精简项目入口：index.js 内容写在：APP.js 什么是组件网页整个是一个组件，各个部分也是一个组件。 只要是页面上的一部分，就是一个组件。eg.网页上的标签 index.js 123// react：让浏览器理解&lt;App /&gt;组件的语法// react-dom：加载组件，将组件渲染到dom节点上（标签内）。将APP渲染到index.html标签里去// App.js：APP（最外层的）组件，大写字母开头都是组件 App.js 123456789101112131415import React from 'react';// 定义一个React组件：App是一个类，继承Component类class App extends React.Component &#123; // 必须需要的函数，负责组件显示的内容：return的内容为需要显示的内容。 render() &#123; return ( &lt;div&gt; hello iris &lt;/div&gt; ); &#125;&#125;// 导出出去，index.js才可以引入export default App; JSX语法允许在react中，直接使用标签&lt;&gt;结构 注释：{/ /} class样式为：className，否则会被认为是组件类的class label的for标签为：htmlFor，否则会被认为是for循环关键字 实战TodoListReact 面向数据编程，不实际操作Dom 数据构造函数中控制数据 123456789// Todolist组件的构造函数，组件创造的瞬间，自动执行。constructor(props) &#123; super(props); // 创建了state数据项：数据存放的位置 this.state = &#123; list: [], inputValue: '' &#125;&#125; 展示列表123456789&lt;ul&gt; &#123; // 循环list中的数据，每循环一次，返回一个类标签 this.state.list.map((item, index) =&gt; &#123; // 类标签需要唯一key值 return &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125;&lt;/ul&gt; 新增列表 input输入内容后：将输入框内容的值初始化为inputValue，其改变的时候自动更新inputValue中 button点击后：将inputValue加载在list中最后一位，清空inputValue。 1234567891011121314151617// 1 添加任务// 1.1输入框改变，保存输入框内容handleInputChange(e) &#123; console.log(e.target.value) this.setState(&#123; inputValue: [e.target.value] &#125;)&#125;// 1.2点击add，增加一项数据handleBtnClick() &#123; // 按下按钮，调用setState来改变数据list：...展开运算符，表示老的内容 + 增加的新的内容 this.setState(&#123; list: [...this.state.list, this.state.inputValue], inputValue: '' &#125;) alert('click');&#125; 删除列表数据项被点击后： 获取index值，作为删除函数输入 复制list于const list 删除list中index的数据项 在更新原list(不直接操作list)，setState操作 123456789101112// 2 删除任务// 选择数据项，删除数据项：通过list的index获取其下标，再删除handleItemClick(index) &#123; console.log(index) // 拷贝、删除、复制 const list = [...this.state.list] list.splice(index,1) this.setState(&#123; list: list &#125;) // this.setState(&#123;list&#125;) ES6的新写法，键值一致的写法&#125; 其他用bind方法保持this上下文写法一，直接写在HTML标签内： 1&lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;add&lt;/button&gt; 若不绑定，则handleBtnClick()函数中的this则指的是button，而不是组件props本身。 写法二，写在构造函数中：提升代码执行性能(底层内容) render()只能返回return一个包裹标签123456789render() &#123; // 返回一个大组件:1.一个div:root的div中会多一层div包裹 2.React.Fragment只有root的div return ( &lt;React.Fragment&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/React.Fragment&gt; );&#125; ✨组件通信父组件向子组件传值：父组件的属性父组件通过属性的方式向子组件传递参数 子组件通过props的形式接收父组件传递的参数 子组件向父组件传值：通过调用父组件的方法改变数据CSS行内样式 style 12/* 外层&#123;&#125;表示为JS表达式；里面的&#123;&#125;表达式为JS的对象*/style=&#123;&#123;background:'red',color:'#fff'&#125;&#125; className的方法(不能使用class关键字，react中的class关键字表示定义一个组件) 1&lt;button className='red-btn' onClick=&#123;this.handleBtnClick&#125;&gt;add&lt;/button&gt; 步骤：关键字className，定义css文件，在入口处index.js引入css文件 ### 代码优化1234567891011// setState性能优化的方式：函数的形式变为异步的setState// 将target存储在外层，再在内部适用对象const value = e.target.value;this.setState(() =&gt; (&#123; inputValue: value&#125;));// setState原本的方式：不推荐this.setState(&#123; inputValue: [e.target.value]&#125; 1234567891011// 新方法：// prevState:修改数据之前的那一次数据的状态；避免不小心改变state状态this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue], inputValue: ''&#125;));// 原方法：this.setState(&#123; list: [...this.state.list, this.state.inputValue], inputValue: ''&#125;); 关于React的思考声明式开发减少大量dom操作代码量 可以和其他框架并存react只去管理id=”root”的div的渲染。jQuery可以管理其他div操作。 组件化 区分组件和标签 xxx 组件之间通信： 父向子：属性 子向父：调用父组件的方法 单向数据流父组件可以向子组件传值（只读），子组件不能去改变这个值。 why单项数据流：防止其中一个改变时出现bug，难以定位是哪一个组件改变导致的错误。 视图层框架只解决数据和渲染的问题，不解决react复杂传值问题，可以借助其他redux等数据传递框架 函数式编程代码逻辑清晰：拆分函数，各司其职； 前端自动化测试便捷：只需要给函数一个数值，查看输出是否符合预期。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React - 3 高级内容]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FReact%20%20-%20%203%20%E9%AB%98%E7%BA%A7%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[React高级propTypes和DefaultPropspropTypes:组件要接受外部传过来的值，进行类型校验。验证传值 DefaultProps:若父组件未向子组件传值，定义属性默认值。设置默认值 https://reactjs.org/docs/typechecking-with-proptypes.html 12345678910111213import PropTypes from 'prop-types';// 组件要接受外部传过来的值，进行类型校验。验证传值TodoItem.propTypes = &#123; test: PropTypes.string.isRequired, content: PropTypes.oneOfType([PropTypes.string, PropTypes.number]), deleteItem: PropTypes.func, index: PropTypes.number&#125;// 若父组件未向子组件传值，定义属性默认值。设置默认值TodoItem.defaultProps = &#123; test: '-'&#125; props、state、render函数关系当组件的state或者props发生改变的时候，render函数就会重新执行 当父组件的render函数被运行时，他的子组件的render都被重新运行一次 虚拟DOM1234567891011121314151617181920212223242526272829303132333435363738//真实DOM - 全部替换缺陷：第一次生成DOM片段，第二次生成DOM。第二次DOM地带第一次DOM，非常耗费性能1.state 数据2.JSX 模板 3.数据+模板 结合，生成真实的DOM显示4.state 发生改变5.数据+模板 结合，生成真实的DOM，替换原始的DOM//真实DOM - DOM比对后替换缺陷：性能提升并不明显。替换内容变性能变少，比对性能增加1.state 数据2.JSX 模板 3.数据+模板 结合，生成真实的DOM显示4.state 发生改变5.数据+模板 结合，生成真实的DOM，不直接替换原始的DOM6.新的DOM和原始的DOM做比对，找差异7.找出input框发生改变8.只用新的DOM中input元素，替换DOM中的input元素//虚拟DOM - JS比对// 优点：//1.性能提升了：减少了对真实DOM的1 创建和2 对比的性能//2.跨端应用得以实现：React Native，虚拟DOM转化为原生应用的组件。1.state 数据2.JSX 模板 3.数据+模板 结合，生成虚拟DOM(虚拟DOM是一个JS对象，用它来描述真实DOM)['div',&#123;id:'123'&#125;,['span',&#123;&#125;,'hello world']]//本身+属性+内容4.用虚拟DOM的结构生成真实的DOM显示&lt;div id='123'&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;/div&gt;5.state 发生变化6.数据+模板 结合，生成新的虚拟DOM['div',&#123;id:'123'&#125;,['span',&#123;&#125;,'bye bye']]//本身+属性+内容7.比较原始虚拟DOM和新的虚拟DOM的区别8.直接操作DOM，改变span中的内容- 极大提升性能- 性能损耗极小，JS生成JS对象消耗小- JS生成DOM对象消耗极大,调用web application的API 流程：JSX —&gt; createElement—&gt;虚拟DOM(JS对象) —&gt; 真实的DOM 12return &lt;div&gt;item&lt;/div&gt;return React.createElement(&apos;div&apos;,&#123;&#125;,&apos;item&apos;) 虚拟DOM的diff算法diff算法：比对原始虚拟DOM和新的虚拟DOM的差异 虚拟DOM时候会被比对 —&gt; 什么时候数据改变 —&gt; 调用setState 1.setState设计成异步函数的原因？ 假设连续调用三次setState，且三次调用的时间间隔非常小。react把三次，合并为一次，只做一次虚拟DOM比对，更新一次DOM。节省了两次DOM比对和更新的时间，性能提升。 diff算法： 同级比对：算法简单，比对算法的速度快。同层比较，若有差异，本层及下层重新渲染， key值比对：提高了比对的性能。 需要保证：原虚拟DOM树和新虚拟DOM树上的key值一致。 因此不能使用index做key值，删除之后index会改变，key值不稳定 key值要稳定，用item做key值 React中ref的使用用处：帮助我们直接获取 DOM元素 一般情况：然而并不推荐直接操作DOM元素，因为react是操纵数据 1234567891011121314151617&#123;/*构建ref的引用；引用名为：this.input；指向input对应的dom节点*/&#125;&lt;input id="insertArea" className='input' value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; ref=&#123;(input)=&gt;&#123;this.input = input&#125;&#125;/&gt; // 1.1输入框改变，保存输入框内容 handleInputChange() &#123; // const value = e.target.value; const value = this.input.value; this.setState(() =&gt; (&#123; inputValue: value &#125;)); &#125; ref和setState使用需要注意的地方： DOM的获取并不及时，因为setState是异步的。如果希望页面更新后获取DOM，将获取DOM的语法放在setState第二个参数中，他是一个回调函数。 1234567891011// 1.2点击add，增加一项数据handleBtnClick() &#123; // setState异步，第一个参数需要执行的函数，第二个参数回调函数 // prevState:修改数据之前的那一次数据的状态；避免不小心改变state状态 this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue], inputValue: '' &#125;),()=&gt;&#123; console.log(this.ul.querySelectorAll('div').length); &#125;);&#125; React生命周期函数生命周期函数：在某一时刻，组件会自动调用的函数 render：setState 初始化initialization挂载mounting更新updation去除unmounting123456789101112131415161718192021//2组件即将被挂载到页面的时刻执行componentWillMount()&#123; console.log('2 组件即将被挂载到页面：componentWillMount')&#125;//2组件即将被挂载到页面的时刻执行componentDidMount()&#123; console.log('2 组件被挂载到页面之后：componentDidMount')&#125;//3组件需要更新吗？true or falseshouldComponentUpdate()&#123; console.log('3 组件是否更新？：shouldComponentUpdate') return true;&#125;//3组件即将更新componentWillUpdate()&#123; console.log('3 组件更新之前：componentWillUpdate')&#125;//3组件更新完成componentDidUpdate()&#123; console.log('3 组组件更新完成：componentDidUpdate')&#125; 1234567891011// 3（1）当组件从父组件接收参数；（2）父组件的render执行了，该生命周期函数会执行// 如果这个组件第一次存在于父组件中，不会执行// 如果这个组件已经存在与父组件中，会执行componentWillReceiveProps() &#123; console.log('3 ! 组件即将获取父组件：componentWillReceiveProps')&#125;//4 子组件即将被去除componentWillUnmount()&#123; console.log('4 组件即将被去除：child componentWillUnmout')&#125; React生命周期函数使用场景性能优化：借助shouldComponentUpdate 原因：提高react组件性能，避免无谓的组件render渲染 12345678910// 避免一个组件做无谓的render操作// 利用shouldComponentUpdate提升性能：若更新后的content和更新前的content一致，则不刷新渲染shouldComponentUpdate(nextProps,nextState)&#123; //nextProps指更新后Props会变成什么样，nextState指的是State会变化成什么样 if(nextProps.content !== this.props.content)&#123; return true; &#125;else&#123; return false; &#125;&#125; 发送ajax请求：默认放在componentDidMount 原因：ajax只需要请求1次，需要在渲染前获取数据 场景：使用ajax异步请求的方式，从我的一个接口上，请求一个远程的todolist数据，将远程数据加载到本地，渲染到页面上。 12345// npm、或者初始化脚本方法安装yarn npm install -g yarn curl -o- -L https://yarnpkg.com/install.sh | bash // yarn安装axiosyarn add axios 1234// 约定：ajax放在componentDidMount中// ajax只需要请求1次componentDidMount()&#123;&#125; 使用Charles实现本地数据mockCharles：中间代理服务器，可以抓取浏览器的请求，可以使用map local模拟本地前端接口。 模拟一个接口，ajax请求获取接口中真正的结果，改变页面的内容。 1234567891011componentDidMount()&#123; // axios.get('/api/todolist') axios.get('http://localhost.charlesproxy...:3000') .then((res)=&gt;&#123; this.setSate(()=&gt;(&#123; list: [...res.data] &#125;) ); &#125;) .catch(()=&gt;&#123;alert('错误')&#125;)&#125; CSS3的过渡动画和动画监听state里show的值，根据值在div元素中动态添加css样式className 1&lt;div className=&#123;this.state.show?'show':'hide'&#125;&gt;hello&lt;/div&gt; 1234567891011121314151617181920212223/*过渡动画*/.show&#123; opacity: 1; transition: all 1s ease-in;&#125;/*动画*/.hide&#123; animation: hide-item 2s ease-in forwards;&#125;@keyframes hide-item&#123; 0%&#123; opacity: 1; color: red; &#125; 50%&#123; opacity: 0.5; color: green; &#125; 100%&#123; opacity: 0; color: blue; &#125;&#125; react-transition-group实现动画文档：https://reactcommunity.org/react-transition-group/css-transition 安装：yarn add react-transition-group 1234//不需要样式的添加和删除&lt;CSSTransition&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/CSSTransition&gt; 性能优化 作用域修改放在constructor构造函数内，保证作用域绑定操作只执行一次 + 避免子组件的无谓渲染。 this.handleClick = this.handleClick.bind(this); react底层setState性能提升机制，使用异步函数：多次数据改变结合成一次来做，降低虚拟DOM频率 react底层虚拟DOM，同层比对+使用key值比对，提升虚拟DOM比对速度 借助shouldComponentUpdate，提高react组件性能，避免无谓的组件render渲染]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - APP合集]]></title>
    <url>%2F2019%2F03%2F09%2FAPP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[合集简介编码工具： Xcode 10.1，Swift 4.2，UIKit 设计工具：Adobe Inllustrator， 设计icon ， 生成icon 第三工具：移动端火热数据库 Realm，天气API等 思路来源：平时喜欢在APP store里面下载一些独立开发者的APP。这些APP部分思路来自于优秀的APP（如羡辙-2019字体日历、素记 等），部分是自己生活需要的简单小功能。 代码方面：大部分使用了Storyboard，UI设计需要；纯手写代码在 每日一个swift小程序内 开源项目：暂未整理完成 上架中： Project : Todos 极简事项 需求分析：iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 技术： 数据存储：先学习了userDefault，再改为时下火热的移动端数据库Realm存储数据 TableView 具体实现 Project : Weather 元气天气 需求分析：让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 技术： 页面传值 第三方库管理器 具体实现 Project 3 : Quizzler 奇怪问答 需求分析：该问答APP可以修改为任意主题的答题APP。目前想法是改为数据结构基础知识的APP，因为我自己可以用该APP为了实习面试而刷题。 技术： SVM模式 题库存储：realm移动端数据库 具体实现 Project 4 : Piano 木琴 按下不同的按键，发出不同的音调。 Project 3 : Dicee 麻将骰子模拟器 技术： 具体实现 Project 2 : Magic 8 Ball 问答魔力球 Project 1 : 计时器 技术： SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 具体实现]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 5 任务清单APP]]></title>
    <url>%2F2019%2F03%2F08%2FiOS%E5%9F%BA%E7%A1%80%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%2F</url>
    <content type="text"><![CDATA[项目介绍需求分析TableViewController 增加任务 删除任务 修改任务 需求遇到的困难知识点 项目布局UI设计页面一页面二源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F03%2F07%2F%F0%9F%91%80IOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%204%20%E5%85%83%E6%B0%94%E5%A4%A9%E6%B0%94APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 本程序共分为三个页面：欢迎页面，天气预览界面，城市天气查询界面。 需求天气预览界面：定位天气展示【1 获取当前经纬度位置 2 根据位置获取天气、城市信息 3将信息展示在视图】 城市天气查询界面：用户查询天气【1展示当前城市 2输入框输入查询城市的名称 3按下查询按钮-获取名称至页面1，销毁页面2 】 采用了MVC模式model部分负责数据，我们构建天气类，属性包括：温度、城市、condition，以及计算属性——icon、words，他们需要根据condition属性来确定。比如晴天对于icon为小太阳、文字对于“天晴是你的心情”。 controller负责两个页面中的业务逻辑：从model中取数据，然后返回给view。 最终在view上展示所需天气及其文字信息。 遇到的困难页面跳转传值页面跳转传值部分。【功能：按页面1右上角按钮，跳转到页面二，页面二展示当前city；用户输入目标city，按查询后跳转回页面一，展示查询city的天气信息】 segue导航正向传值较容易，3步骤。1在prepare函数部分获取segue的identifier【转换箭头】，2使用as!强制转化，实例化该segue的destination页面vc，3使用实例化的vc进行传值。这样就可以在下一个页面使用本页面中的“所在城市”的信息了。 而反向传值就不同。如果采用control+drag方式，从页面二的button到页面一加上转换箭头，这样只会再重新生成新的页面一，定位到本地天气；而不是预想的回到原先页面，重新展示所搜索城市的信息。 所以需要自定义protocol，使用delegate实现导航的反向传值。 在页面二需要：3个步骤来自定义协议portocol，实现【按下查找城市按钮，获取输入的city值】的功能。 1自定义协议，安排协议中的方法（获取输入的city，传给页面一），2 声明协议属于页面二中的delegate变量 3规定在哪里触发协议中的事件。 在页面一种需要：3个步骤来实现协议，实现【获取页面二中city的值，并展示于本页面】的功能。 1遵守协议 2 实现协议中的方法（获取city值，根据值获取温度对象的所有信息，展示与本页面）3 第二个页面vc的事件函数委托delegate给self实现。 获取当前位置的天气1 委托本页面，实现定位协议中的请求位置的方法，获得经纬度。（难点） 2 根据经纬度信息，使用Alamofire请求API来获取天气数据； 3 利用SwiftJSON解析生成数据； 4 给weather对象赋值； 5 再使用weather对象中的天气、文字信息更新页面。 ✨使用了定位协议CLLocationManagerDelegate的方法。 1 遵守定位协议 2 实例化定位管理器CLLocationManager 3 实现协议中的方法（获取当前的经纬度）4locationManager委托本页面 当manager请求位置的时候，则系统自动调用manager方法，在该方法里获得经纬度。 知识点protocol-delegate：类似java中的接口与实现协议——工具间，协议中的方法——工具，实例化的对象——老板，本页面self——打工仔，委托——老板让打工仔干活 计算属性model中的计算属性——compute属性 某个属性需要根据另一个属性来确定，我们定义其为计算属性 如根据天气情况属性——晴天，得到对应的icon和words：icon为小太阳、wors为“天晴是你的心情”。 第三方库的CocoaPods安装的使用Alamofire：完成http请求天气数据 SwiftJSON：解析、生成数据 extension代码优化目的：提高代码可读性。为日后重构代码打下了良好的基础。 场景：1 私有的辅助函数 ；2 遵守协议（实现某个协议的方法放到一个 extension 中）；3 模型（Model用结构体， 使用extension 将 Model 的 属性 和 基于属性的计算计算属性分离 ） 项目布局UI设计 页面一创建项目的时候需要取消左右旋转 背景图约束： 上下左右相对于View都是0 背景图片填充方式为Aspect Fill拉伸 中间图片 Label 左边自适应 页面二StackView自适应页面的宽度： 选中StackView后control+drag至背景图 是的stackView：页面的比例为2：5 错误：该页面无法到达，需要添加跳转 需要按下按钮，跳转至新的页面：选中按钮，control+drag 至第二页面，选择show（直接跳转）/Present modally（从下往上弹出），生成连接。 启动页面同理自行设计 依赖管理工具CocoaPods介绍 什么是CocoaPods CocoaPods是OS X和iOS下的一个第三类库管理工具，通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 需要第三方库的时候，三个步骤： 0、安装cocoapos 1、command+N导入项目 2、自动创建podfile文件，在该文件写入pod ‘工具包名称’，点击instal下载 3、项目安装配置第三方库完成，点击r.xcworkspace文件进入项目 在CocoaPods中安装第三方库SVProgressHUD 导入 写需要的第三方库，安装 安装配置完成。安装配置过功能包之后，打开项目都是使用Weather.xcworkspace文件 获取经纬度请求用户给予权限的窗口未弹出，报如下错误 原因是：弹框弹出时，需要给到一个描述给用户，说明为什么需要该信息，在info.plist中设置 问题解决： https://swift.gg/2017/02/13/requesting-permissions-core-location-tutorial/ API 使用网络请求功能包Alamofire完成http请求获取天气数据https://study.163.com/course/courseLearn.htm?courseId=1208935831&amp;share=1&amp;shareId=1386037112#/learn/video?lessonId=1278405463&amp;courseId=1208935831 API:应用程序接口(API:Application Program Interface) https://openweathermap.org/api 选择合适的API 根据经纬度获取天气需要的信息 HTTP+字典Dictionary+JSON+第三方功能包SwiftyJSON字典类型：键值对构成 let dict:[String:Any] = [“name”:”zhangsan”,”age”:18] 创建Weather模型+把获取到的数据显示到页面+计算属性初探https://openweathermap.org/weather-conditions 代码优化-把功能块分离出来变成函数+extensionview连接controller+segue导航正向传值+三种as+delegate实现导航的反向传值view连接controller 选择cocoaTouch class，创建controller，选择页面二，建立连接。 segue导航正向传值1、选中转换箭头，设置该转换的id 2、通过在segue的函数中的segue.identifier找到究竟是哪一个【转换箭头】 3、根据转换箭头，使用 sugue.destination 找到箭头的目的地页面 4、使用as!强制转换获取页面vc（实例化的对象） 5、利用vc页面，传值 自定义protocol和delegate实现导航的反向传值页面二：selectCityController 自定义协议，安排了协议的方法 工具属于谁的——页面二中的delegate变量的 规定在哪里触发时间——按下查找城市按钮 页面一：viewController 遵守协议——领取工具 实现协议中规定的方法——去干活。原因：想要用协议的方法，获取里面的参数 委托——指导谁（vc）委托给本页面（self）的 转型——三种as as 向上转型：安全，一般直接使用Int(3.2)，所以不常用 3.2 as Int as? 向下转型：需要判断 if let，若转换不了，得到nil 1if let vc = segue.destination as? SelectCityController as! 向下转型 1let vc = segue.destination as! SelectCityController 完成用户查询天气的功能光标的出现和收起 1234567891011121314 override func viewDidLoad() &#123; super.viewDidLoad() currentCityLabel.text = currentCity //打开本页面，输入框成为第一个响应者，光标显示在输入框 inputCity.becomeFirstResponder() &#125;///该段代码放在退出页面处即可 // 让用户界面在主线程上进行——优先执行 // 经常用于使UI方面的操作提前执行，查询可以慢慢查，我们的键盘先收起来——用户体验更好 DispatchQueue.main.async &#123; // 3.收起键盘 让searchBar失去焦点(光标消失+软件盘收起) self.inputCity.resignFirstResponder() &#125; 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 3 一站到底APP]]></title>
    <url>%2F2019%2F03%2F06%2FiOS%E5%9F%BA%E7%A1%80%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%203%20%E4%B8%80%E7%AB%99%E5%88%B0%E5%BA%95%20%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析与项目布局需求分析1用户答题——2比对答案——3刷新页面进入下一题 面试介绍首先我来介绍第一个项目——一站到底答题类APP。 其主要业务需求是【1用户答题——2比对答案——3刷新页面进入下一题】 我是使用的是MVC模式开发，保证了项目功能之间的低耦合。 首先我们的数据就是题库，题目类属性为题干和答案。 用户在View上看到题干，选择心中的答案，Controller将获取当前问题答案的请求发送给model，model将答案返回，在Controller与其正确答案比对，正确后计得分并显示在View上，Controller再获取下一个题目的题干和答案，刷新View的题干label和进度条进行下一个题目答题。 在所有题目加载完成后，弹出框显示分数，用户可重新开始游戏。 面向对象编程 OOP类：抽象 对象：具体 初始化方法、构造方法：实例化之后创建一个对象 eg. 类：人——属性：名字、性别 对象：Iris这个人——属性：iris、女 MVC模式控制器从model取得数据，然后返回给view——MVC Model 模型：负责数据找后台数据 View 视图：用户界面Controler控制器：业务逻辑负责传递视图需要表达的信息， 拿到数据后，传到视图 需求：打开微博个人页面，想要查看多少人关注自己 首先传到控制器，发现需要准备数据——关注人数 找到模型要数据 模型准备好数据之后，将数据给Controler，Controler拿到后传给View， 分工明确，高聚合，低耦合 功能实现弹出框 谷歌关键词： alert Apple documentation 方法：UIAlertController 使用第三方库在swift项目中调用objective-C语言的包 下载源码：https://github.com/relatedcode/ProgressHUD 拖入项目中的supporting files的组中 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 2 木琴APP]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E5%9F%BA%E7%A1%80%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%202%20%E6%9C%A8%E7%90%B4APP%2F</url>
    <content type="text"><![CDATA[项目介绍按下不同的按键，发出不同的音调。 Tag // 3.1 通过tag获取被按下的buttonlet indexTag = sender.tag 多媒体播放器// 1.引入多媒体播放器import AVFoundation // 2.声明播放器，用于播放url的多媒体文件var player:AVAudioPlayer! // 3.4 将“音频”放入“播放器”player = try AVAudioPlayer(contentsOf: url!) // 3.5 播放音频player.play() url // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: “note(indexTag)”, withExtension: “wav”) 编组：可以帮助项目整理同类型，且不同使用文件，获取文件更方便 抛异常 // 抛异常: 播放器可能为空 do{}catch{print(error)} 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import UIKit// 1.引入多媒体播放器import AVFoundationclass ViewController: UIViewController&#123; // 2.声明播放器，用于播放url的多媒体文件 var player:AVAudioPlayer! // 音频资源 let sounds = ["note1","note2","note3","note4","note5","note6","note7"] override func viewDidLoad() &#123; super.viewDidLoad() &#125; // 3.根据按下的button，播放不同的声音 // 用户按下这个控件sender，按钮 @IBAction func notePressed(_ sender: UIButton) &#123; // 3.1 通过tag获取被按下的button 1-5,下标需要为0-4 let indexTag:Int = sender.tag - 1 // 3.2 播放音频 play(tag:indexTag) &#125; /* 创建一个发出声音的功能函数 输入为第几个声音Int */ func play(tag:Int)&#123; // 1 根据tag不同，获得不同“音频” // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: sounds[tag], withExtension: "wav") // 抛异常: 播放器可能为空 do&#123; // 2 将“音频”放入“播放器” player = try AVAudioPlayer(contentsOf: url!) // 3 播放音频 player.play() &#125;catch&#123; print(error) &#125; &#125;&#125;]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 1 摇色子APP]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E5%9F%BA%E7%A1%80%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%201%20%E6%91%87%E8%89%B2%E5%AD%90APP%2F</url>
    <content type="text"><![CDATA[项目介绍点击按钮或者摇晃手机，两个骰子摇晃改变。 UI设计 IBOutlet和IBActionOutlet 插座 ：定义控件 Action 动作 ：控件动作 步骤control 拖拽定义控件IBOutlet和动作IBAction TIPS改名方式需要先断开连接，再修改变量名，再建立连接 否则运行时会抛异常：空指针问题 命名方法文件名 大驼峰 变量名 小驼峰 快捷键command+R:运行 随机数和数组实现图片使用数组存储String类型的图片文件名 随机数获取0-5的数字作为数组下标 将功能放进func函数中，代码更改性更强 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// ViewController.swift// Dicee//// Created by iris on 2019/3/5.// Copyright © 2019 IrisWang. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; // 一、随机数 var index1:Int = 0 var index2:Int = 0 // 二、数组 let diceArray = ["dice1","dice2","dice3","dice4","dice5","dice6"] @IBOutlet weak var diceeImageView1: UIImageView! @IBOutlet weak var diceeImageView2: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 初始的数字也是随机的 updateDiceImage() &#125; @IBAction func rollButton(_ sender: Any) &#123; // 更新骰子 updateDiceImage() &#125; // 三、函数:将功能放进函数中 // 更新骰子函数 func updateDiceImage()&#123; // 1.获取随机数 // 闭区间 0...5 取0-5这几个数 index1 = Int.random(in: 0...5) index2 = Int.random(in: 0...5) // 2.获取数组的某一个 // diceArray[index1] // 3.摇骰子功能 command+R:运行 diceeImageView1.image = UIImage(named: diceArray[index1]) diceeImageView2.image = UIImage(named: diceArray[index2]) &#125;&#125; 摇一摇功能谷歌关键词：shake apple documentation 给出结果：motionEnded 123456// 四、摇一摇功能// 手势结束之后，要进行的行为 motionEndedoverride func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; // 更新骰子 updateDiceImage()&#125; 练习——占卜球]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 7 定制Table Views]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%207%20%E5%AE%9A%E5%88%B6Table%20Views%2F</url>
    <content type="text"><![CDATA[项目简介开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。 12345import UIKitimport Foundationclass RestaurantTableViewController: UITableViewController&#123;//code&#125; 将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码： cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择打钩，且Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。 12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 位置和类型label设置 添加“Type”和“Location”。添加如下两个数组变量： 1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可： 12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 结果： 练习 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 ###]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%206%20%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84Table%20Based%20App%2F</url>
    <content type="text"><![CDATA[项目简介 table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。 出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击到UITableViewDataSource中查看： 1234567891011121314151617public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell's reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different //...&#125; UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有.有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 3 傻瓜式制作APP图标]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%203%20%E5%82%BB%E7%93%9C%E5%BC%8F%E5%88%B6%E4%BD%9CAPP%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用真机测试的效果如下： 设计网址：https://www.canva.cn/ step1 自定义尺寸：1024 x 1024 step2 设计：拖入背景和元素 step3 下载得到png格式的图标 生成图标网址：https://appicon.co/ 将图片拖入网站，选择需要的格式，下载得到zip 解压后得到 图标拖入工程项目中需要各种大小的icon 进入Assets.xcassets的文件夹，删除AppIcon.appiconset文件夹 再将上步解压后的文件夹拖入 消除警告，直接键盘delete删除多余图片即可]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 5 Stack View设计UI]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%205%20Stack%20View%E8%AE%BE%E8%AE%A1UI%2F</url>
    <content type="text"><![CDATA[项目介绍 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 步骤Assets.xcassetsXcode中添加图片 Lable布局用Stack View布局title的label 先拖入两个label。其一修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色；其二修改label的title为“Get help from experts in 15 minutes” 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出两个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label。 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution image布局 拖动三个image view对象。并修改其image属性为user1，user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 组合stack view后添加布局约束 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 选中大的stack view，添加space constraints，上，左右，分别为70，0，0 添加约束后，如果出现布局问题，可通过issue indicator解决：点击问题 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 每日一个Swift小程序]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%E5%9F%BA%E7%A1%80%2FIOS%E5%BC%80%E5%8F%91%20-%20%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AASwift%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[swift学习日记——每日一个小程序 名称：30DaysofSwift 工具： Xcode 10.1, Swift 4.2, UIKit 思路来源：samvlu ，Allen_朝辉，nimomeng 用例方面：主要参考nimomeng的case，也参考了Sam Lu的40个小项目，也参考了Allen_朝辉的项目 代码方面：前两个项目学习了Storyboard，然而实际上多人协作的项目中我们尽可能少用Storyboard，因为很容易出现冲突问题。况且从学习的角度，storyboard很难说清楚操作步骤是什么。因此以后的项目都尽量手写。 开源项目：暂未整理完成 Project 3 : 计时器 Change Custom Font 学习内容： 具体实现 SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 Project 2 : 改变字体 Change Custom Font 学习内容： 获取字体属性：UIFont.familyNames可以存储为数组，可以直接输出、或通过索引获取 随机获取字体：随机数arc4random()格式为UInt32，需转为Int，再对数组长度取余。获得范围随机数 字体设置：words.font=UIFont(name: “字体名称”, size: 20) 按钮边框设置：圆角cornerRadius，颜色borderColor，该颜色需要CGColor，因此需要将UIColor转为CGColor 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041//// ViewController.swift// ChangeCustomFont//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var words: UILabel! @IBOutlet weak var change: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 按钮的边框粗细、圆角、颜色 // 注：颜色需要CGColor，因此需要将UIColor转为CGColor change.layer.borderWidth = 1; change.layer.cornerRadius = 8; change.layer.borderColor = UIColor.blue.cgColor &#125; // 字体改变：根据随机数，随机获取系统字体的第i个 @IBAction func change(_ sender: Any) &#123; // 1.存储字体名称y为数组 let familyNames_arr = UIFont.familyNames let count:Int = familyNames_arr.count // 2.获取随机数 // 平常的随机数：0 ~ X,UInt32格式，需要转为Int let random1:Int = Int(arc4random()) // 限制长度的随机数，取余 ：0 ~ X let random2:Int = random1 % count // 3.设置字体为第 随机数 的字体 print(familyNames_arr[random2]) words.font=UIFont(name: familyNames_arr[random2], size: 20) &#125;&#125; Project 1 : 加法计算器 Calculation of Add 学习内容： 具体实现 IOS的UI布局：使用Storyboard和其辅助视图添加部件，且为部件定义，加上动作 值的转化：Option获取 -&gt; String -&gt; Float计算 -&gt; String展示]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 4 AutoLayout]]></title>
    <url>%2F2019%2F03%2F03%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%204%20AutoLayout%2F</url>
    <content type="text"><![CDATA[项目介绍Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag 使用Auto Layout使label到中央Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Control-drag使得label到右下角用control+drag方法来添加spacing constraint。 按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。 所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束 使用Auto Layou\Control-drag使得label水平居中，距离上边40]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础 - 2 数据库]]></title>
    <url>%2F2019%2F03%2F03%2F%E2%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%20-%202%20%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[题目合集数据库一、事务事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。 一个事务是可以被看作一个单元的一系列SQL语句的集合。 事务的特性（ACID） A, atomacity 原子性：事务必须是最小单位；对于数据修改，要么全都执行，要么全都不执行。(转账失败) C, consistency 一致性：事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。 I, isolation 隔离性 ：一个事务的影响在该事务提交前对其他事务都不可见。 D, durability 持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命故障也一直保持。 二、索引create index 索引名 on 数据库名（列名 DESC降序） 优点：加速查找 缺点：增删改的时候需要更新索引 三、数据库引擎InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。 MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。 注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。 实现B+树]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习整理 - 未完待续]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%AD%98%E6%A1%A3%2F%E5%AE%9E%E4%B9%A0%E6%95%B4%E7%90%86%20-%20%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[实习的资料整理。 包括银行、互联网公司。 包括各公司的福利整合。 农业银行截止日期：3.20日申请入口 宣传网页： https://i.eqxiu.com/s/iqd0XQ71?eqrcode=1&amp;share_level=5&amp;from_user=b819b53f-2d44-49e8-aa62-fa07f712a8ef&amp;from_id=c8995d88-6327-45bc-97dc-a4ad26ef27cb&amp;share_time=1551152498524&amp;from=timeline&amp;isappinstalled=0 福利工资17k。公积金5200。 农行总部编制 档案北京管理 北上广天成西 六地即可 扩招截止20年 这两年把握机会 进入顶级国企 全国统一待遇 当地公积金封顶 上海数据中心 部门 免费房子（一辈子） 招商银行时间：3.4-4.7内推网页： https://cmbjob.ccc.cmbchina.com/positionlistshare.html?v=3.0&amp;refereeId=847a71a8-f981-4d7a-abd3-d846ddef0634&amp;refereeCode=674440&amp;recruitType=3&amp;positionClass=&amp;deptId=003 福利180w行员贷款福利 招行有免费房子住的（只有一年） 花旗银行 发简历给HR 微信https://mp.weixin.qq.com/s/Yyxep9M6z525g-c6czt78Q 发简历给HR 快手实习招聘 腾讯时间：提前批3月9日，普招3.31 字节跳动时间：未知。一直在发布岗位，投递后5个工作日内安排面试内推码：6PFRDJMhttps://job.toutiao.com/2018/intern_referral/?token=5lT3rIxuAZuD18qmg3DYlg%3D%3D&amp;key=MjU4NDcsMzE5MTEsMzE5MTQsMzE5MTUsMzE5MTgsMzE5MjMsMzE5MzE%3D&amp;from=groupmessage&amp;isappinstalled=0 深信服时间：未知 华为 其他Google Girl Hackathon报名截止时间：2019年3月6日23:59分 报名： https://mp.weixin.qq.com/s/7H9NBuRYAqNnRciF3m3Cng]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合集 - 优秀iOS开发者博客]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%AD%98%E6%A1%A3%2F%E5%90%88%E9%9B%86%20-%20%E4%BC%98%E7%A7%80iOS%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[onevcat的博客 https://onevcat.com/#blog 唐巧的博客 http://blog.devtang.com/ ibireme的博客 https://blog.ibireme.com/ Kitten的时间胶囊 http://kittenyang.com/ 杨萧玉的博客 http://yulingtianxia.com/ Biso的技术博客 http://allluckly.cn/ 黄玄的博客 http://huangxuan.me Samir Chen的博客 http://www.samirchen.com/ Limboy‘sHQ http://limboy.me/category/tech.html 叶孤城的iOS杂货铺 https://zhuanlan.zhihu.com/zangqilong J_Knight https://knightsj.github.io/archives/ 雷纯峰的技术博客 http://blog.leichunfeng.com/blog/archives/ Halfrost-Field https://halfrost.com/ bang’s blog http://blog.cnbang.net/archives/ MrPeak杂货铺 http://mrpeak.cn/ Casa Taloyum https://casatwy.com/ Bestswifter https://juejin.im/user/57638ad8207703006b06e3ef/posts joy_xx的博客 https://juejin.im/user/5656f11760b28da566412f03/posts 大左的博客 https://draveness.me/index 没故事的卓同学 https://www.jianshu.com/u/88a056103c02 Andy矢倉 http://www.rockerhx.com/archives/ 老谭笔记 http://www.tanhao.me/archives/ 一叶博客 https://00red.com/archives/ 涂鸦的博客 http://www.beyondabel.com/blog/archives/ LeeWong的博客 http://www.leewong.cn/ 作者：海强_hq 链接：https://www.jianshu.com/p/89de5a2d3e63]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>合集</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础 - 1 计算机网络]]></title>
    <url>%2F2019%2F03%2F03%2F%E2%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%20-%201%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[题目合集一、TCP和UDP的区别1.为什么握手需要三次，而挥手却需要四次？握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步： （1）回应A； （2）发送自己的最后一个数据 2.为什么A进入TIME_WAIT需要等待最大报文段生存的时间后，才能关闭？原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内，A是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。 二、HTTP是什么？ 定义：HTTP就是一个在TCP基础上实现的，客户机与服务器之间的，请求-响应模式的双向通信协议。 目的：超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80。 HTTP 请求的构建 第一部分——请求行：方法：如下。URL ：www.baidu.com、版本：HTTP 1.1 HTTP方法有哪些？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 第二部分——首部字段：Accept-Charset，表示客户端可以接受的字符集。 Content-Type是指正文的格式：POST 的请求，如果正文是 JSON。 缓存： 第三部分——请求的正文实体HTTP 返回的构建 一、状态行： 状态码会反应 HTTP 请求的结果；短语会大概说一下原因。 HTTP 状态消息 1xx: 信息。100收到部分请求。 2xx：成果。200 请求成功（其后是对get、post请求的应答文档） 3xx：重定向。301永久重定向，302 转移至临时url（临时重定向） 4xx：客户端错误。403禁止访问，404无法找到被请求页面 5xx：服务器错误 二、首部：key value。Retry-After表示，告诉客户端应该在多长时间以后再次尝试。Content-Type，表示返回的是 HTML，还是 JSON。 持久连接：http1.1支持HTTP协议采用“请求-应答”模式，当时用普通模式，即非持久连接的模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（无连接的协议） 当使用Keep-Alive模式（持久连接）时，Keep-Alive功能使客户端到服务端的连接持久有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。 http管线化通俗的讲，不用管线化的持久连接就是来一个请求就响应一个； 而管线化则是，把请求打包发过去，一起响应。 三、HTTPS是什么？SSL过程。HTTPS并不是一个新协议，HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路，TLS）+认证+完整性保护 原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。 HTTPS 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下： 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验； 二、客户端如果校验通过后，生成随机数，随机数使用公钥进行加密（RSA加密）； 三、消息体的摘要进行MD5算法加密，此时就得到了RSA签名； 四、消息发送给服务端，只有服务端（RSA私钥）能解密。 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。 四、GET和POST的区别本质：get和post就是TCP连接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 1使用：get参数通过url传递，post参数放在request body中 2限制： get参数是有长度限制的，而post没有 get请求支持支持ASCII字符，而post支持标准字符集，可以传递中文字符 3安全性： get参数直接暴露在url中，较为不安全，不能传递敏感信息 get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留 4数据包：✨get产生一个TCP数据包，post产生两个TCP数据包： GET ：浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； POST：浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 （据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。） 总结：对于get和post的区别，get传递数据如同是写在脸上，post传递数据如同放在肚子里，脸上不能放太多东西，也不能放隐私东西，肚子里就无所谓啦~ 五、浏览器进行一次网络请求都需要哪些步骤？建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接 1、域名解析： 包含com的时候浏览器认为其不是关键字而是URL，未指明协议的时候开头加上HTTP 浏览器查找是否存有域名的 IP 地址，没找到后发送给 DNS 服务器（本地host，电信），让它解析为 IP 地址 2、TCP的三次握手：建立连接 3、web浏览器向 web 服务器发送一个 HTTP 请求 HTTP请求格式：GET(请求) /sample/hello.jsp(URI) HTTP/1.1(版本) 过程：请求行+请求头，最后发送一行空白行通知服务器结束信息发送 4、Web服务器应答 到达负载均衡器的IP地址之后，如果是GTTPS，则返回307告诉需要重定向，然后会发送TLS握手 HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码 过程：应答行+应答头+发送数据 4、浏览器解析html代码，并请求html代码中的资源 服务器的永久重定向响应：“https://www.google.com/” 而非“http://google.com/”。 解析 —— HTML，CSS，JS 渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制 基础知识 讲述一下计算机网络的七层 应用层：发起请求的逻辑 表示层 会话层 TLS 传输层——TCP 网络层——数据路由包IP——路由器 数据链路层——帧，数据包的容器——交换机 物理层——比特流——网卡、集线器 网际层协议：IP协议、ICMP协议、ARP协议、RARP协议传输层协议：TCP协议、UDP协议应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS 如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。 UDP用户数据报协议： 面向无连接包：源端口号和目标端口号+数据 UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性： UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次 UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。 UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。 UDP 支持多播和广播。 适合情况： 流媒体的协议：直播 实时游戏 移动通信领域 TCP传输控制协议： 面向连接 分析： 源端口号和目标端口号：数据知道发给哪个应用。 包的序号：那个包先来，那个后来 确认序号：发出去的包应该有确认，无确认再发一次。 状态位：SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。是面向连接的，因而双方要维护连接的状态，这些带状态位的包的的发送，会引起双方的状态变更。 窗口大小：标识自己当前能够的处理能力，让对方根据自己窗口来确定发送速度。 拥塞控制：控制自己发送的快慢。 TCP 的三次握手 TCP 提供一种面向连接的、可靠的字节流服务。 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 作用：三次握手除了双方建立连接外，还获取TCP包的序号。 “请求 -&gt; 应答 -&gt; 应答之应答”A：您好，我是 A。 B：您好 A，我是 B。 A：您好 B。 状态时序图： 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 以上就是TCP建立连接的三次握手过程，以上流程还需要补充的是： 对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称（同步seq号）Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四次挥手A：B 啊，我不想玩了。 B：哦，你不想玩了啊，我知道了。（半关闭） B：A 啊，好吧，我也不玩了，拜拜。 A：好的，拜拜。 客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。过程： 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器收到 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到服务器端的关闭请求，发送确认包，进入 TIME_WAIT状态，等待可能需要重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 四次挥手的原因： TCP连接是全双工的，即一端接收到FIN报时，对端虽然不再能发送数据，但是可以接收数据，所以需要两边都关闭连接才算完全关闭了这条TCP连接。 DDOS攻击典型的场景是DDOS攻击，也可以说是tcp的SYN Flood攻击，又叫洪水攻击； 根据上面的分析，我们知道tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1到63s这样(如果有特殊的设置，这个时间可以到1-2min这样)，默认最长是63s之后才会断开，之前这段时间内属于半连接的状态，服务器不会丢弃掉这些连接，而是会等，试想如果有一个人突然想你的server瞬间之内发送了几千万个连接请求，但是对服务端的响应不做理睬，这样很容易就导致我们正常的tcp连接进不去，从而出现服务拒绝的情况，而他只需要一个简简单单的脚本去给你丢包就可以了，这种情况就会导致服务器对正常的客户端表现为宕机。。此种攻击的成本比较低，但是防护却特别麻烦，因为你必须要保证正常的不能因为访问次数的提高而出现拒绝。 http协议]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础 - 0 操作系统]]></title>
    <url>%2F2019%2F03%2F03%2F%E2%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%20-%200%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目合集进程管理一、进程和线程的区别 按照操作系统的概念： 进程为一个独立执行单元（是系统进行资源调度和分配的基本单位），在PC或者移动端是程序和应用的执行。 线程为CPU调度的最小单元，是有限资源。一个进程可以包含多个线程。 异： 组成：唯一标示为进程控制块PCB + 资源、线程控制块TCB(栈) 资源：进程间的资源是分隔独立的，内存映射表不同，占用物理内存地址是分隔的；线程的资源是共享所在进程的。 切换：线程切换了TCB（栈结构），进程还包括切换资源，即切换内存映射表 同： 运行状态：就绪、运行、阻塞。运行时受阻如需要资源之后会变为阻塞，获取资源后变为就绪，再次运行。 iOS中的进程和线程 进程：一个iOS程序运行后，该运行的程序就是进程。默认会开启1条线程，称为“主线程” 线程：从用途上来说，线程分为主线程和子线程，主线程的作用是「显示刷新页面；处理UI事件」，而子线程的作用则是「执行耗时任务，比如网络请求、I/O 操作等」。如果在主线程中执行耗时操作那么就会导致程序无法及时地响应。因此耗时操作必须放在子线程中执行。 多线程的实现：pthread，NSthread，GCD，NSOperation。 二、进程通信（一）广义的进程间通信本地进程间通信的方式有很多，可以总结为下面四类： 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC） （二）狭义的进程间通信1、共享存储器系统 A、共享数据结构：信息交换的格式、类型一定；进程通信由程序员完成，效率低； B、共享存储区：进程可随时向系统申请一块存储区，并指定该分区的关键字，用于进程通信。 2、消息传递系统 A、直接通信方式 Send(Receiver,message);Receive(Sender,message); B、间接通信方式：1、信箱的创建、撤消； 2、消息的发送和接受；Send(mailbox,message); 3、管道通信管道：用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为Pipe文件。 功能：Command1进程以字符流的形式向管道发送大量的数据，Command2进程则从管道接收数据。两进程实现单向、同步、互斥运行。单向：Command1只能发送；同步：管道满时，Command1等待；互斥：同一时刻，只能有一个进程对管道操作； 4、消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 5、套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同的主机间的进程通信。通过”套接字”向网络发出请求或者应答网络请求。 三、死锁在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。 ✨产生条件：互斥、占有等待、非剥夺和循环等待。 互斥条件 ：一个资源一次只能被一个进程使用 请求保持条件 ：一个进程因请求资源而阻塞时，对已经获得资源保持不放 不可抢占条件 ：进程已获得的资源在未使用完之前不能强行剥夺 循环等待条件 ：若干进程之间形成一种头尾相接的循环等待资源的关系 ✨死锁处理： 破坏产生死锁的4个必要条件中的一个或者多个 预防死锁：预先静态分配法（破坏不可剥夺条件）、资源有序分配法（将资源分类按顺序排列，保证不形成环路）。 避免死锁：银行家算法（对每个资源请求进行检测，确保安全。需要很大的系统开销）。 检测死锁：资源分配图简化，非孤立点的进程处于死锁状态。 解除死锁：资源剥夺法、撤销进程法。 四、CPU调度算法 （在就绪序列中怎么挑选进程让CPU执行）先来先服务调度算法FCFS：按作业或者进程到达的先后顺序依次调度；（平均周转时间可能会很长 ） 短作业优先调度算法SJF：算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行（周转时间短，但是响应时间长 ） 时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;（响应时间可以得到保证） 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。(堆实现优先队列) 五、锁多线程编程中需要使用的锁。锁要解决的是线程之间争取资源的问题，这个问题大概有下面几个角度： 资源是否是独占（独占锁 - 共享锁） 抢占不到资源怎么办（互斥锁 - 自旋锁） 自己能不能重复抢（重入锁 - 不可重入锁） 竞争读的情况比较多，读可不可以不加锁（读写锁） 内存管理六、堆栈栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。系统操作，不需要程序员手动干预。 栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。eg.递归过深，超过，stackoverflow 七、缓存算法LRU（least recently used）最近最久未使用 页面置换算法——插入、访问、淘汰。 1、哈希+双向链表： 现在哈希表中查询是否存在该数据，根绝索引找到数据存储的位置，查询时间变为O(1)。 先查询链表中是否有该分页，没有的话查看cache是否满，未满直接放在头尾；满了则删除尾部，再将其放在头部。 存在该分页，则先移除原本的node，将其放在头部。 2、哈希表+数组 ： 哈希表存储数据项对应的位置+频次，被访问后频次+1。插入和访问为O(1) 淘汰的时候在表中找到最少访问的，在数组中删除，再放入新的内容，淘汰为O(n)。 操作系统五个基本功能1、存储管理：内存分配、内存保护、地址映射、内存扩充2、处理机管理：进程控制、进程同步、进程通信、进程调度3、设备管理：缓冲管理、设备分配、设备处理、设备独立性和虚拟设备4、文件管理：外存管理、目录管理、文件操作5、用户接口：命令接口、程序接口、图形接口 第2部分 进程管理第1章 进程与线程1.1 进程进程（Process)：一个具有一定独立功能的可并发执行的程序，在一个数据集合上的运行过程。用来记录进程信息的数据结构 进程控制块PCB：用以记录与进程相关信息的主存区，是进程存在的唯一标志（管理进程的核心，包含了PID等进程的所有关键信息）用链接指针链成队列； 进程的三种基本状态（多线程时也是这些状态） ​ 运行状态(Running) ​ 就绪状态(Ready) ​ 阻塞状态(Block) 队列：就绪队列、等待（阻塞）队列。 处于就绪状态的进程，在调度程序为之分配了处理机之后便开始执行， 就绪 -&gt; 执行 正在执行的进程如果因为分配他的时间片已经用完，而被剥夺处理剂， 执行 -&gt; 就绪 如果因为某种原因致使当前的进程执行受阻，使之不能执行。 执行 -&gt; 阻塞 1.2 线程线程(Thread)，是进程中的一个实体，是能被系统独立调度和分派的基本单位。引入线程，是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 线程最直接的理解就是“轻量级进程”。 2.3 进程和线程的对比进程是系统进行资源调度和分配的基本单位；线程是CPU调度的基本单位。 进程 = 资源 （包括寄存器值，PCB，内存映射表）+ TCB（栈结构）线程 = TCB（栈结构） 线程 的资源是共享的进程 间的资源是分隔独立的，内存映射表不同，占用物理内存地址是分隔的 线程 的切换只是切换PC，切换了TCB（栈结构）进程 的切换不仅要切换PC，还包括切换资源，即切换内存映射表 第2章 进程的同步与通信2.1 进程同步进程之间存在两种基本关系：竞争关系和协作关系。 同步的解决方案：管程，信号量。 信号量即利用PV操作来对信号量进行处理。当它的值大于0时，表示当前可用资源的数量； 当它的值小于0时，其绝对值表示等待使用该资源的进程个数。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 2.2 进程的数据通信1、共享存储器系统 A、共享数据结构： 信息交换的格式、类型一定； 进程通信由程序员完成，效率低； B、共享存储区： 进程可随时向系统申请一块存储区， 并指定该分区的关键字，用于进程通信。 2、消息传递系统 A、直接通信方式 Send(Receiver,message);Receive(Sender,message); B、间接通信方式：1、信箱的创建、撤消； 2、消息的发送和接受； Send(mailbox,message); Receive(mailbox,message); 3、管道通信(Pipe Communication)管道：用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为Pipe文件。 功能：Command1进程以字符流的形式向管道发送大量的数据，Command2进程则从管道接收数据。两进程实现单向、同步、互斥运行。 ​ 单向：Command1只能发送； ​ 同步：管道满时，Command1等待； ​ 互斥：同一时刻，只能有一个进程对管道操作； （4）消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 （5）套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同的主机间的进程通信。通过”套接字”向网络发出请求或者应答网络请求。 2.3 几种线程间的通信机制1、锁机制 1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。 1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。 1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 2、信号量机制：包括无名线程信号量与有名线程信号量 3、信号机制：类似于进程间的信号处理。 ### 第4章 调度与死锁CPU调度算法 （在就绪序列中怎么挑选进程让CPU执行）先了解两个概念： 周转时间： 从开始申请执行任务，到执行任务完成 响应时间： 从开始申请执行任务到开始执行任务 先来先服务调度算法FCFS：按作业或者进程到达的先后顺序依次调度；（平均周转时间可能会很长 ） 短作业优先调度算法SJF：算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行（周转时间短，但是响应时间长 ） 高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;（响应时间可以得到保证） 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。 ✨死锁 在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。 ✨产生条件：互斥、占有等待、非剥夺和循环等待。 互斥条件 ：一个资源一次只能被一个进程使用 请求保持条件 ：一个进程因请求资源而阻塞时，对已经获得资源保持不放 不可抢占条件 ：进程已获得的资源在未使用完之前不能强行剥夺 循环等待条件 ：若干进程之间形成一种头尾相接的循环等待资源的关系 ✨死锁处理： 破坏产生死锁的4个必要条件中的一个或者多个 预防死锁：预先静态分配法（破坏不可剥夺条件）、资源有序分配法（将资源分类按顺序排列，保证不形成环路）。 避免死锁：银行家算法（对每个资源请求进行检测，确保安全。需要很大的系统开销）。 检测死锁：资源分配图简化，非孤立点的进程处于死锁状态。 解除死锁：资源剥夺法、撤销进程法。]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的计时器]]></title>
    <url>%2F2019%2F02%2F28%2FiOS%E5%9F%BA%E7%A1%80%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目介绍 项目完全由代码所写，没有使用storyboard，代码更具有复现性。 手动部分：需要将图片拖入assets 项目知识SnapKit 布局经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达9340颗星。 作者仍然是写Objective-C的第三方库Masonry的大牛 - @Robert Payne。 SnapKit配置1.github下载：https://github.com/SnapKit/SnapKit 2.将下载下来的SnapKit项目的 SnapKit.xcodeproj 拖进自己的项目目录最外层中 3.工程文件 -&gt; General -&gt; Embedded Binaries 中点击加号，添加SnapKit库到项目中来 4.command+B 重新编译项目 SnapKit使用123456789101112131415161718192021import UIKitimport SnapKit class ViewController: UIViewController &#123; // 1.定义box var box = UIView() override func viewDidLoad() &#123; super.viewDidLoad() box.backgroundColor = UIColor.orange // 2.将box加入父视图，之后的布局是相对于父视图布局的 self.view.addSubview(box) // 3. 添加布局的约束：上下左右、中心、 box.snp.makeConstraints &#123; (make) -&gt; Void in make.width.equalTo(100) make.height.equalTo(100) make.center.equalTo(self.view) &#125; &#125;&#125; Timer 计时器初始化1234self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true ,block:&#123; (timer) in // withTimeInterval ： 的值0.1s 时间片后，执行的代码 // repeats : withTimeInterval的时间后，是否继续重复 &#125;) 启动：fire1self.timer.fire() 您可以使用此方法来触发重复计时器，而不会中断其常规的触发计划。 如果计时器不重复 repeats，则在触发后自动失效，即使其预定的触发日期尚未到达。 暂停：invalidate（移除计时循环）1self.timer.invalidate() 官方的解释是： This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes and releases the timer, either just before the invalidate method returns or at some later point. 这是唯一一个把一个定时器从NSRunLoop object运行循环中移除的方法。 NSRunLoop object这个对象移除，并且release掉这个的定时器，或者是在这个invalidate方法返回的之前或是在之后的某个时间段，再进行移除并release操作。 guardguard 打头只判断合理条件，保证判断条件简约 guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 详见 guard详解 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//// ViewController.swift// WatchDemo//// Created by iris on 2019/2/27.// Copyright © 2019 iris. All rights reserved.//// 学习：import UIKitimport SnapKitclass ViewController: UIViewController &#123; var timer:Timer! var resultLabel:UILabel! //计时器：文字显示 var resultNumber:Double = 0 //计时器：时间记录 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 1.计时器的数字显示 // 1.1 数字的背景 let resultView = UIView() resultView.backgroundColor = UIColor.init(red: 0.0, green: 0.0, blue: 0.1, alpha: 1) // 注意：使用snp.makeConstraints方法的元素必须事先添加到父元素的中，例如：self.view.addSubview(view) self.view.addSubview(resultView) resultView.snp.makeConstraints&#123; (make) in make.top.equalTo(0) make.left.equalTo(0) make.height.equalTo(300) // 长度 300 make.width.equalTo(self.view.frame.width) &#125; // 1.2 数字的显示 resultLabel = UILabel() self.view.addSubview(resultLabel) resultLabel.textColor = UIColor.black resultView.addSubview(resultLabel) resultLabel.snp.makeConstraints&#123; (make) in make.center.equalTo(resultView) make.width.height.equalTo(140) make.width.equalTo(400) &#125; resultLabel.font = UIFont.init(name: "Helvetica Neue", size: 60) resultLabel.text = "0.0" resultLabel.textColor = UIColor .white // 设置字体对齐方式 resultLabel.textAlignment = NSTextAlignment.center // 2.开始按钮 // 2.1 开始按钮：背景 let startView = UIView() startView.backgroundColor = UIColor.init(red: 0.1, green: 0.0, blue: 0.8, alpha: 0.8) self.view.addSubview(startView) startView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.left.equalTo(0) make.bottom.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 2.2 开始按钮：布局 let startButton:UIButton = UIButton() // startButton.setTitle("Start", for: UIControl.State.normal) startButton.setImage(UIImage (imageLiteralResourceName: "start"), for: UIControl.State.normal) startView.addSubview(startButton) startButton.snp.makeConstraints &#123; (make) in make.center.equalTo(startView) make.width.height.equalTo(50) &#125; // 2.3 开始按钮：点击事件添加 startButton.addTarget(self, action: #selector(startHander), for: UIControl.Event.touchUpInside) // 3 停止按钮 // 3.1 停止：背景 let stopView:UIView = UIView() stopView.backgroundColor = UIColor.init(red: 0.1, green: 0.8, blue: 0.0, alpha: 0.8) self.view.addSubview(stopView) stopView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.bottom.equalTo(0) make.right.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 3.2 停止：按钮 let stopButton:UIButton = UIButton()// stopButton.setTitle("Stop", for: UIControl.State.normal) stopButton.setImage(UIImage (imageLiteralResourceName: "pause"), for: UIControl.State.normal) stopView.addSubview(stopButton) stopButton.snp.makeConstraints &#123; (make) in make.center.equalTo(stopView) make.width.height.equalTo(50) &#125; // 3.2 停止：按钮事件添加 stopButton.addTarget(self, action: #selector(stopHander), for: UIControl.Event.touchUpInside) // 4 重置 // 4.1 重置按钮 let resetButton:UIButton = UIButton() resetButton.setTitle("Reset", for: UIControl.State.normal) resetButton.titleLabel?.font = UIFont.init(name:"Helvetica Neue",size:20) resultView.addSubview(resetButton) resetButton.snp.makeConstraints &#123; (make) in make.right.equalTo(-10) make.top.equalTo(10) make.width.equalTo(100) make.height.equalTo(50) &#125; // 4.1 重置：事件监听 resetButton.addTarget(self, action: #selector(resetHander), for: UIControl.Event.touchUpInside) &#125; // 3个按钮的事件函数 // 1.开始计时 @objc func startHander()&#123; if self.timer != nil&#123; self.stopHander() &#125; self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true,block:&#123; (timer) in self.resultNumber = self.resultNumber + 0.1 self.resultLabel.text = String(format:"%.1f",self.resultNumber) &#125;) self.timer.fire() &#125; // 2.暂停时间 @objc func stopHander()&#123; // 2.1 不进行判断的方法，可能出现异常，内存可能泄露// var timerForDistory:Timer!// timerForDistory = self.timer// timerForDistory.invalidate() // 2.2 进行判断的方法，可能出现异常，内存可能泄露 // guard 打头只判断合理条件，保证判断条件简约 // guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 guard let timerForDistory = self.timer else &#123; return &#125; timerForDistory.invalidate() &#125; // 3.重置计时器 @objc func resetHander()&#123; self.resultNumber = 0 self.resultLabel.text = "0.0" &#125;&#125;]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的加法计算器swift版本]]></title>
    <url>%2F2019%2F02%2F26%2FiOS%E5%9F%BA%E7%A1%80%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8swift%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[近日开始学习IOS开发。想找一个简单版本较新的IOS开发教程都很难：（1）现在找的很多都是object-C的，不是swift的，（2）老版与最新版本swift中很多语法也不适配，（3）Xcode版本和用法也不一样。 因此，今天自己写一个最简单的教程，用于swift入门，记录自己的学习。 基础步骤基础步骤就是项目类型、项目名称、项目位置的选取。 1.创建APP 2.项目类型为 简单的view 3.项目名称：加法计算器 4.结果 界面拖拽1、打开故事版，找到UI部件框，搜索需要的部件——输入框、Label、按钮 2、拖拽部件、部件位置布局、部件更名，右边为其结果 3、选择展示设备、选择运行设备、运行程序查看结果 4、运行结果，布局已经实现 功能实现输入框定义1、左右展示storyboard与ViewController文件，用于拖拉式实现部件定义和部件功能添加。 2、方式1：text部件定义，按住control，鼠标拖拽至ViewController对应空白处，接着添加名称以及修改属性。 方式2：输入语句，将代码前的空心点拖拽左边的UITextField @IBOutlet weak var sum: UITextField! 3、定以后的结果如下。 使用方式1拖拽num1，num2定义，使用代码和空心圈绑定至左边UITextField。 按钮功能1、添加Action作为响应 生成如下的代码，我们可以将功能函数写在calculate方法的代码内 2、编写计算的代码和清空的代码 1234567891011121314151617181920212223//计算方法//sum = num1+num2@IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125;//重置方法@IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = ""&#125; 3、结果，可以实现浮点数相加的功能 项目源码ViewController代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//// ViewController.swift// Calculation_add//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; //UITextField的定义 @IBOutlet weak var num1: UITextField! @IBOutlet weak var num2: UITextField! @IBOutlet weak var sum: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; //计算方法 //sum = num1+num2 @IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125; //重置方法 @IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = "" &#125;&#125; 下载资源 CSDN资源https://download.csdn.net/user/katherine_java/uploads]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统下使用Hexo在Github上搭建博客]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%AD%98%E6%A1%A3%2FMac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、安装环节二、Hexo部署三、github仓库四、git代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的Web服务器搭建]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FNode.js%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[服务器搭建 12345//安装服务区npm install http-server -g//启动服务器http-server 打开浏览器，进入指定端口访问： 问题：查看所需端口是否被占用 lsof -i tcp:8080 删除该PID，则该端口号就不会被占用 kill 7826]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具整理 - 设计类工具]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%AD%98%E6%A1%A3%2F%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%20-%20%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[设计icon：https://www.canva.cn/ 生成icon：https://appicon.co/ 海报： 阿里矢量图标：https://www.iconfont.cn/ 矢量图标：https://www.easyicon.net/update/ 机器学习：https://mp.weixin.qq.com/s/F_AvAtITyQHWhXgi2K02Ag 快捷键 command+shift+g ：跳出窗口，进入地址 Cammand+i :格式化 简历：]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期实习面试 - 腾讯PCG移动客户端iOS开发面试]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E8%85%BE%E8%AE%AF%E6%89%8B%E6%9C%BAQQ%E7%9C%8B%E7%82%B9iOS%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[基本信息事业群：PCG 产品：手机QQ 看点 岗位：移动客户端开发（iOS、Objective-C语言开发） 地点：深圳总部 转正：几率较小 实习时间：6月份之后的暑期实习 面试日期：3月30日 - 3月31日 offer call：4月10日(看到很多小伙伴都接到offer call了，内心有一些着急，9号换了ycy头像) 一面面试时间一共为：28min，3月30日 问题涉及：iOS项目、操作系统 问题未涉及：计算机网络、数据结构、算法、场景 项目介绍及相关问题：APP1.获取当前天气功能为什么要使用协议代理？过程如何？表述还需加强。 2.是否接触TableView渲染性能相关的东西？ cell的数目，配置tableview数据 重用单元格的形式，数据成千上万行，最终渲染个数为屏幕上显示的数目。 往下拉的时候，最上面的cell到最下面来，放置重复渲染，提高手机性能。 刷新页面的两种方法 无动画效果：tableView.reloadData()，就是相当于执行 cell for row的方法，将结果取出来，再更新视图 将刷新语句放在View.beginUpdates()、tableView.endUpdates()中间，可以提高app的性能 基础问题iOS相关问题3.MVC模式，有什么缺点？介绍了概念和优点。 缺点猜测作答。 4.RunLoop是什么？ 概念：事件循环对象，在循环过程中处理各种事件（点击、刷新等），从而保持程序持续运行；在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 为什么需要：一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理时间但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现。 Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。我们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。 5.点击事件之后发生什么？这里没准备过，跟面试官说是否可以根据已有知识猜测一下流程，面试官说可以。 大概从获取事件源，执行事件内容方面作答。 操作系统问题6.进程和线程的区别？操作系统的概念；异同点；iOS上的进程和线程，多线程。 7.多线程共享资源，如何防止资源问题？ 资源是否是独占（独占锁 - 共享锁） 抢占不到资源怎么办（互斥锁 - 自旋锁） 自己能不能重复抢（重入锁 - 不可重入锁） 竞争读的情况比较多，读可不可以不加锁（读写锁） 提问环节我：为什么面试时间较短？有人面试一个小时，被举报了。 面试官：是否介意转正率低？不介意，先努力转正，不行可以秋招再投递。 二面面试时间一共为：28min，3月30日 问题涉及：iOS项目、网络、排序算法 项目介绍及相关问题自由探索科研项目1.高维数据降维2.数据稀疏如何处理3.梯度下降过程APP4.网络请求的第三方库是什么？基础问题网络5.HTTP状态码6.HTTP和HTTPS的区别算法7.稳定的排序有哪些？三面面试时间一共为：23min，3月31日 项目介绍及相关问题1.遇到的困难？反向传值delegate+protocal； GCD主线程控制UI刷新。 2.是否了解性能相关的东西？渲染和多线程 3.是否了解跨平台开发？不了解，聊了一些前端的东西。 https://juejin.im/post/5b076e3af265da0dce48fe95 social环节4.为什么想做iOS开发？5.未来移动端开发的趋势是什么？可能以后 Web 和 Native 的边界会越来越模糊。偏向于Hybrid APP开发。 (我是果粉，面试的时候表现的是热爱iOS开发。然而说到最后，面试官老师说未来的趋势是安卓，感觉就有点崩了。最后建议我了解跨平台开发。) HR面时间：9min，3月31日下午4点半 自我介绍+哪里人+是否愿意来深圳之类的问题。 offer call时间：2min，4月10日上午11点 确认个人信息、部门、岗位、工作地点。 通知今日之内会发放offer到邮箱。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历 - 简历要点]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%AD%98%E6%A1%A3%2F%E7%AE%80%E5%8E%86%20-%20%E7%AE%80%E5%8E%86%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[简历命名除了姓名是一定要有的，最好还有这几个信息：岗位方向、学校、几几届（不是几几级），后两个是针对校招简历 排版排版是简历给面试官的第一印象，正所谓人靠衣装……但是排版其实是需要审美的，有人说那我不会穿衣打扮怎么办，不会打扮不要紧，但是要会打理，可以不会搭配，但是需要打理得干净、整洁、大方，不能给人邋遢的感觉，简历也是这个道理 第一是行间距，不知道大家有没有看过一些简历字迹是挤在一起一坨一坨的，这种情况下，稍稍加大一点行间距，就可以美观很多，单倍行距太小了，1.5倍太宽，一页纸写不下多少东西，比较合适的参考值是1.2和1.25倍 第三是字体，字体可以通篇一致（指中文一致，英文数字一致，并不是中英文都一致），也可以根据分级目录选字体，字体颜色大小粗细都可以根据审美自行调整，但核心还是要整洁大方 第四是标点，尤其注意列项的时候，切忌有的加标点有的没加，还要注意半角全角等 内容个人信息个人信息里面，三项必填的，姓名、电话、邮箱，几项选填的，性别、年龄、学历、所在地、政治面貌等，有些没必要填的，学校专业班级，学校专业可以放在教育经历那一栏，还有，如果有技术博客和GitHub，建议都写上 实习工作经历、项目经验除了公司和时间，重要的是做的是啥，项目经验也是一样，做了啥，才是整个简历面试官想看的主要部分，个人觉得这块可以尝试这么去写，先是简单介绍整体项目，再说一说用到的技术栈，再是自己在项目中的角色，承担的部分，也可以把遇到的最大的挑战、难点写上去，前提是你得想好应对政策，面试的一大套路是让面试官往你铺设的道上走 如果你做的项目很多，挑最熟悉的写，难度最大的，收获成长最多的，这些你有的讲 一般挑两到三个细写就可以了 基本技能这个常规写就好，不要太夸张，也不要太笼统，一句熟悉C、C++、Java，就没有展开了，可以稍微具体一点 获奖经历、科研成果挑重点写，获奖经历最好写含金量比较大的，小规模的比赛其实没必要写，奖学金的话可以写国奖，校级院级的个人觉得也没什么必要，有论文专利之类要写上 自我评价这块其实是最虚的东西，写得好与坏差距挺大的，但基本套话比较多，所以自己衡量 自我评价真的很虚，写得好和坏差距挺大的，如果你觉得写得好的，往上放，这是亮点]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F01%2F06%2F%F0%9F%91%80IOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%205%20%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析iOS原生风格的极简的日程管理工具。 现有的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打：界面使用iOS原生风格，随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 功能需求浏览任务页面：可以在tableview查看所有任务及其完成状态；可以在编辑状态下批量删除任务、移动任务顺序；按下navigation的+进入添加任务页面；按下&gt;进入修改任务页面。 添加修改页面：判断当前任务是添加还是修改。使用自定义protocol和delegate反向传值，将文字传回浏览页面。 知识点主线程https://www.jianshu.com/p/f042432e2d7d TableView的使用1.我们知道tableView是IOS中的高级视图，其继承与ScrollView，具有ScrollView的功能，还扩展了许多。 2.tableView的表现格式分两种Plain和Grouped两种风格 3.tableView的两种代理类delegate和dataSource.这两种代理至关重要，我们在做tableView和这些代理是分不开的。 4.代理中比较常用的代理方法： (1)dataSource的两个必须使用的代理 显示UITableView的Cell的个数：一共有多少个格子 Cell和model的数据的交互：根据数据，获取每一个数据的值 5.增删改查需要做的：第一步获取需要操作的行数（增加不需要），第二步对数据库进行处理，第三部更新视图 6.更新视图的2种方式：beginUpdates、endUpdates之前操作（如一行一行的删除数据）；tableView.reloadData()刷新TableView了。 在使用数据库之后，我就直接reloadData()刷新TableView了。比较方便 123456// 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() Navigation使用，sugue实现跳转常用控件：相当于一个扑克盒子，里面的页面是出栈和入栈来实现试图切换。 利用segue界面跳转一共有两种方式： 第一种就是以上我的例子，利用button组件，拖拽添加segue，直接运行就可以用。 第二种是利用ViewController与ViewController之间，拖拽添加segue。不过，这种方法就需要在相应需要跳转的方法内写入代码，手动去设置它的跳转。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： 项目布局UI设计页面一页面二步骤配置tableview数据重用单元格的形式，数据成千上万行，最终渲染个数为屏幕上显示的数目。 往下拉的时候，最上面的cell到最下面来，放置重复渲染，提高手机性能。 使用tableview cellCell定一个class为TodoCell，Cell使用as!强制转换为TodoCell。 model结构体使用Struct初探结构体：不需要写初始化构造器，直接可以构造出来；轻量级的class indexPath动态配置每行数据确定位置：第几行indexPath.row、第几段indexPath.session cell切换打勾和取消使用static单元格，grouped风格。 navigation controller压栈(入栈)和出栈navigation controller类似扑克盒子 跳转实现 主页面标题设置为大标题，需要在选中navigation页面，设置大标题 新页面需要设置小标题，添加item当做标题，再修改名称，改为大标题为never 返回按钮的名称需要在页面一的任务清单UINavigationItem中修改 添加任务功能✨流程如下： 使用：(自定义protocol和delegate反向传值)+出栈 添加新任务：反向传值 确定之后页面消失：出栈，navigation老大让他出栈 编辑任务✨1 正向传值segue将选中的cell中的（1 任务文本todo；2选中的行数row）传到编辑页面 2 编辑页面根据输入框判断是否有文本，定下title。若不为空，title为编辑任务；为空title为添加任务 3 修改后按下navigate bar button确认后，将（1修改后的文字；2之前选中的行数）传回主页面 4 主页面中实现协议的函数中：修改mode数组中的数据，根据行数row找到cell，再将cell的文字改为新的任务 左滑删除已经预置代码，直接取消注释； 添加上删除某一行的数据； 更新页面已经写了，不需要添加。 批量选择+批量删除navigation自带了添加编辑button的代码，取消注释，将button改到左边即可，还需要批量功能 由于需要批量的对象是table view，选中他，找到edit选择multiple 编辑即可 实现批量选中的效果： 批量删除需要重新放一个”删除“按钮； 在按下按钮后：获取选中的indexPath存储于数组，通过循环删除数据对应行数indexPath.row，使用table view的delete方法删除存于数组中的行数 1234567891011121314// 获取所有被选中的indexPath，若为空则不进行删除操作if let indexPaths = tableView.indexPathsForSelectedRows&#123; //1 Model 数据删除 for indexPath in indexPaths&#123; todos.remove(at: indexPath.row) &#125; //2 View 视图更新—— table View的删除方法 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能 tableView.beginUpdates() tableView.deleteRows(at: indexPaths, with: .automatic) tableView.endUpdates() // 方式二：从新load数据更新页面；但没有动画效果 //tableView.reloadData()&#125; ps 更新视图 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() 发现无法选择，原因是：原先的设置选择后，立即变成未选中状态，使得页面保持白色，不会保持变成灰色。需要：在原先的选择代码中，使用flag——isEditing，判断若在editing状态，则可以选中、打钩等一系列操作。 1234// 如果不是在编辑的情况下，选择打勾才有用、取消选中等才有用 if !isEditing&#123; //选择的代码——选择后原数据状态改变、重新mark为相反的、判断mark绘制√，取消选择背景变回白色 &#125; 按钮的默认文字汉化左滑时候的delete —— 变成 ”删除“的关键词：tableView、title、delete、button后出现需要重写的方法 批量选择edit、done改成中文——1 通过command+点击获取方法、2通过三元运算符+isEditing确认是”编辑“还是”确定“ 移动单元格已有该方法，重写to support rearranging the table view 首先使用临时变量temp交换两个数据，接着更新视图moveRow（不写这一句也可以移动，即自动调用）。 但是这里存在一个小bug，当编辑状态下，当选中数据，被移动后，该数据将一直处于选中状态，且无法删除。结局方法为：移动数据后，reloadData，取消选中状态，就不会导致setEditing函数自动调用该函数，导致混乱。 1234567891011121314// 移动单元格功能// Override to support rearranging the table view.override func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to: IndexPath) &#123; // 1 移动数据 let temp = todos[fromIndexPath.row] todos[fromIndexPath.row] = todos[to.row] todos[to.row] = temp print(todos) // 2 更新数据:自动更新,可以不用下面的代码 tableView.moveRow(at: fromIndexPath, to: to) // 3 移动后，刷新 tableView.reloadData()&#125; 简单数据存储userDefaultsAppDelegate文件+轻量级本地存储userDefaults+编码解码 1 AppDelegate文件：APP的声明周期：打开：APP启动、激活 按下home健：由于某种原因被挤到后台、进入后台 再次进入：即将激活、激活 退出：（APPlist 中）进入后台、（退出后）完全退出 2 数据数据存储在沙盒里面，信息安全，本APP只能访问本APP的数据 沙盒数据中只能存储基本的数据类型，我们的数据是存储对象的Array，无法存储进沙盒plist，因此需要写一个存储函数来编码数据为.data 3 使用userDefaults写好储存数据的方法（编码为data格式+存入沙盒）和解码方法（通过forKey获取数据，解码至todos数组）： 1234567891011121314151617181920212223242526// 数据存储——编码数据func saveData()&#123; // 可能会抛出错误 do&#123; // 编码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 let data = try JSONEncoder().encode(todos) // 得到data类型的数据，存入沙盒 UserDefaults.standard.set(data, forKey: "todos") &#125;catch&#123; print(error) &#125;&#125;//取数据——解码func getData()&#123; // 获得data类型的数据，由于可能为空，则使用if let：不为空的时候获取本地数据，为空则不获取 if let data = UserDefaults.standard.data(forKey: "todos") &#123; // 解码固定格式 do&#123; // 解码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 todos = try JSONDecoder().decode([Todo].self, from: data) &#125;catch&#123; print(error) &#125; &#125;&#125; 再把写数据的函数在所有操作数据处理调用； 在程序load时候调用取数据。 本地存储coredata和realm了解cs和bs+什么是数据库+为什么App需要本地存储 cs：client-server —— QQ、微信——聊天记录存在本机 bs：browser-sever —— 网页论坛——数据存储在服务器 IOS本地存储数据库： userdefaults——轻量级的数据 coredata——苹果自带的，学习成本高，代码多、不够快——了解 realm：速度快 realm安装与示例使用由于cocoapods无法pod，我选择下载安装法，自行配置： 先去 Realm 的官网去下载最新框架： https://realm.io/cn/docs/swift/latest/#prerequisites 接着拖拽 RealmSwift.framework 和 Realm.framework 文件到”Embedded Binaries”选项中。选中 Copy items if needed 并点击 Finish 寻找应用的 Realm 文件：Swift using Realm Swift:(lldb) po Realm.Configuration.defaultConfiguration.fileURL command+shift+g ：跳转窗口，进入沙盒 在model中新建模型User.swift，import包，定义模型 1234567import Foundationimport RealmSwift// 定义模型的做法和定义常规 Swift 类的做法类似class User: Object &#123; @objc dynamic var name = "" @objc dynamic var age = 0&#125; 进入AppDelegate，找到启动的方法，在该方法中： 1 数据实例化 do - catch中 2 创建数据库、3 存储数据 1234567891011121314151617181920212223func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. print("APP启动") // 0 输出沙盒地址 print(Realm.Configuration.defaultConfiguration.fileURL) // 1 实例化需要存储数据 —— 实例化user对象 let user = User() user.name = "Iris" user.age = 18 do&#123; // 2 创建一个数据库 let realm = try Realm() // 3将对象存入数据库 try realm.write &#123; realm.add(user) &#125; &#125;catch&#123; print(error) &#125; return true&#125; 查看数据：print(Realm.Configuration.defaultConfiguration.fileURL) command+shift+g ：输入得到的地址，跳转窗口，进入沙盒，查看的结果 realm操作1 在主页面处实例化数据库，为全局变量123// 使用数据库后，todo相当于一个中间人的角色// 实例化realm数据库 —— 强制try，确定不会出异常 （一般不这样写，可能会出现网络等异常）let realm = try! Realm() 2 创建RealmSwift的类 class Todo1234567import Foundationimport RealmSwift//定义模型的做法和定义常规 Swift 类的做法类似class Todo: Object &#123; @objc dynamic var name = "" @objc dynamic var checked = false&#125; 2 写数据新增数据功能： 新增数据后，创建一个类Todo的todo对象，传入saveData 3 取数据现在viewLoad()的时候，读取数据。发现需要results类型，所以下一步更改todos的类型 12// 从Realm数据库中读取数据 todos = realm.objects(Todo.self) 声明todos由数组类型改为复合类型，接受取出来的 result array的数据，定义为可选性，可能为空 123456789//定义为esults类型todos -- 定义复合数据类型 -- 名字:复合类型&lt;类型&gt; ——1种方式var todos: Results&lt;Todo&gt;? //定义空数组L：需要指明数组内存的类型。—— 3种方式//var Todos: Array&lt;Todo&gt;=[]//var todos:[Todo] = []//var todos = [Todo]()//定义空字典的方法：指明key和value的类型; [:]表明m空字典。—— 2 种方式//var dict:[String:Any] = [:]//var dict = [String:Any]() 可选性（todos为空），则初始的时候判断。 为此，进行初始判断：当todos取出来为空的时候，数组的行数为0，且出现文字——请添加任务 12345678910111213141516171819// 二、每段有几行：第i个session的行数override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows // todos?.count ：?表示，该符号前面为空，则不执行后面的，整个则为 nil // 空合运算符 xxx ?? ooo ,xxx为空，则执行ooo // 若tosos为空，则ession的行数 返回1 return todos?.count ?? 0&#125;// 三、每行显示什么override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 想要用到的到TodoCell下面的属性，向下z强制转型 let cell = tableView.dequeueReusableCell(withIdentifier: "todo", for: indexPath) as! TodoCell // 若取出的todos不为空，我们赋值给 这里的todos，可以在下面用 if let todos = todos&#123; //确定位置 第几行indexPath.row、第几段indexPath.session // Configure the cell... cell.todo.text = todos[indexPath.row].name cell.checkMark.text = todos[indexPath.row].checked ? "✓" : " " &#125; 在存储数据的时候，把更新页面直接改为reload()方法。 修改数据1 修改任务部分 ：获取当前行数，修改todos![indexPath.row].name = name；更新视图 2 状态更改部分：按下，状态取反，修改todos![indexPath.row].checked =取反；更新视图 删数据删除数据 更新视图 12345678910111213// Override to support editing the table view.override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; // 数据操作 do&#123; try realm.write &#123; realm.delete(todos![indexPath.row]) &#125; &#125;catch&#123; print(error) &#125; // 更新视图 tableView.reloadData()&#125; Realm-搜索和排序+searchBar+收起软键盘+主线程点击search bar 搜索，发生什么事情。 想到需要一个delegate协议。先遵守协议UISearchBarDelegate，再委托。告诉Todos Controller，search bar是老板（委托人），一会他有些申请会委托给controller做。 12345678910111213// 实现搜索功能// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 todos = todosData.filter("name CONTAINS %@", searchBar.text!) // 2 更新视图 tableView.reloadData()&#125; 当searchBar内容改变的时候，查看其是否为空，若为空，则‘’‘ 搜索之后，根据创建时间排序。先在class 中添加时间属性为当前时间，搜索的时候按照时间倒叙： 123456789101112// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 // 排序：时间倒叙 todos = todosData.filter("name CONTAINS %@", searchBar.text!).sorted(byKeyPath: "createdAT", ascending: false) // 2 更新视图 tableView.reloadData()&#125; 收起键盘：学习：https://www.jianshu.com/p/f042432e2d7d 1234567891011121314151617// 二、在搜索栏清空后，需要显示所有数据，且收起键盘 func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) &#123; // 看是否为空 if searchBar.text!.isEmpty&#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) todos = todosData // 2 更新视图 tableView.reloadData() // 让用户界面在主线程上进行——优先执行 // 经常用于使UI方面的操作提前执行，查询可以慢慢查，我们的键盘先收起来——用户体验更好 DispatchQueue.main.async &#123; // 3.收起键盘 让searchBar失去焦点(光标消失+软件盘收起) searchBar.resignFirstResponder() &#125; &#125; &#125; 未完成： //需求：打√之后，就放置在最后，取消打钩，放置在最前 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础]]></title>
    <url>%2F2019%2F01%2F06%2F%E2%9C%A8iOS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[RunLooprunloop是一个事件循环对象。 do { //接受消息-&gt;等待-&gt;处理 }while(message != quit) 概念：事件循环对象，在循环过程中处理各种事件（点击、刷新等），从而保持程序持续运行；在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 为什么需要：一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理时间但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现。 Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。我们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。 是否接触TableView渲染性能相关的东西？ cell的数目，配置tableview数据 重用单元格的形式，数据成千上万行，最终渲染个数为屏幕上显示的数目。 往下拉的时候，最上面的cell到最下面来，放置重复渲染，提高手机性能。 刷新页面的两种方法 无动画效果：tableView.reloadData()，就是相当于执行 cell for row的方法，将结果取出来，再更新视图 将刷新语句放在View.beginUpdates()、tableView.endUpdates()中间，可以提高app的性能 事件处理触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种： 触屏事件（Touch Event） 运动事件（Motion Event） 远端控制事件（Remote-Control Event） 响应者链当发生事件响应时，必须知道由谁来响应事件。在 iOS 中，由响应者链来对事件进行响应。 所有事件响应的类都是 UIResponder 的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。 1First Responser --&gt; The Window --&gt; The Application --&gt; nil（丢弃） 我们可以通过 [responder nextResponder] 找到当前 responder 的下一个 responder，持续这个过程到最后会找到 UIApplication 对象。 通常情况下，我们在 First Responder （一般也就是用户当前触控的 View ）这里就会响应请求，进入下面的事件分发机制。 事件分发第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个 UIView 对象），即表示当前该对象正在与用户交互，它是响应者链的开端。响应者链和事件分发的使命都是找出第一响应者。 iOS 系统检测到手指触摸 (Touch) 操作时会将其打包成一个 UIEvent 对象，并放入当前活动 Application 的事件队列， 单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理， UIWindow 对象首先会使用 hitTest:withEvent:方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。 内存管理机制：ARC自动引用计数\MRC创建的时候为1，使用的时候+1，不需要的时候-1，为0的时候系统知道其不需要了，则release。 class和struct相同点 可以定义存储属性 能够定义方法 通过下标操作访问实例所包含的值 通过扩展来增加默认实现功能 不同点 类可以继承 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何它所被分配的资源 引用计数允许一个类的多次引用 class是引用类型，struct是值类型 struct会自动生成一个初始化所有属性的构造器 多线程谈及 iOS 中的多线程，一般说的是 pthread，NSthread，GCD，NSOperation 这四种, 用的最多也最方便的就是 GCD 了。 四、线程安全问题 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比几个人在同一时修改同一个表格，造成数据的错乱。 解决多线程安全问题的方法 方法一：互斥锁（同步锁） 1`@synchronized(锁对象) &#123;`` ``// 需要锁定的代码``&#125;` 加了互斥做的代码，当新线程访问时，如果发现其他线程正在执行锁定的代码，新线程就会进入休眠。 方法二：自旋锁 加了自旋锁，当新线程访问代码时，如果发现有其他线程正在锁定代码，新线程会用死循环的方式，一直等待锁定的代码执行完成。相当于不停尝试执行代码，比较消耗性能。 GCD 中两个重要重要概念 —— 队列 &amp; 任务队列是一种特殊的线性表，采用FIFO（先进先出）的原则，队列的主要作用是用来存放任务。 GCD会自动将队列中的任务取出，放到对应的线程中执行。 串行队列（Serial Dispatch Queue）: 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务 并发队列（Concurrent Dispatch Queue）: 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）, 并发功能只有在异步（dispatch_async）函数下才有效 队列执行任务的方式： 同步：在当前线程中执行，当前代码不执行完，就不能够执行下一条代码。会阻塞当前线程。 异步：在另一条线程中执行（不用等待当前代码执行完，就能够执行下一条），不会阻塞当前线程。 主队列 (串行) 1let mainQueue = DispatchQueue.main 全局队列 (并发) 1let globalQueue = DispatchQueue.global() 全局队列默认是并发队列，在不进行第三方框架或者大型的商业应用开发，全局队列基本够用。 主队列 dispatch_main_queue(); 串行 ,更新UI 全局队列 dispatch_global_queue(); 并行,四个优先级: background,low,default,high 自定义队列 dispatch_queue_t queue; 可以自定义是并行: DISPATCH_QUEUE_CONCURRENT 或者串行 DISPATCH_QUEUE_SERIAL 同步不开异步开，串行开1条，并行开多条。 队列中的任务同步执行，队列就不具有开启线程的能力， 队列中的任务异步执行，队列就具有开启线程的能力。（同步和异步执行决定的是否有开启线程的能力） 如果队列具 有开启线程的能力 (队列任务异步执行) 且队列是 串行队列 ，那么将会 开启 1 条线程 。如果队列具 有开启线程的能力 (队列任务异步执行) 且队列是 并发队列 ，那么将会 开启 多 条线程 。开启线程的条数由 GCD 决定。 2.1 全局队列全局队列是获取的，不是程序员创建的。为了方便 GCD 的使用，apple 默认为我们提供的。全局队列默认是并发队列，在不是进行第三方框架或者大型的商业应用开发，全局队列基本够用。 全局 ( 并发 ) 队列异步执行 ： 并发队列异步（不阻塞当前线程）执行（队列就具有开启线程的能力）， 队列会开启多条线程。 12345678任务异步执行不会阻塞当前线程， befor 在最前， after 在任意位置， task 执行顺序不确定 —— 并发执行（index可以确认）。 task 并发执行 —— 并发执行（number可以确认）。异步开线程 number 可以确定开启了多条线程 开的线程数由 GCD 决定。 可以看到线程的 number 有重复，是 GCD 对线程进行了复用。 123456789101112func async() &#123; print("DispatchQueue.global().async: befor", Thread.current) // 全局队列进行 10次异步 for index in 0..&lt;10 &#123; DispatchQueue.global().async &#123; print("DispatchQueue.global().async: task:(taskIndex:\(index)", Thread.current) &#125; &#125; print("DispatchQueue.global().async: after", Thread.current)&#125;打印： 全局 ( 并发 ) 队列同步执行 ： 并发队列同步（阻塞当前线程）执行（队列就不具有开启线程的能力）， 队列不会开启线程（代码都在主线程中执行）。 12345任务同步执行会阻塞当前线程， befor 在最前， after 在最后， task 执行顺序确定 —— 阻塞。同步没有开启线程 number 可以确定没有开启多条线程。所有的代码都在 主线程中执行。 123456789101112131415161718192021222324func sync() &#123; print("DispatchQueue.global().sync: befor", Thread.current) for index in 0..&lt;10 &#123; DispatchQueue.global().sync &#123; print("DispatchQueue.global().sync: task:(taskIndex:\(index))", Thread.current) &#125; &#125; print("DispatchQueue.global().sync: after", Thread.current)&#125;打印： DispatchQueue.global().sync: befor &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:0) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:1) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:2) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:3) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:4) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:5) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:6) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:7) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:8) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: task:(taskIndex:9) &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125;DispatchQueue.global().sync: after &lt;NSThread: 0x60800007fa80&gt;&#123;number = 1, name = main&#125; 2.2 主队列主队列是获取的，不是程序员创建的，apple 默认为我们提供的。 （app 开发中，所有的 UI 更新操作都应该在主线程中进行） 主队列(串行)异步执行 主队列异步（不会阻塞当前线程）执行（队列就具有开启线程的能力）， 队列会开启线程（开启的线程就是主线程）。 1234567891011&gt; 有朋友问我，异步会开启线程， 主队列异步就不会开启线程。 &gt; 我当时还信以为真。认为自己错误，说特殊情况特殊处理。 其实说白了就是学艺不精。&gt; 由于主队列是我们获取的，不是我们创建的，在某种意识中会认为主线程不是在主队列中创建的。（认为一开始就存在的。）&gt; 任务异步执行不会阻塞当前线程， befor 在最前， after 在第二， task 执行顺序确定 —— 串行执行（index可以确认）。同步没有开启线程 number 可以确定没有开启多条线程。所有的代码都在 主线程中执行。 主队列异步的操作主要用在更新 UI 操作中。 具体参考 项目开发中 GCD 代码使用。 123456789101112131415161718192021222324func async() &#123; print("DispatchQueue.main.async: befor", Thread.current) for index in 0..&lt;10 &#123; DispatchQueue.main.async &#123; print("DispatchQueue.main.async: task:(taskIndex:\(index)", Thread.current) &#125; &#125; print("DispatchQueue.main.async: after", Thread.current)&#125;打印： DispatchQueue.main.async: befor &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: after &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:0 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:1 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:2 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:3 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:4 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:5 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:6 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:7 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:8 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125;DispatchQueue.main.async: task:(taskIndex:9 &lt;NSThread: 0x60800006ddc0&gt;&#123;number = 1, name = main&#125; 主队列(串行)同步执行 执行的效果就俩字 死锁 主线程同步，在 Swift 中，编译阶段就报错，在 oc 中是在运行的时候才能发现。体现的主要是界面的 “假死”。 UITableView要实现Tableview必须要签订2个协议 UITableViewDelegate:数据视图的普通协议,作用是:处理数据视图事件.UITableViewDataSource:数据视图的数据代理协议,作用是:处理视图的数据代理. 实现签订的协议的2个协议方法：返回数字，每个section有多少个row 返回cell，cell就是TableView显示时候的格子内容，根据indexPath和数据决定; 观察者设计模式、KVO设计模式——观察者设计模式A对B的变化感兴趣，就注册为B的观察者，当B发生变化时通知A，告知B发生了变化。 指定一个被观察对象(例如 A 类)，当对象某个属性(例如 A 中的字符串 name)发生更改时，对象会获得通知，并作出相应处理； 在 MVC 设计架构下的项目，KVO 机制很适合实现 mode 模型和 view 视图之间的通讯。比如label中的对象为 num=0 ，我们按下按钮之后对象的num++，则label改变。 设计模式——通知机制当用户从后台进入，从非活跃的状态进入活跃状态的时候，系统自动发送“becomeActive”通知，如果有注册监听者（观察者），则执行回调方法。【天气预报需要用】 网络浏览器进行一次网络请求都需要哪些步骤？ 1、域名解析： 浏览器查找域名的 IP 地址、 没找到后发送给 DNS 服务器（本地host，电信），让它解析为 IP 地址 2、TCP的三次握手 3、建立TCP连接后发起HTTP请求，浏览器向 web 服务器发送一个 HTTP 请求 HTTP请求格式：是请求方法（GET/POST/DELETE/PUT/HEAD）、URI路径、HTTP版本号。 3. 2 服务器响应HTTP请求：状态行、响应头、空行、消息体。 4、浏览器解析html代码，并请求html代码中的资源 服务器的永久重定向响应：“https://www.google.com/” 而非“http://google.com/”。 三次握手第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我介绍]]></title>
    <url>%2F2019%2F01%2F05%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[自我介绍一、基本信息：中南研二，本科中南保研本校，现研究方向为数据可视分析。 二、项目： 可视分析的项目：高维数据降维 iOS项目：天气和 以及上一个部门的，四面的面试官推荐的技术栈React-redux-antD等，来重写了iOS的小项目。 三、合适的原因： 专业比较对口，可视分析不只是展示的工具，而是将人类的感知和知识加入到交互中，对数据进行深层次的模式分析和探索。上一面面试官介绍需要做一些数据分析的数据产品。 喜欢技术。自己有申请苹果开发者账号，APP正在审核中。之前和别人做的外包Doable也有上线。 有毅力，为了拿下校运会跨栏金牌，坚持晨跑。且身体健康，可以接受高强度的工作。 具体项目介绍]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发 - 老虎机]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%AD%98%E6%A1%A3%2FJava%E5%BC%80%E5%8F%91%20-%20%E8%80%81%E8%99%8E%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[老虎机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package test.iris; import java.awt.Color; import java.awt.FlowLayout;import java.awt.Font;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Random; import javax.swing.BorderFactory;import javax.swing.ImageIcon;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.SwingConstants;import javax.swing.border.EmptyBorder; public class UI extends JFrame&#123; private static UI ui = null; static String[] paths = &#123; "1.png", "2.png", "3.png" &#125;; private MyLabel labelLeft = new MyLabel(paths[0], 0);// 左图 private MyLabel labelCenter = new MyLabel(paths[1], 1);// 中图 private MyLabel labelRight = new MyLabel(paths[2], 2);// 右图 private JButton button = new JButton("开始");// 开始按钮 private JLabel labelMessage = new JLabel("");// 结果标签 private UI() &#123; setTitle("老虎机"); setBounds(200, 200, 500, 500); JPanel panel = new JPanel(); setContentPane(panel); panel.setLayout(new GridLayout(3, 1)); panel.setBorder(new EmptyBorder(50, 50, 50, 50)); // 上中下三块面板 JPanel panelTop = new JPanel(); JPanel panelCenter = new JPanel(); JPanel panelBottom = new JPanel(); panel.add(panelTop); panel.add(panelCenter); panel.add(panelBottom); // 三张图片显示区域 panelTop.setLayout(new FlowLayout()); panelTop.add(labelLeft); panelTop.add(labelCenter); panelTop.add(labelRight); // 开始按钮面板 panelCenter.setLayout(new GridLayout(1, 1)); panelCenter.setBorder(new EmptyBorder(30, 100, 30, 100)); button.addActionListener(new MyListener()); panelCenter.add(button); // 抽奖结果面板 panelBottom.setLayout(new GridLayout(1, 1)); labelMessage.setBorder(BorderFactory.createLineBorder(Color.BLACK)); labelMessage.setFont(new Font("微软雅黑",0 , 40)); labelMessage.setForeground(Color.red); labelMessage.setHorizontalAlignment(SwingConstants.CENTER); panelBottom.add(labelMessage); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); &#125; public static UI getInstance() &#123; return UI.ui; &#125; public static String[] getPaths() &#123; return paths; &#125; public MyLabel getLabelLeft() &#123; return labelLeft; &#125; public MyLabel getLabelCenter() &#123; return labelCenter; &#125; public MyLabel getLabelRight() &#123; return labelRight; &#125; public JButton getButton() &#123; return button; &#125; public JLabel getLabelMessage() &#123; return labelMessage; &#125; public static void main(String[] args) &#123; UI.ui = new UI(); &#125;&#125; class MyListener implements ActionListener&#123; private boolean buttonFlag = false;// 按钮点击状态，默认未点击 public static boolean threadFlag = true;//线程中断标志 @Override public void actionPerformed(ActionEvent e) &#123; UI ui = UI.getInstance(); JButton button = ui.getButton(); JLabel labelMessage = ui.getLabelMessage(); MyLabel labelLeft = ui.getLabelLeft(); MyLabel labelCenter = ui.getLabelCenter(); MyLabel labelRight = ui.getLabelRight(); if (buttonFlag) &#123; threadFlag = false; buttonFlag = false; button.setText("开始"); synchronized (labelLeft) //等待三个线程释放锁 &#123; synchronized (labelCenter) &#123; synchronized (labelRight) &#123; int leftId = labelLeft.getId(); int centerId = labelCenter.getId(); int rightId = labelRight.getId(); String result = getResult(leftId, centerId, rightId); labelMessage.setText(result); &#125; &#125; &#125; &#125; else &#123; threadFlag = true; buttonFlag = true; new MyThread(220, labelLeft).start(); new MyThread(150, labelCenter).start(); new MyThread(60, labelRight).start(); labelMessage.setText(""); button.setText("暂停"); &#125; &#125; public static String getResult(int leftId, int centerId, int rightId) &#123; String result = null; if (leftId == centerId &amp; leftId == rightId) result = "一等奖"; else if (leftId == centerId || leftId == rightId || centerId == rightId) result = "二等奖"; else result = "未中奖"; return result; &#125;&#125; class MyLabel extends JLabel&#123; private int id;// 标签id public MyLabel(String path, int id) &#123; ImageIcon icon = new ImageIcon(path); setIcon(icon); this.id = id; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class MyThread extends Thread&#123; private long time; private MyLabel label; private Random random = new Random(); public MyThread(long time, MyLabel label) &#123; this.time = time; this.label = label; &#125; @Override public void run() &#123; synchronized (label) //锁住lable对象 &#123; while (MyListener.threadFlag) &#123; try &#123; Thread.sleep(time); int id = random.nextInt(3); label.setId(id); ImageIcon icon = new ImageIcon(UI.paths[id]); label.setIcon(icon); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试题 - iOS]]></title>
    <url>%2F2018%2F09%2F05%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%AC%94%E8%AF%95%E9%A2%98%20-%20iOS%2F</url>
    <content type="text"><![CDATA[1、（iOS开发选做）实现多线程都有哪几种方法？A、使用@synchronized(self) B、使用GCD C、使用NSOperationQueue D、使用@thread 正确答案：B C 2、表视图的相关类有哪些?UITableView UITableViewController UITableViewDelegate UITableViewDataSource 正确答案: A B 错误答案解析：C.UITableViewDelegate是代理协议D.UITableViewDataSource是数据源协议 3、iOS中导航设计模式有几种？平铺导航、 标签导航、 树形导航、 模态视图导航 正确答案: A B C， 平铺导航( UITabbarController ) 标签导航( UINavigationController ) 树形导航(UIPageViewController) 4、为什么说Object-C是runtime language?将数据类型的确定由编译时，推迟到了运行时运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。假使A继承了B类，那么在编译时就已经生成了A的实例多态是指不同对象以自己的方式响应相同的消息的能力 ABD 简答题一、用Object-C定义并实现一个基于数组的循环队列类，当队列放满需支持动态的扩展队列长度。定义一个结构体，以及int变量front，rear用于跟踪数据填充情况。 1.当队列rear+1对数组长度取余等于front时，说明数组已填充满，那么需要扩展，即重新new 数组，长度为原来2倍，然后将原来数据copy新数组中，同时回收旧的数组 2.当rear==front时为空 注：使用rear+1前提是front指定的空间不存放值，这样就可知front==rear时时队列为空，而避免混淆队列是空还是满。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试题 - 前端]]></title>
    <url>%2F2018%2F09%2F05%2FiOS%E5%9F%BA%E7%A1%80%2F%E7%AC%94%E8%AF%95%E9%A2%98%20-%20%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[1、正则表达式 /a+(bab)?(caac)*/ ，下列选项中是该正则表达式的子集是？ ：C 第一步：理解题目。 题目中的 a+ 代表 字符“a” 出现1次或者若干次，(bab)? 代表 字符 “bab” 出现一次或者0次，(caac)* 表示重复了“0或者若干次”的字符“caac”，即 字符“caac”出现0次或者若干次 。 若改题目为/李+太?白*/,可匹配：李、李太、李白、李太白、李李、李李太、李李白白、李李太白白等。 第二步：理解选项，选出子集。 A /(bab)(caca)/ ：匹配含有 “babcaca” 的字符串，不是题目中的 “babcaac”, 就好比是在找 “太星” 而不是”太白”，而且没有a，所以该正则匹配的结果不可能出现在题目匹配的结果中，错误。 B /a(bab){2}(caac)*/ ：其中(bab){2} 表示 字符串“bab”必须出现2次，与题干正则显然不同，错误。 C /a{2}/ ：其中(a){2} 表示 字符“a”必须出现2次，就好比 “李李” ，属于题目匹配结果的子集，正确。 D /a+(bab){0,1}(ca)+(ca)/ ：前半部分正确，后半部分(ca)+(ca)明显错误。 E /a(^bab)+(caac){1,}/：正则本身有误，(^bab)匹配以”bab”开头的字符串，但前面还有a,也就是匹配以a开头的字符串，两者矛盾。 F /a+(babc){2,}(acc){1,}/：分组和区间值都不正确。 2、目前 HTTP2 协议已经逐渐普及到日常服务器中，以下对于 HTTP2 协议描述正确的是：ABCDhttp2的新特性：多路复用 二进制分帧 首部压缩（Header Compression） 服务端推送（Server Push） 所有http请求都建立在一个TCP请求上，实现多路复用 可以给请求添加优先级 服务器主动推送 server push HTTP2的头部会减小，从而减少流量传输 3、请问下面哪种方式可以在不改变原来数组的情况下，拷贝出数组 b ，且满足 b!=a 。例如数组 a 为 [1,2,3] 。 ：BD let b=a; let b=a.slice(); let b=a.splice(0,0); let b=a.concat(); A选项 b=[1,2,3] b==a B选项 b=[1,2,3] b!=a C选项 b=[] b!=a D选项 b=[1,2,3] b!=a]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C学习]]></title>
    <url>%2F2018%2F09%2F05%2FiOS%E5%9F%BA%E7%A1%80%2FObjective-C%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[APP启动 冷启动： 热启动：]]></content>
      <categories>
        <category>iOS课程</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 散列表]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%202%20%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[来源来源于数组支持按下表访问的特性，是数组的拓展。 构造：首先根据数据确定哈希函数，接着选择冲突解决方法，最后构造散列表，再写上需要的增加、查找、删除的方法。 插入：根据key键值，经过哈希函数，得到哈希值，插入表中。 查找：根据key值查找。 三个问题：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。 设计散列函数定义key值通过哈希函数之后，数据散列到列表中。 4个要求 哈希之后，值为大于0的整数，对应到数组的下标 同一个key的哈希结果相同 哈希之后的值均匀分布 哈希方法不能太复杂 根据装载因子动态扩容 rehash原因装载因子——给定一个能存放n个元素的、具有m个槽位的散列表T： 定义T的装载因子：α = n / m 对于动态的数据集，一开始无法知道其大小，其频繁的插入和删除，可能导致装载因子过大或者过小。此时我们需要动态扩容。 方式 一次扩容 插入数据的时间复杂度O(1)，但是某次达到装载因子阈值的插入时需要重新对原来数据进行hash操作，再放入新元素。非常耗时，需要优化放入分批扩容。 分批扩容 对于插入：获取一个新的2倍大小的哈希表，将新元素哈希之后插入，同时选择原哈希表中的一个数据插入新表，直至原哈希表为空。 对于查找：现在新表中查询，再查找旧表。 选择冲突解决的办法定义不同的key值散列之后，有可能获得同样的值，发生散列冲突 2个方法 空间寻值法：1 种类： 线性寻址：index + i 平方寻址：index + i^2 二次哈希：经过两次哈希函数得到的值 2 对应方法 增加：冲突后，往后找寻空位置放置元素 查找：哈希之后的值不是要找寻的元素时，往后面继续寻找。找到返回true；若找到空，则说明不存在该元素。 删除：注意。删除后标记delete，而不知直接删除。否则查找方式受影响。 3 缺点 装载因子不能过大，因此要求的空位要足够，需要较大的内存 会发生一次集群、二次集群，经过哈希之后的值都分布在某一段，插入和查找的时间成本变多 链接法 方法：将冲突元素装在以h(k)开头的链表 查找时间：为Θ(1 + α)，查找操作最坏情况下，需要常数时间。 优点：装载因子可以较大，要求的内存少 优化：如果链表中元素较多的时候，我们可以使用改造为其他高效的动态数据结构（树等），及时最极端情况下也只是退化为一棵树，查找时间还是0(log n)。 例子工业散列表：Java 中的 HashMap1 初始大小：默认16，预先知道数据大小可以设计出适合大小避免rehash 2 装载因子和动态扩容：0.75，自动扩容为2倍 3 散列冲突：链接法。jdk1.8版本中，优化链表，如果链表&gt;8，则转化为红黑树，查找更快；&lt;8时，变为链表，因为树结构平衡维护。 word的拼写检查1 数据存储的数据结构：50w个英文单词不超多10M，存储于哈希表中。 2 单词比对：对于每次输入的单词，作为key值，hash之后，查找哈希表，若查找不到，则标注拼写错误。 总结当数据量比较小、装载因子小的时候，适合采用开放寻寻址法。 数据量大，空间不足，使用链表法。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 散列表]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%203%20%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树为什么需要二叉树？线性表查询快 链表（双向）插入删除快 哈希表结合两者优点，但是构建需要考虑的多 二叉树结合三者优点，且更符合人类认知+可以映射现实的结构 树存储：一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法 链式存储法：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点 顺序存储法：完全二叉树适合，不浪费空间，堆其实就是一种完全二叉树。 高度、深度、层数：“高度”这个概念，其实就是从下往上度量，3-0 “深度”这个概念在生活中是从上往下度量的，0-3 “层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点从1开始。 二叉树遍历 前序遍历：打印顺序为本节点、左节点、右节点 中序遍历：打印顺序为左节点、本节点、右节点 后序遍历：打印顺序为左节点、右节点、本节点 时间复杂度是 O(n)。 123456789101112131415161718192021222324252627282930前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r// 真实代码void preOrder(Node* root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印 root 节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;void inOrder(Node* root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印 root 节点 inOrder(root-&gt;right);&#125;void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印 root 节点&#125; 按层遍历：使用队列。 根节点入队列，此时队列不为空。取出队列第一个元素打印出来，若其左节点存在就存入队列，否组什么也不做，右节点同理。 直至队列为空，表示数的层次遍历结束，层次遍历也是一个广度优先遍历算法。 翻转二叉树12345678def inverttree(self, treenode): #真正的翻转只有这8行代码 if treenode == None: return None temp = treenode.lchild treenode.lchild = treenode.rchild treenode.rchild = temp self.inverttree(treenode.lchild) self.inverttree(treenode.rchild) 二叉查找树支持：快速插入、删除、查找一个数据 要求：树中的任意一个节点，其左子树中的每个节点值都小于该节点，有字数节点值大于该节点。 查找、插入和删除首先取根节点，两者相等则返回，数小于该节点则在其左子树中递归；大于则在右边递归查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 节点类class static class Node&#123; private int data； private Node left; private Node right; // 初始化方法 public Node(int data)&#123; this.data = data; &#125;&#125;// 二叉树类public class binarySeachTree&#123; // 声明一棵树，根节点为 tree private Node tree; // 1.查找函数 public Node find(int data)&#123; //复制 Node p = tree; // 不为空则继续查找 while(data != null)&#123; // 是否相等 if(data &lt; p.data) p = p.left else if(data &gt; p.data) p = p.right else return p； &#125; // 为空返回空，表示没找到 return null; &#125; // 2.插入函数 public void insert(int data)&#123; // 若根节点为空,根节点为该数据，实例化 if (tree == null)&#123; tree = new Node(data) return; &#125; Node p = tree; // 若不为空 while(p != null)&#123; // 小于，查看节点左边是否有节点，没有就实例化，有就继续判断下一个 if(data &lt; p.data) &#123; if(p.left = null)&#123; p.left = new Node(data) &#125; p = p.left; &#125;else if(data &gt; p.data)&#123; if(p.right == null)&#123; p.right = new Node(data) &#125; p = p.right; &#125; &#125; &#125; public class Question_39 &#123; //----递归求二叉树深度---- public static int treeDepth(BinaryTreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = treeDepth(root.left); int right = treeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125; &#125; 其他操作：最大最小、前驱后继节点中序遍历（左中右）二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效率。 因此，二叉查找树也叫作二叉排序树。 支持重复数据的二叉查找树方式一：一个节点不仅存储数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据存储于一个节点上。 方式二：更优雅。相等的时候看做大于该值。 二叉查找树的时间复杂度分析最差情况：二叉查找树，根节点的左右子树极度不平衡，已经退化成链表。O(n)。 时间复杂度其实都跟树的高度成正比，也就是 O(height)。 两个极端情况的时间复杂度分别是 O(n) 和 O(logn)。 而对于完全二叉树： 问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？ 完全二叉树的层数小于等于 log n +1，也就是说，完全二叉树的高度小于等于 （log n）。 平衡二叉树是 O(logn)。 散列表和二叉查找树比较排序：散列表无序排序，输出有序数据前需要排序；二叉查找树有序，中序遍历可以在时间复杂度O(n)中，输出有序序列。 稳定性：散列表扩容耗时多、散列冲突的时候性能不稳定；平衡二叉查找树较稳定，时间稳定在 O(logn)。 构造复杂：散列表更加复杂，需要考虑散列函数、负载因子动态扩容、冲突解决。平衡二叉树只需要考虑平衡性。 空间：对于散列表的开放寻址法，装载因子不能太大，需要更多的空间。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 散列表]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%203%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%A9%E5%B1%95%20%2F</url>
    <content type="text"><![CDATA[其他二叉树平衡二叉树-AVL 树(没有很严格)平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树： 它的左子树和右子树都是平衡二叉树， 左子树和右子树的深度之差的绝对值不超过1。 平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。 ### 红黑树红黑树的五个基本原则： 首先它一颗平衡树，每个节点是红色或黑色的。 根节点是黑色的。 每个叶节点（null）是黑色的。 如果一个节点是红色的，则它的两个子节点是黑色的。 对每个节点，从该节点到其所有后代叶节点上的简单路径，包含相同数目的黑色节点。 比较重要的是第4点和第5点，因为它可以保证我们树的最长路径不超过最短路径的两倍。也就是说一个n个节点的红黑树，它的高度至多为2lg（n+1），虽然不是严格平衡，但至少查找的效率还是可以接受的。 红黑树在高度方面不像AVL有个左右子树高度差不超过1的限制，同时红黑树的维护效率比AVL高很多。红黑树需要旋转的次数较少。 Java中的map就是通过红黑树来实现的。 Question：动态数据结构支持动态地数据插入、删除、查找操作，除了红黑树，还有哪些？比较优劣和场景。 动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。 而且，这些操作都非常高效动态数据结构有链表，栈，队列，哈希表等等。 链表适合遍历的场景，插入和删除操作方便； 栈和队列可以算一种特殊的链表，分别适用先进后出和先进先出的场景。 哈希表适合插入和删除比较少（尽量少的扩容和缩容），查找比较多的时候。 红黑树对数据要求有序，对数据增删查都有一定要求的时候。 B树（平衡多路查找树）B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构; （1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则； B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理，把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度; 目的：使树的层级减少达到快速查找数据的目的。 适合：外部存储。磁盘。 ##B+树 B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。 特点 1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快； 2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; 3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。 哈弗曼树 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 构造： 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为： 将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)； 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 从森林中删除选取的两棵树，并将新树加入森林； 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 5 任务清单APP]]></title>
    <url>%2F2018%2F03%2F08%2FiOS%E5%9F%BA%E7%A1%80%2FObject-C%E5%BC%80%E5%8F%91%20-%20%201%20APP%2F</url>
    <content type="text"><![CDATA[学习建议源码和资源链接:http://a.ixuea.com/zl 密码: JnPM 这是学习建议：推荐对着视频敲一遍代码（如果没有足够的时间可以先看一遍视频，不敲代码，这样对课程讲的内容有一个大概了解，后面工作中遇到了问题才知道去哪一节找），后面遇到问题了可以直接先看电子书看是否能理解，如果不能理解再找到相应的视频学习，工作中可以直接打开电子书对应的章节复用相应的代码。 http://www.ixuea.com/books/16 需求分析TableViewController 增加任务 删除任务 修改任务 需求遇到的困难知识点 项目布局UI设计页面一页面二源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>object-c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化 - 可视化基础]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%20-%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[有些人认为可视化只是把计算分析的结果图形化。 实则不然，可视化是人类认识、分析复杂数据的重要途径。 数据可视分析数据可视化的挑战计算能力有限、感知和认知的局限、显示能力的局限 大数据可视化以人为中心的探索式可视分析(关注)可视化框架可视化循环模型 可视分析流程数据转化、可视映射、视图转化 原数据-&gt;转化后的数据-&gt;可视结构-&gt;视图 如：我们选择线性投影将30维的原数据降为5维度的转化数据，再使用平行坐标视觉映射转为可视结构，然而数据有相互遮挡，则选择PCP方法视图转化至视图上。最后呈现热力图式的平行坐标。 基本图表原始数据数据轨迹、柱状图（x轴为类别型，主要用于统计值）、直方图（x轴为数据型，主要用于频率）、饼图(比例)、散点图与散点图矩阵(属性对的关系、热力图(颜色编码二维数据值的大小) 统计值标绘制盒须图，上面最大值、下面最小值、盒子表示数据大致范围25-75% 多视图协调关联选择后高亮 交互技术选择 selection数据过多视觉混乱：堆叠区域和对象放大选择后展示提示信息：字符串在有限空间排列，不选择的时候隐藏，选择后展开 导航 navigation人眼观察到区域可见空间有限缩放平移旋转 重配 reconfigure提供观察数据的不同视角重组视图重排列 编码 encode颜色编码、大小、方向、字体、性状 抽象 abstraction不同等级的信息，交互控制获得更多或更少的细节 过滤 filter设置约束条件进行信息查询eg.选定价格房型，地图上出现复合房子动态过滤：滑动框、按钮、组合框，过滤条件之间不相关 关联 connection高亮显示对象之间关系链接与刷动 刷选对象，其余都可高亮 概览+细节 overview+details谷歌地图右下角全局，主页面当前区域 焦点+上下文 focus+context高维数据可视化高维多元数据——独立属性、相关数据 可视分析——维度太高，难以提取可理解的维度关联信息。高于10维的数据 空间映射法散点图与散点图矩阵平行坐标降维(重要)线性方法和非线性方法，将高维数据投影project或嵌入embed至低维空间(通常为2、3维)，并尽量在低维空间保持多元空间中的关系和特征。 最后展示的方法一般为散点图。 主元分析 PCA(无监督)减少维度，保持数据集方差贡献最大的特征。（在低维空间找一个观察角度，以便最大限度观察多维数据的差异。） 第一个新坐标轴选择的是原始数据中方差最大的方向，第二个新坐标轴选择的是与第一个新坐标轴正交且方差次大的方向。 通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值及特征向量，选择特征值最大（也即包含方差最大）的N个特征所对应的特征向量组成的矩阵，我们就可以将数据矩阵转换到新的空间当中，实现数据特征的降维（N维）。 123456去除平均值计算协方差矩阵计算协方差矩阵的特征值和特征向量将特征值排序保留前N个最大的特征值对应的特征向量将数据转换到上面得到的N个特征向量构建的新空间中（实现了特征压缩） 线性判别分析 LDA(有监督)也叫Fisher线性判别。 抽取分类信息和压缩特征空间维数，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离，即模式在该空间中有最佳的可分离性。 优化目标J最大，获得最优投影向量w：使用矩阵分解，得到特征值最大的特征矩阵的第一行。 多维尺度分析 MDS multimensioanal scaling### 图标星状图 基于像素的可视化方法]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 二分查找]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[针对有序数据集合的查找算法 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 该功能不要占用太多的内存空间，最多不要超过 100MB。 二分思想O(logn) 惊人的查找速度 二分查找的递归与非递归实现最简单的情况就是有序数组中不存在重复元素。 循环条件：low&lt;=high mid取值： low 和 high 比较大的话，mid=(low+high)/2和可能会溢出。 改进方式1为，mid=low+(high-low)/2 改进方式2为，除以 2 操作转化成位运算 mid = low+((high-low)&gt;&gt;1) low和high更新 low=mid+1，high=mid-1 1234567891011121314151617181920212223242526272829303132333435# 循环二分查找def search(arr, n, value): low = 0 high = n - 1 while low &lt;= high: mid = int((high + low) / 2) if arr[mid] == value: return mid elif arr[mid] &lt; value: low = mid + 1 else: high = mid - 1 return -1# 递归二分查找def Binarysearch(arr, low, high, value): if low &gt; high: return -1 # 位操作，防止溢出 mid = low + ((high - low) &gt;&gt; 1) if arr[mid] == value: return mid elif arr[mid] &lt; value: return Binarysearch(arr, mid + 1, high, value) else: return Binarysearch(arr, low, mid - 1, value)a = [1, 2, 3, 4, 6, 8, 9]n = len(a)value = 1print(search(a, n, value))print(Binarysearch(a, 0, n - 1, value))]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 2 链表]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%202%20%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LRU 缓存淘汰策略内存管理的一种页面置换算法。LRU全称是Least Recently Used,即最近最久未使用的意思，最久未使用的数据，下次被访问的可能最小，我们需要删除它。 链表实现维护一个有序单链表，靠近尾部是最早访问，头部为最新访问。当有新数据被访问，我们从头开始遍历链表： 若此数据之前已有，从原来的位置删除，再将数据放在头结点； 若之前没有：缓存未满，直接放在头部；缓存已满，删除尾部数据，将其放在头部。 时间复杂度：时间复杂度为 O(n)，需要遍历。 LRU缓存淘汰算法 散列表实现1.上面所讲的几个散列表和链表组合的例子里，我们都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？2.假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作：1）根据猎头ID查收查找、删除、更新这个猎头的积分信息；2）查找积分在某个区间的猎头ID列表；3）查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。 以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。 1）ID 在散列表中所以可以 O(1) 查找到这个猎头；2）积分以跳表存储，跳表支持区间查询；3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 数组]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%202%20%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[08 | 栈：如何实现浏览器的前进和后退功能？ abc顺序浏览页面，回退返回a页面，前进返回b页面。 若此时在进入新的页面d，则无法再回到页面c，需要清空第二个栈。 ps.内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 09 | 队列：队列在线程池等有限资源池中的应用线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？ 第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学术]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%AD%98%E6%A1%A3%2F%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[自由探索项目——面向分类的感知驱动的可视化监督降维方法成绩：自由探索项目，预计4月-5月投稿。（负责人） 目标：分类数据的分析。 方法：本文提出了一种感知驱动的线性降维方法，寻求生成具有最大视觉分离程度、最少数量的最优二维投影集合。 （1）子空间表达：对于类别两两之间利用分离度量求最优分离向量，然后在各个维度上找出在这个度量上能够达到分离度量阈值的范围，各个维度上的范围构成了一个包围盒。 （2）子空间求交：包围盒如果有交集，则代表它们之间可以用一条向量进行区分。 我们将包围盒看做点，两个包围盒有交，则在对应的点之间连边，若存在一个完全图，则代表这些包围盒所代表的点对都可以用一条向量进行区分，用最少数量的团对这张图进行覆盖，这些团就对应了最少数量的包围盒集合。 （3）组合优化：我们取包围盒的中心所对应的向量作为投影的坐标轴，将坐标轴进行组合，得到最少数量的投影集合。 困难1：一开始构建单个视图，发现类别多的时候无法构建 目标函数：为了最大化非线性目标函数dDSC。优化方法：使用模拟退火算法，通过比较随机生成的投影结果的costFuction，找出全局最优值。得到最优的投影结果展示分类数据。 发现：真实数据中可能存在很多类，如骑车包括： 困难2： 方式2：几何的方式优化 方法：要得到一个最优的向量w，步骤如下： 1）得到使方差很小的Pa、Pb两个子空间基本功能已经完成。 矩阵分解得到将得到两个特征矩阵Pa、Pb（n*k），其k个特征向量均为正交矩阵，则该矩阵为正交矩阵。 2）Pa、Pb两个子空间求交基本功能已经完成。 解线性方程组得到基础解系{x,y}，Ax为基向量，再将Ax化为模等于1的单位向量。 得到验证结果，类别A的数据在本空间Va的标准差和在交空间的方差标准差数值接近。 类别A的data在Va、Vb、AB交空间vec的方差：0.0088525953414772470.0114245457684850630.00896923772901887类别A的data在Va、Vb、AB交空间vec的标准差：0.095043466648306780.10797082829987120.09566756711110631 数据A投影到Va、Vab中的结果如下： 3）最大化两个类别中心点的距离的特征向量distVec由于方式2为几何的方法，我们得到的该特征项就是两个类别中心的连线 v_{dist} = u_a-u_b 这一步很简单，直接可以得到的为：n*1的特征向量 v_dist A、B可视化为图中绿色点，中心点为红色点、distVec则为蓝色线段的方向，我们将其化作单位向量如橙色线段。 4）将2）中的交空间和3）中的子空间（向量）组合，得到最终的子空间范围 V方式1：直接看做两个子空间求交 对于该方式，大概率会求出空集。 方式2：线性组合。 这里提出enegeFuction = distAB- Sa-Sb(A、B的方差) 最大化enegeFuction，得到参数k。 得到newV= {vec+k1α1，vec+k2α2，…，vec+knαn} 纯代数无法得到结果。 D3是Data-Driven Document的缩写，从字面上理解就是数据驱动文本高维数据中的低维结构的可视探索成绩：并推荐可视化顶级刊 TVCG。非学生一作 问题：高维数据集中往往含有不同结构的低维结构，当未知数据集中的低维结构与当前的可视化方法的假设不匹配时，可视化结果将难以理解。解决：可视分析方法帮助用户有效地识别低维结构及关键特征，为进一步分析提供关键结构信息。方法：t-SNE初步提供初始聚类信息，局部切空间-测地距离视图用来发现子空间，2个滚石图拐点为子空间维度， 高维多元数据——独立属性、相关数据 可视分析——维度太高，难以提取可理解的维度关联信息 高维数据低维结构 P1——二维S1、一维S2、S3 P2—— 一、选题意义和研究价值 分析高维数据集的许多方法都假设数据集包含特定结构，例如聚类位于线性子空间中或位于非线性流形上。这需要反复的实验去验证适当的模型和参数。本文提出了一个探索性的界面，支持识别高维数据集中的低维结构，并有助于选择最优的数据模型和参数配置。我们的关键思想是从潜在的低维结构的邻居图表示中提取一组全局和局部特征描述符，例如点间的测地距离(GD)以及点的局部切空间(LTS)中点间的局部切空间散度(LTSD)。我们提出了一个新的LTSD-GD视图，它通过多维标度分析方法(MDS[6])分别将LTSD和GD映射到x轴和y轴。与保留点之间各种距离的传统降维方法不同，LTSD-GD视图展示了点LTS(x轴)的分布和结构中LTS的变化(x轴和y轴的组合)。我们设计并且实现了一系列可视化工具，用于探索高维数据中的内在结构 二、国内外研究现状和发展动态 2.1可视化高维数据 高维数据可视化引起了广泛关注[18]。包括平行坐标图[14]，散点图矩阵和雷达图[11]等的常规可视化技术被设计去呈现数据的统计，例如维度中的数据分布或两个维度之间的相关性。然而，这些方法基本不可能去揭示潜在的聚类模式和潜在的特征。 基于DR的投影方法是可视化方法中的重要组成部分。通常，将点投影到二维或三维空间，并且同时保留一定的结构。广泛使用的PCA方法尽力去保留数据的方差。经典的多维标度分析(MDS)[6]，在投影过程中保留了高维空间中数据间的欧几里德距离。这些方法假定点位于单个的低维线性子空间中。如果当点位于非线性流形中，同样也已经提出了几种流形学习方法来检测潜在流形，例如ISOMAP[34]，LLE[24]，LE[4]和LTSA[44]。然而，基于DR的投影结果可能难以理解和解释[31]。首先，这些点被盲目地减少到二维或三维空间，由于维度的限制，这些空间可能不能准确地捕捉到数据间的内在结构[13]。第二，分析者可能缺乏DR方法与内在结构之间是否合适的相关知识[13]。分析者可能对DR模型的理解有限，或者在初始阶段对数据的了解有限。 在现实世界的高维数据集中，数据点通常位于多个子空间或多个流形中。子空间聚类[40]和流形聚类[8]方法被设计用于检测潜在的多个低维结构。通常的策略是首先采用DR模型，然后有序地可视化检测到的低维结构。VISA[2]系统根据全局视图中的聚类和维度的大小提出了聚类之间的相似性。它还在详细视图中显示了各个聚类的属性。Tatu等人[33]开发了一个可视化界面来探索SURFIN[3]发现的大量子空间。基于相似度函数来探索子空间，其重点在于子空间之间的拓扑和维度重叠。Liu等[19]用谱法提取子空间，并将子空间用可视化技术呈现出来。然而，子空间聚类和流形聚类模型通常强烈依赖于本质结构的假设，例如聚类的数量[7]，聚类的维度[36]和结构之间的是否相交。在不了解本质结构的情况下，很难选择合适的模型。 在这些可视化方法中，t-SNE[39]对内在结构做了一个温和的假设。在低维嵌入中，它保留了对不同结构(如多个流形)的k-Nearest-Neighbors(kNN)图的统计数据。t-SNE不仅保留了局部结构而且还显示了全局信息[22]，因此我们将其作为高维数据集中内在结构的初始指标之一，并在可视化探索过程中优化它。为了计算效率，在t-SNE中可以采用层次化策略[21]。 2.2 探索高维数据 探索高维数据比自动模型更需要含有交互功能的预处理工具[42]。传统的方法，如平行坐标图，散点图矩阵[12]和各种投影[25]已经得到了很好的研究。 通常，分析者需要在探索期间以交互方式产生许多视图。为减轻手工负担，Voyager[41]提出自动生成可视化的建议。接下来，出现了大量关于质量测量[5,32]和排名[29]的可视化文献。DimScanner[42]提出构建可视化来发现不同视图之间的信息感知关系。Sarvghad等[27]可视化了维度覆盖以记录探索的历史。为了探索显著的子空间，Yuan等[43]提出了一个矩阵/树结构，以便在探索过程中组织数据和维度的子集。 为了增强发现潜在结构的能力，自动化的DR模型被集成到探索界面中。因为数据的潜在结构往往是未知的，所以这些方法利用混合模型[23]来匹配潜在的结构。DimStiller[13]提出了用于维度分析和减少组合的自动化DR模型的工作流程。通常，只能选择比较容易理解的模型，如PCA和MDS。当处理包含多个低维结构的数据时，这些模型和工作流程产生可解释的结果是基本不可能的。在本文中，我们试图在构建具体模型之前对其内在结构和特征进行表征。结构的特征和可视化揭示了潜在的低维结构。 三、主要研究思路、研究内容和在学术方面的创新点 3.1 低维结构的表示 我们将子空间定义为一个聚类低维表示的基础[40]。给定一组线性或仿射子空间的点，子空间可以通过奇异值分解(SVD)或主成分分析(PCA)来计算得出。还有一点需要注意的是数据可以是轴对齐的，也可以是非轴对齐的。 在一般情况下，点大多位于非线性流形上。我们可以把流形认为是一个“软”和“弯曲”的子空间。d维流形的每一个点都有一个与d维的欧几里得空间同胚的小邻域，在一个流形中，点的局部子空间的方向是逐渐变化的。另一方面，子空间是流形的一般情况。对于位于相同子空间中的聚类，点的局部子空间的方向是相同的。 受流形学习方法的启发，我们建立了一个邻居图，一个kNN图，用来表示位于潜在流形或子空间中的聚类。这个表示是基于一个局部假设[16]，即每个点都有一个小的邻域，在这个邻域里，每个点都属于同一流形，近似地位于一个低维的仿射子空间中。这意味着即使在全维空间中，每个点的局部子空间也可以从局部领域中获取。给定一个不熟悉的数据集，分析者总是可以从一个统一的表示开始。 在本文中，我们使用Shared-Nearest-Neighbor (SNN)图[9]，它是一个kNN图的子图，用来表示本质结构。在SNN图中，当且仅当p和q位于彼此的kNN邻域时，两者之间才存在一条边。SNN图形倾向于生成多个分区，这非常适合用于呈现聚类特征。 三、4.5.1 kNN Graph与SNN Graph 首先我们构建出Shared-NearNeighbors(SNN) Graph，来表示高维数据的内蕴结构。SNN Graph是kNN Graph的子图，他要求两点互为k近邻时，两点之间才存在边；数据存在异常值时，与其他部分相互分隔开。与kNN Graph相比，SNN Graph中心和边界的数据分布得到了增强。接着，我们用节点链接布局SNN Graph。本文提供了两种方式来交互地从SNN Graph中提取内蕴轴：点选和自由绘制曲线。 4.5.2 点选 用户可以选择一系列数据点来解释他的点选的趋势。我们根据用户点选的顺序，通过Dijkstra算法得到最短路径，并连接数据点，得到原始路径。当所选点的数量超过两个时，构建的原始路径中可能存在回路。当原始路径中存在回路时，算法将会移除该回路，如图4-5-2。如果在点选列表中相继的两个点处于两个不相连接的图中部分，我们将会寻找两部分中最近的两个点，并添加一条边来连接两个部分。 随着选定点的增加，解释知识从宽泛到细致。因此，路径中的回路反映了人类知识的不确定性。视觉特征，如聚类，路径趋势和异常值，往往可以作为用户交互的感知线索。 图4-5-2 从原始路径中移除回路（a）点选两点的最短路径（b）选择多个点时，路径不确定性增加（c）原始路径存在回路（d）从路径中移除回路]]></content>
      <categories>
        <category>学术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 数组]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%205%20%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[有向图 带权图 邻接矩阵存储方法存储费空间，使用方便 领结表存储方法节省空间、使用耗时 如何存储微博、微信等社交网络中的好友关系？判断用户A是否关注用户B 判断用户A是否是用户B的粉丝 邻接表 逆邻接表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 0 排序]]></title>
    <url>%2F2018%2F01%2F05%2F%E2%9D%A4%EF%B8%8F%E7%AE%97%E6%B3%95%20-%200%20%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)排序算法 3 冒泡排序 插入排序 选择排序 选择排序不稳定，相同元素可能会变化，因此这三种不选择选择排序。 代码中，把执行一个赋值语句的时间粗略地计为单位时间。冒泡排序需要 3 个赋值操作temp存储临时变量，而插入排序只需要 1 个 a[j]=a[j+1]移动数据。时间比值：1：7。 最优方法：插入排序。 O(nlogn) 排序算法 3归并排序 方法：利用了分治思想，用递归代码来实现归并排序。先分，再合。 时间复杂度： T(n)=Cn+nlog2n。非常稳定，所有情况都是O(nlogn)。 空间复杂度：不是原地排序算法，每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时空间释放。 O(n)。 处理过程：是由下到上的，先处理子问题，然后再合并。 快速排序方法：利用主元分区，每次分为左边小区，右边大区。直至区内只有一个元素之后，排序完成。 时间复杂度：分区每次右边都没有元素。就从 O(nlogn) 退化成了 O(n2)。 处理过程：是由上到下的，先分区，然后再处理子问题。 堆排序10 亿个搜索关键词的日志文件，Top 10 最热门的搜索关键词用户搜索的关键词，有很多可能都是重复的，散列表先记录次数。 用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出次数，若次数多&gt;顶堆，则删除顶堆。遍历完成后得到top10。 然而10亿太大了。 哈希之后，将 10 亿条搜索关键词先通过哈希算法分到10个文件。在进行上述步骤，然后得到10x10个关键字。租后排序得到top10。 问题10 个接口访问日志文件，每个日志文件大小约 300MB，日志都是按照时间戳从小到大排序的 将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后也是从小到大排序。 机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这10 个日志文件合并吗？ 每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。 线性排序 3桶排序（Bucket sort）要求： 容易划分为m个桶，且天然有序 分布均匀，若分布不均匀全在一个桶里会退化为log（n/m log(n/m)) = log(n logn) 外部排序。数据大，内存有限，无法将数据全部加载到内存，存放于外部磁盘中。 10GB数据，如何按照订单金额排序？ 扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 1… 将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内，第二个1001-2000，类推。每个桶按照范围命名。 理想状态均匀分布，则划分为100个100M文件。按文件编号，依次将文件放入内存快排，在写入同一个文件。 若部分文件很大，无法写入内存，继续划分，直到对所有文件都可读入内存为止，再依次快排。 计数排序（Counting sort）要求： 数据量大，数据区间小 非负整数。若为不符合该条件，则转化即可。 如何根据年龄给 100 万用户排序？年龄的范围最小 1 岁，最大不超过 120 岁； 遍历这 100 万用户，根据年龄将其划分到这 120 个桶里； 依次顺序遍历这 120 个桶中的元素。 高考查分系统，省内50万名考生，分数范围为900-0。数据范围小，我们划分为901个桶，桶内为分数相同的学生。 此时不需要在排序，而是只需要依次输出到数组即可，只需一次扫描操作，时间复杂度O(n)。 ps. 若考生分数有小数点后一位，则需要所有分数乘10，转为整数，再放进9010个桶内。 基数排序（Radix sort）要求： 数据可以分割出独立的“位”来比较，位之间有递进的关系（高位优先） 每一位的数据范围不能太大，要可以用线性排序算法来排序 10万个11位电话号码排序（等长） 规律：比较两个号码a、b，若前几位a已经大于b，则后面不用看。 方法：先按照最后一位排序，再按照倒数第二位，以此类推。最后按照第一位来排序。11排序之后，手机号码有序。 时间复杂度：按照每一位排序，数字只有0-10，可以使用桶排序，时间复杂度可以做到 O(n)。排序的数据有 k 位，时间为O(k*n)。k不大的时候，近似为O(n)。 排序牛津字典中的20 万个英文单词（非等长1-45） 解决非等长：把所有的单词补齐到相同长度，位数不够的可以在后面补“0”。根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响排序。 接着使用基数排序]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 1 基础语法]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FJavaScript%20-%201%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%20%2F</url>
    <content type="text"><![CDATA[第一章 入门本章节主要讲解如何在HTML文件中添加JavaScript代码，掌握必备的基础语法，为以后来章学习打下基础。 第二章 请和我互动本章节主要讲解如何向网页中输入内容，如何与浏览器窗口进行交互，通过简单的对象方法就可以轻松实现。 JavaScript-警告（alert 消息对话框）12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;alert&lt;/title&gt; &lt;script type="text/javascript"&gt; function rec()&#123; var mychar="I love JavaScript"; alert(mychar); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input name="button" type="button" onClick="rec()" value="点击我，弹出对话框" /&gt;&lt;/body&gt;&lt;/html&gt; JavaScript-确认（confirm 消息对话框）confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。 1234567891011function rec()&#123; var mymessage= confirm("你是女士吗？"); if(mymessage==true) &#123; document.write("你是女士!"); &#125; else &#123; document.write("你是男士!"); &#125; &#125; JavaScript-提问（prompt 消息对话框）12345678910111213141516 function rec()&#123;var score; //score变量，用来存储用户输入的成绩值。score = prompt("同学输入成绩",null) ;if(score&gt;=90)&#123; document.write("你很棒!");&#125;else if(score&gt;=70) &#123; document.write("不错吆!");&#125; else&#123; document.write("要努力了!");&#125; &#125; JavaScript-打开新窗口（window.open）open() 方法可以查找一个已经存在或者新建的浏览器窗口。 1window.open([URL], [窗口名称], [参数字符串]) 123function Wopen()&#123; window.open('http://www.imooc.com','_blank','width=600,height=400,top=100,left=0')&#125; JavaScript-关闭窗口（window.close）用法： 1window.close(); //关闭本窗口 或 1&lt;窗口对象&gt;.close(); //关闭指定的窗口 例如:关闭新建的窗口。 1234&lt;script type="text/javascript"&gt; var mywin=window.open("http://www.imooc.com"); mywin.close()&lt;/script&gt; 综合练习1234567891011function openWindow()&#123; // 1.新窗口打开时弹出确认框，是否打开 var msg_confirm = confirm("是否打开窗口？") if(msg_confirm==true)&#123; // 2.通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/ var msg_url = "http://www.imooc.com/" var msg_prompt = prompt("输入网址",msg_url) //3.打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。 window.open(msg_url,"_blank",'width=400,height=500') &#125; &#125; 第3章 你也有控制权(DOM操作)如何用JavaScript去操作HTML元素和CSS样式，实现简单的动态操作。 认识DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 先来看看下面代码: HTML文档可以说由节点构成的集合，三种常见的DOM节点: 1. 元素节点：上图中、、等都是元素节点，即标签。 2. 文本节点:向用户展示的内容，如…中的JavaScript、DOM、CSS等文本。 3. 属性节点:元素属性，如标签的链接属性href=”http://www.imooc.com&quot;。 看下面代码: 1&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt; 通过ID获取元素学过HTML/CSS样式，都知道，网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。 语法: 1document.getElementById(“id”) 结果:null或[object HTMLParagraphElement] 注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。 innerHTML 属性：获取替换内容innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: 1Object.innerHTML 注意: 1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。 2.注意书写，innerHTML区分大小写。 我们通过id=”con”获取 元素，并将元素的内容输出和改变元素内容，代码和结果如下: 改变 HTML 样式HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？ 语法: 1Object.style.property=new style; 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 基本属性表（property）: 注意:该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。 显示和隐藏（display属性）网页中经常会看到显示和隐藏的效果，可通过display属性来设置。 语法： 1Object.style.display = value 注意:Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。 value取值: 看看下面代码: 控制类名（className 属性）className 属性设置或返回元素的class 属性。 语法： 1object.className = classname 作用: 获取元素的class 属性 为网页内的某个元素指定一个css样式来更改该元素的外观 看看下面代码，获得 元素的 class 属性和改变className： 12345678function add()&#123; var p1 = document.getElementById("p1"); p1.className = "one" &#125; function modify()&#123; var p2 = document.getElementById("p2"); p2.className = "two" &#125; 综合练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" Content="text/html; charset=utf-8" /&gt;&lt;title&gt;javascript&lt;/title&gt;&lt;style type="text/css"&gt;body&#123;font-size:12px;&#125;#txt&#123; height:400px; width:600px; border:#333 solid 1px; padding:5px;&#125;p&#123; line-height:18px; text-indent:2em;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 id="con"&gt;JavaScript课程&lt;/H2&gt; &lt;div id="txt"&gt; &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt; &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt; &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt; &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt; &lt;/div&gt; &lt;form&gt; &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt; &lt;input type="button" value="改变颜色" onClick = "colorChange()"&gt; &lt;input type="button" value="改变宽高" onClick="sizeChange()"&gt; &lt;input type="button" value="隐藏内容" onClick="hide()"&gt; &lt;input type="button" value="显示内容" onClick="display()"&gt; &lt;input type="button" value="取消设置" onClick="cancel()"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt;//定义"改变颜色"的函数 function colorChange()&#123; var obj = document.getElementById("txt"); obj.style.color = "red"; obj.style.backgroundColor = "gray"; &#125;//定义"改变宽高"的函数 function sizeChange()&#123; var obj = document.getElementById("txt"); obj.style.height = "300px"; obj.style.width = "300px"; &#125;//定义"隐藏内容"的函数 function hide()&#123; var obj = document.getElementById("txt"); obj.style.display = "none"; &#125;//定义"显示内容"的函数 function display()&#123; var obj = document.getElementById("txt"); obj.style.display = "block"; &#125;//定义"取消设置"的函数 function cancel()&#123; var message = confirm("是否还原？") if(message==true)&#123; txt.removeAttribute('style'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础 - 1 HTML]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%201%20HTML%2F</url>
    <content type="text"><![CDATA[第1章 Html介绍本章节主要讲解html和css样式的关系，以及html标签、html文件结构、head标签,最后讲解了在html中的注释代码的作用。 关系： 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的： HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 下面给大家布置一个任务，在完成任务的时候，每输入一行代码，代码窗口就会立即显示出效果。 第2章 你要懂的规则(JS基础语法)第3章 一起组团(数组)第4章 跟着我的节奏走(流程控制语句)第5章 小程序，大作用（函数）第6章 事件响应，让网页交互第7章 JavaScript内置对象第8章 浏览器对象第9章 DOM对象，控制HTML元素第10章 编程挑战###]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 1 基础语法]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FJavaScript%20-%202%20%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[原型链创建对象有几种方法123456789// 1.字面量对象方式var o1=&#123;name:'o1'&#125;;var 02=new Object&#123;name:'o2'&#125;;// 2.通过构造函数var M=function(name)&#123;this.name=name&#125;;var o3=new M('o3');// 3.Onject.createvar p=&#123;name:'p'&#125;;var o4=Object.create(p); 原型、构造函数、实例、原型链原型、构造函数、实例 1234567// M是构造函数，o3是 实例var M=function(name)&#123;this.name=name&#125;;var o3=new M('o3');M.prototype.constructor===M //trueo3.__proto__==M.prototype //trueM.__proto__==Fuction.prototype //true,M为Fuction构造函数的实例，原型对象相同 原型对象和原型链的作用原型对象作用：构造函数中增加了很多属性和方法，实例可以共用。多个实例的时候，想使用这个方法的时候，不能每个实例都取拷贝一份。可以考虑存在一个共同的地方——原型对象。 1234567// 原型链的方式找到原型对象，原型对象的方法是被不同的实例所共有的。var M=function(name)&#123;this.name=name&#125;;var o3=new M('o3');M.prototype.say=function()&#123; console.log('say hi');&#125;var o5=new M('o5'); 原型链的作用：实例调用方法时没有找到方法时，如则通过 proto 在上级对象去找，再没找到的时候，则继续找，直至Object.prototype根部。 instanceof的原理 判断实例对象的 proto 和生成其的构造函数的prototype是不是引用同一个地址。(ps.实例的instanceof在比较的时候，与原型链上想上找的构造函数相比都是true。) new运算符JavaScript作用域和闭包变量提升js会把所有的声明提到前面，然后再顺序执行赋值等其它操作，因为在打印a之前已经存在a这个变量了，只是没有赋值，所以会打印出undefined，为不是报错，fn同理。 作用域JavaScript是没有块级作用域的：if里的变量都可以访问 js有全局作用域和函数作用域：在函数里声明的变量，在是不会影响外面的变量的，看结果 作用域链：一个自由变量，js引擎在执行到console.log(x)时，会先在F2中寻找x，没找到就去当前作用域的父级作用域F1中找，还找不到就在往上找直到全局作用域。 闭包Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 其应用我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数,然后把这个函数返回。 在本例中就实现了闭包，简单的说，闭包就是能够读取其他函数内部变量的函数。 1234567891011function F1()&#123; var a = 100 //返回一个函数 (函数作为返回值) return function ()&#123; console.log(a) &#125;&#125;//f1得到一个函数var f1 = F1()var a = 200f1() JS-web-API6-5 Ajax跨域手写ajax：使用API——XMLHttpRequest()实现ajax 1234567891011var xhr = new XMLHttpRequest()xhr.open("GRT","/api",false)xhr.onreadystatechange = function()&#123; // 异步函数执行，可以参考JS基础中的异步模块 if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) 什么是跨域？浏览器的通远策略，不允许ajax访问其他域的接口。前端用JSONP，后端用http header。 跨域条件：协议、域名、端口，有一个不同就算跨域 三个标签允许跨域加载资源： 1图片：&lt; img src=xxx&gt; 、打点统计，统计网站可能是其他域：可以跨域；兼容多个浏览器 2CSS，外部样式表的位置: &lt; link href=xxx&gt;、3地址，引入外部js文件，外部脚本文件的 URL：&lt; script src=xxx&gt;：可以使用CDN，CDN也是其他域。 注意所有跨域请求都必须经过信息方允许；若未经允许即可获取，就是浏览器同源策略出现了问题。eg.知乎日报的API JSONP：简单非官方跨域数据交互协议原理：为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许。方法：可以通过动态创建script，再请求一个带参网址实现跨域通信。缺点：只能实现get一种请求 例如自己的网站需要访问一个慕课网的接口 慕课给我一个地址 https://coding.imooc.com/api.js 返回内容格式如callback({x:100,y:200}) 可动态生成： callback相当于执行的函数 函数的参数：为内容 123456&lt;script&gt; window.callback = function(data)&#123; console.log(data)//输出跨域的信息&#125;&lt;/script&gt;&lt;script src="https://coding.imooc.com/api.js"&gt;&lt;/script&gt; 跨域资源共享（CORS）：复杂主流的跨域解决方案。 普通跨域请求：只服务端设置http header{Access-Control-Allow-Origin}即可，前端无须设置。 若要带cookie请求：前后端都需要设置。 12//前端设置 原生JSxhr.withCredentials = true; 窗口之间JS跨域postMessage用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 6-6 存储cookie本身用于客户端和服务端通信本身有本地存储功能，于是被”借用”document.cookie = xxx 获取和修改即可 缺点： 存储量太小，4kb；所有http都会带着，影响获取资源的效率(因此仅4kb)；API简单，需要封装才能用 document.cookie localStorage和sessionStorageHTML5存储设计，容量5MAPI简单易用:localStorage.setItem(key,value)和localStorage.getItem(key)注意：应该try-catch封装，在iOS无痕模式下，getItem(key)会报错 区别：容量不同是否会被携带到ajaxAPI易用性清除：localStorage浏览器不主动清除数据，非登录状态都存在这里；sessionStorage每次会话结束会清清除。 第七章 7开发环境7-3 git常用命令代码管理、大型项目需要多人协作开发 命令： 1git add 第1章 系好安全带,准备启航第2章 你要懂的规则(JS基础语法)第3章 一起组团(数组)第4章 跟着我的节奏走(流程控制语句)第5章 小程序，大作用（函数）第6章 事件响应，让网页交互第7章 JavaScript内置对象第8章 浏览器对象第9章 DOM对象，控制HTML元素第10章 编程挑战###]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 1 基础语法]]></title>
    <url>%2F2017%2F02%2F19%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FJavaScript%20-%203%20ES6%2F</url>
    <content type="text"><![CDATA[常量const x = “123”;//常量，定义后不能修改 作用域：var 定义的 i 变量是一个全局变量 let 声明的变量：块作用域 作用域一、ES5中，callbacks中的return i*2，是对变量的引用，而不是对函数变量值的引用。函数体中是一个变量，而不是一个值。 二、用let声明的变量有块作用域的概念，这个时候的闭包取决于当前的块作用域，会将当前值保存，供后面的闭包使用。 三、es6:{}表示一个新的作用域，{}可以对作用域进行隔离。 es5中要执行立即执行函数（(function(){},()），才能对作用域进行隔离。 ###箭头函数 ES6箭头函数()=&gt;{ } 替代 ES5中function a（）{ }结构 箭头函数中this指向—是对象被定义时this的指向 普通函数的this指向—指向被调用对象 默认参数ES5,ES6可变参数的处理 求和例子 ES5利用 Array.prototype.slice.call(arguments) 获得 参数列表 ES6 直接是（扩展运算符 …）+参数名 可直接获取参数列表 f(…a){ } 扩展运算符合并数组 … 代表自己 对象代理对象代理多用于数据保护。 ES3 this.set中判读if是某个属性不能复制；ES5数据只读；ES6 Proxy对象代理。 12345678let person = new Proxy(Person,&#123;get(target,key)&#123;return target[key];&#125;,set(target,key,value)&#123; if(key != 'sex')&#123; target[key]=value; &#125; set和map其他：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 0 排序实现]]></title>
    <url>%2F2017%2F01%2F05%2F%E2%9D%A4%EF%B8%8F%E7%AE%97%E6%B3%95%20-%200%20%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[快速排序时间复杂度：O(nlogn)，最差情况为O(n^2) 空间复杂度：O(1)，没有使用额外空间 稳定性：不稳定 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# 一、算法导论实现def quickSort(array, l, r): if l &gt;= r: return mid = partition(array, l, r) quickSort(array, l, mid - 1) quickSort(array, mid + 1, r)"""在划分partition的过程中排序，使用小区游标i+循环游标j，将比key小的值j与i在的位置交换，直至分区后交换r与i+1的值，返回i+1的中心位置。"""def partition(array, l, r): # 1.选择主元 key = array[r] # 2.找到小区，使用小区最后一个元素i，游标j i = l - 1 j = l for j in range(l, r): # 2.1 j循环+1，找到小于key的元素时候，i后移动，并将找到的arr[j]与arr[i]换位置 if array[j] &lt; key: i += 1 array[i], array[j] = array[j], array[i] # 3.游标j循环后，i为小区的最后一个元素，将r与i+1换位置，则分割完成 array[i + 1], array[r] = array[r], array[i + 1] return i + 1if __name__ == '__main__': nums = [6, 1, 2, 7, 9, 9, 3, 4, 5, 10, 8, -1] quickSort(nums, 0, len(nums) - 1) print nums 归并排序时间复杂度：O(nlogn)，最好最优平均 空间复杂度：O(n)，每次归并的时候需要开辟临时空间 2倍数组长度的空间 稳定排序 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-def mergeSort(array): # 1.划分小于等于1，则返回自己 if len(array) &lt;= 1: return array # 2.大于1，继续划分为左右，mid为中位index。返回为merge排序后的结果。 else: mid = len(array) / 2 print mid left = mergeSort(array[:mid]) right = mergeSort(array[mid:]) # 返回排序后的left+right return merge(left, right)"""在merge的过程中排序，输入为left，right数组，使用i、j循环俩数组，返回排序好的合并数组result。"""def merge(left, right): # 1.临时存储空间 result = [] # 2.left的下标i，right的下标j i = 0 j = 0 # 2.循环left和right，将小的存入result，i或j+1，直至i、j有一个分完 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # 3.将未循环完的剩余left或right数组的数字直接与result连接 result += left[i:] result += right[j:] # 4.返回merge结果 return resultif __name__ == '__main__': array = [9, 6, 1, 2, 5, 0, 4] result = mergeSort(array) print result]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 -]]></title>
    <url>%2F2017%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%203%20%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[应用三：求中位数、第k%大的数字 维护大顶堆和小顶堆，分别存储n/2个数据（奇数则大顶堆维护n/2+1个） 大数据： 10亿关键字，Top10关键字。 散列表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 1 海量数据]]></title>
    <url>%2F2017%2F01%2F05%2F%E2%9D%A4%EF%B8%8F%E7%AE%97%E6%B3%95%20-%201%20%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[1、海量日志数据，提取出某日访问百度次数最多的那个IP。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 2 动态规划]]></title>
    <url>%2F2017%2F01%2F05%2F%E7%AE%97%E6%B3%95%20-%202%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[https://hit-alibaba.github.io/interview/basic/algo/DP.html 动态规划适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。 爬楼梯问题 LeetCode 70经典的动态规划问题之一，容易找到其状态转移方程为 dp[i] = dp[i-1] + dp[i-2]，从基础的 1 和 2 个台阶两个状态开始，自底向上求解： 容易看出其实结果就是 fibonacci 数列的第 n 项。 连续子数组的最大和 LeetCode 53用 dp[n] 表示元素 n 作为末尾的连续序列的最大和，容易想到状态转移方程为dp[n] = max(dp[n-1] + num[n], num[n])，从第 1 个元素开始，自顶向上求解： House Robber LeetCode 198对于一个房子，有抢和不抢两种选择，容易得到状态转移方程 dp[i+1] = max(dp[i-1] + nums[i], dp[i])，示例代码如下： 最长回文子串 LeetCode 5用 dp[i][j] 表示子串 i 到 j 是否是回文，使用动态规划求解： 12345678910111213141516171819202122232425262728293031323334353637383940string longestPalindrome(string s) &#123; int m = s.size(); if (m == 0) &#123; return ""; &#125; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(m, 0)); int start = 0; int length = 1; for (int i = 0; i &lt; m; i++) &#123; // 单个字符属于回文，例如 abcd dp[i][i] = 1; // 连续两个字符相同属于回文，例如 abb if (i &lt; m - 1) &#123; if (s[i] == s[i + 1]) &#123; dp[i][i + 1] = 1; start = i; length = 2; &#125; &#125; &#125; for (int len = 2; len &lt;= m; len++) &#123; for (int i = 0; i &lt; m - len; i++) &#123; int j = i + len; // 扩展长度 if (dp[i + 1][j - 1] == 1 &amp;&amp; s[i] == s[j]) &#123; dp[i][j] = 1; if (j - i + 1 &gt; length) &#123; start = i; length = j - i + 1; &#125; &#125; &#125; &#125; return s.substr(start, length);&#125; 最小编辑距离 LeetCode 722.进程线程（还有有关操作系统的 我忘了 3.数据库查询 然后连接查询 8.链表讲一下 什么单向链表双向链表循环链表 链表适合快排吗为什么 四次挥手 time_wait 客户端当被告知服务端接收窗口大小为0后的行为，如果服务端的接收窗口又变大了呢？ 拥塞控制 https://www.cnblogs.com/logsharing/p/8448446.html get参数通过url传递，post参数放在request body中 get参数是有长度限制的，而post没有 get参数直接暴露在url中，较为不安全，不能传递敏感信息 get请求只能进行url编码，而post支持多种编码方式 get请求浏览器会主动cache get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留 get和post本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同 get产生一个TCP数据包，post产生两个TCP数据包 总结： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。（据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。） 对于get和post的区别，get传递数据如同是写在脸上，post传递数据如同放在肚子里，脸上不能放太多东西，也不能放隐私东西，肚子里就无所谓啦~（一个面试官给我说的巧记妙招~） 浏览器输入 www.qq.com 发生了什么; 第二次访问与第一次有什么区别吗，长连接和短连接，四次挥手，客户端先发和服务端先发FIN有什么区别，一般是哪端先发，原因，哪端先发好？time_wait持续时间？2MSL? 没有time_wait有什么问题 http 与 https 区别，ssl 的过程]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 -]]></title>
    <url>%2F2017%2F01%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%2F</url>
    <content type="text"><![CDATA[两种基础的数据结构：链表和数组。 数组占据随机访问的优势，却有需要连续内存的缺点。 链表具有可不连续存储的优势，但访问查找是线性的。 散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。 我们可以得出数据结构和算法的重要性排行榜：连续空间 &gt; 时间 &gt; 碎片空间。 数组：连续的内存空间和相同类型的数据。访问时间O(1)，插入删除为了保证连续时间为O(n)。 王者荣耀2亿用户，如何实现动态更新排行榜前100名（具体代码）？ 我说的是分文件 然后小根堆实现动态更新]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
