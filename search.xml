<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IOS开发 - APP合集]]></title>
    <url>%2F2019%2F03%2F09%2FAPP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[合集简介编码工具： Xcode 10.1，Swift 4.2，UIKit 设计工具：Adobe Inllustrator， 设计icon ， 生成icon 第三工具：移动端火热数据库 Realm，天气API等 思路来源：平时喜欢在APP store里面下载一些独立开发者的APP。这些APP部分思路来自于优秀的APP（如羡辙-2019字体日历、素记 等），部分是自己生活需要的简单小功能。 代码方面：大部分使用了Storyboard，UI设计需要；纯手写代码在 每日一个swift小程序内 开源项目：暂未整理完成 Project : Todos 极简事项 需求分析：iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 技术： 数据存储：先学习了userDefault，再改为时下火热的移动端数据库Realm存储数据 TableView 具体实现 Project : Weather 元气天气 需求分析：让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 技术： 页面传值 第三方库管理器 具体实现 Project 3 : Quizzler 奇怪问答 需求分析：该问答APP可以修改为任意主题的答题APP。目前想法是改为数据结构基础知识的APP，因为我自己可以用该APP为了实习面试而刷题。 技术： SVM模式 题库存储：realm移动端数据库 具体实现 Project 3 : Dicee 麻将骰子模拟器技术： 具体实现 Project 2 : Magic 8 Ball 问答魔力球Project 1 : 计时器 技术： SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 具体实现]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 5 任务清单APP]]></title>
    <url>%2F2019%2F03%2F08%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%2F</url>
    <content type="text"><![CDATA[项目介绍需求分析TableViewController 增加任务 删除任务 修改任务 需求遇到的困难知识点 项目布局UI设计页面一页面二源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F03%2F07%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%204%20%E5%85%83%E6%B0%94%E5%A4%A9%E6%B0%94APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析让用户查看当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 本程序共分为三个页面：欢迎页面，天气预览界面，城市天气查询界面。 需求天气预览界面：定位天气展示【1 获取当前经纬度位置 2 根据位置获取天气、城市信息 3将信息展示在视图】 城市天气查询界面：用户查询天气【1展示当前城市 2输入框输入查询城市的名称 3按下查询按钮-获取名称至页面1，销毁页面2 】 采用了MVC模式model部分负责数据，我们构建天气类，属性包括：温度、城市、condition，以及计算属性——icon、words，他们需要根据condition属性来确定。比如晴天对于icon为小太阳、文字对于“天晴是你的心情”。 controller负责两个页面中的业务逻辑：从model中取数据，然后返回给view。 最终在view上展示所需天气及其文字信息。 遇到的困难页面跳转传值页面跳转传值部分。【功能：按页面1右上角按钮，跳转到页面二，页面二展示当前city；用户输入目标city，按查询后跳转回页面一，展示查询city的天气信息】 segue导航正向传值较容易，3步骤。1在prepare函数部分获取segue的identifier【转换箭头】，2使用as!强制转化，实例化该segue的destination页面vc，3使用实例化的vc进行传值。这样就可以在下一个页面使用本页面中的“所在城市”的信息了。 而反向传值就不同。如果采用control+drag方式，从页面二的button到页面一加上转换箭头，这样只会再重新生成新的页面一，定位到本地天气；而不是预想的回到原先页面，重新展示所搜索城市的信息。 所以需要自定义protocol，使用delegate实现导航的反向传值。 在页面二需要：3个步骤来自定义协议portocol，实现【按下查找城市按钮，获取输入的city值】的功能。 1自定义协议，安排协议中的方法（获取输入的city，传给页面一），2 声明协议属于页面二中的delegate变量 3规定在哪里触发协议中的事件。 在页面一种需要：3个步骤来实现协议，实现【获取页面二中city的值，并展示于本页面】的功能。 1遵守协议 2 实现协议中的方法（获取city值，根据值获取温度对象的所有信息，展示与本页面）3 第二个页面vc的事件函数委托delegate给self实现。 获取当前位置的天气1 委托本页面，实现定位协议中的请求位置的方法，获得经纬度。（难点） 2 根据经纬度信息，使用Alamofire请求API来获取天气数据； 3 利用SwiftJSON解析生成数据； 4 给weather对象赋值； 5 再使用weather对象中的天气、文字信息更新页面。 – 使用了定位协议CLLocationManagerDelegate的方法。 1 遵守定位协议 2 实例化定位管理器CLLocationManager 3 实现协议中的方法（获取当前的经纬度）4locationManager委托本页面 当manager请求位置的时候，则系统自动调用manager方法，在该方法里获得经纬度。 知识点protocol-delegate：类似java中的接口与实现协议——工具间，协议中的方法——工具，实例化的对象——老板，本页面self——打工仔，委托——老板让打工仔干活 计算属性model中的计算属性——compute属性 某个属性需要根据另一个属性来确定，我们定义其为计算属性 如根据天气情况属性——晴天，得到对应的icon和words：icon为小太阳、wors为“天晴是你的心情”。 第三方库的CocoaPods安装的使用Alamofire：完成http请求天气数据 SwiftJSON：解析、生成数据 extension代码优化目的：提高代码可读性。为日后重构代码打下了良好的基础。 场景：1 私有的辅助函数 ；2 遵守协议（实现某个协议的方法放到一个 extension 中）；3 模型（Model用结构体， 使用extension 将 Model 的 属性 和 基于属性的计算计算属性分离 ） 项目布局UI设计 页面一创建项目的时候需要取消左右旋转 背景图约束： 上下左右相对于View都是0 背景图片填充方式为Aspect Fill拉伸 中间图片 Label 左边自适应 页面二StackView自适应页面的宽度： 选中StackView后control+drag至背景图 是的stackView：页面的比例为2：5 错误：该页面无法到达，需要添加跳转 需要按下按钮，跳转至新的页面：选中按钮，control+drag 至第二页面，选择show（直接跳转）/Present modally（从下往上弹出），生成连接。 启动页面同理自行设计 依赖管理工具CocoaPods介绍 什么是CocoaPods CocoaPods是OS X和iOS下的一个第三类库管理工具，通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods的好处 1、在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 2、使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 需要第三方库的时候，三个步骤： 0、安装cocoapos 1、command+N导入项目 2、自动创建podfile文件，在该文件写入pod ‘工具包名称’，点击instal下载 3、项目安装配置第三方库完成，点击r.xcworkspace文件进入项目 在CocoaPods中安装第三方库SVProgressHUD 导入 写需要的第三方库，安装 安装配置完成。安装配置过功能包之后，打开项目都是使用Weather.xcworkspace文件 获取经纬度请求用户给予权限的窗口未弹出，报如下错误 原因是：弹框弹出时，需要给到一个描述给用户，说明为什么需要该信息，在info.plist中设置 问题解决： https://swift.gg/2017/02/13/requesting-permissions-core-location-tutorial/ API 使用网络请求功能包Alamofire完成http请求获取天气数据https://study.163.com/course/courseLearn.htm?courseId=1208935831&amp;share=1&amp;shareId=1386037112#/learn/video?lessonId=1278405463&amp;courseId=1208935831 API:应用程序接口(API:Application Program Interface) https://openweathermap.org/api 选择合适的API 根据经纬度获取天气需要的信息 HTTP+字典Dictionary+JSON+第三方功能包SwiftyJSON字典类型：键值对构成 let dict:[String:Any] = [“name”:”zhangsan”,”age”:18] 创建Weather模型+把获取到的数据显示到页面+计算属性初探https://openweathermap.org/weather-conditions 代码优化-把功能块分离出来变成函数+extensionview连接controller+segue导航正向传值+三种as+delegate实现导航的反向传值view连接controller 选择cocoaTouch class，创建controller，选择页面二，建立连接。 segue导航正向传值1、选中转换箭头，设置该转换的id 2、通过在segue的函数中的segue.identifier找到究竟是哪一个【转换箭头】 3、根据转换箭头，使用 sugue.destination 找到箭头的目的地页面 4、使用as!强制转换获取页面vc（实例化的对象） 5、利用vc页面，传值 自定义protocol和delegate实现导航的反向传值页面二：selectCityController 自定义协议，安排了协议的方法 工具属于谁的——页面二中的delegate变量的 规定在哪里触发时间——按下查找城市按钮 页面一：viewController 遵守协议——领取工具 实现协议中规定的方法——去干活。原因：想要用协议的方法，获取里面的参数 委托——指导谁（vc）委托给本页面（self）的 转型——三种as as 向上转型：安全，一般直接使用Int(3.2)，所以不常用 3.2 as Int as? 向下转型：需要判断 if let，若转换不了，得到nil 1if let vc = segue.destination as? SelectCityController as! 向下转型 1let vc = segue.destination as! SelectCityController 完成用户查询天气的功能源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 3 一站到底APP]]></title>
    <url>%2F2019%2F03%2F06%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%203%20%E4%B8%80%E7%AB%99%E5%88%B0%E5%BA%95%20%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析与项目布局需求分析1用户答题——2比对答案——3刷新页面进入下一题 面试介绍首先我来介绍第一个项目——一站到底答题类APP。 其主要业务需求是【1用户答题——2比对答案——3刷新页面进入下一题】 我是使用的是MVC模式开发，保证了项目功能之间的低耦合。 首先我们的数据就是题库，题目类属性为题干和答案。 用户在View上看到题干，选择心中的答案，Controller将获取当前问题答案的请求发送给model，model将答案返回，在Controller与其正确答案比对，正确后计得分并显示在View上，Controller再获取下一个题目的题干和答案，刷新View的题干label和进度条进行下一个题目答题。 在所有题目加载完成后，弹出框显示分数，用户可重新开始游戏。 面向对象编程 OOP类：抽象 对象：具体 初始化方法、构造方法：实例化之后创建一个对象 eg. 类：人——属性：名字、性别 对象：Iris这个人——属性：iris、女 MVC模式控制器从model取得数据，然后返回给view——MVC Model 模型：负责数据找后台数据 View 视图：用户界面Controler控制器：业务逻辑负责传递视图需要表达的信息， 拿到数据后，传到视图 需求：打开微博个人页面，想要查看多少人关注自己 首先传到控制器，发现需要准备数据——关注人数 找到模型要数据 模型准备好数据之后，将数据给Controler，Controler拿到后传给View， 分工明确，高聚合，低耦合 功能实现弹出框 谷歌关键词： alert Apple documentation 方法：UIAlertController 使用第三方库在swift项目中调用objective-C语言的包 下载源码：https://github.com/relatedcode/ProgressHUD 拖入项目中的supporting files的组中 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 2 木琴APP]]></title>
    <url>%2F2019%2F03%2F05%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%202%20%E6%9C%A8%E7%90%B4APP%2F</url>
    <content type="text"><![CDATA[项目介绍按下不同的按键，发出不同的音调。 Tag // 3.1 通过tag获取被按下的buttonlet indexTag = sender.tag 多媒体播放器// 1.引入多媒体播放器import AVFoundation // 2.声明播放器，用于播放url的多媒体文件var player:AVAudioPlayer! // 3.4 将“音频”放入“播放器”player = try AVAudioPlayer(contentsOf: url!) // 3.5 播放音频player.play() url // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: “note(indexTag)”, withExtension: “wav”) 编组：可以帮助项目整理同类型，且不同使用文件，获取文件更方便 抛异常 // 抛异常: 播放器可能为空 do{}catch{print(error)} 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import UIKit// 1.引入多媒体播放器import AVFoundationclass ViewController: UIViewController&#123; // 2.声明播放器，用于播放url的多媒体文件 var player:AVAudioPlayer! // 音频资源 let sounds = ["note1","note2","note3","note4","note5","note6","note7"] override func viewDidLoad() &#123; super.viewDidLoad() &#125; // 3.根据按下的button，播放不同的声音 // 用户按下这个控件sender，按钮 @IBAction func notePressed(_ sender: UIButton) &#123; // 3.1 通过tag获取被按下的button 1-5,下标需要为0-4 let indexTag:Int = sender.tag - 1 // 3.2 播放音频 play(tag:indexTag) &#125; /* 创建一个发出声音的功能函数 输入为第几个声音Int */ func play(tag:Int)&#123; // 1 根据tag不同，获得不同“音频” // Bundlez最外面(苹果为整个取得APP的名字) // main为主要同名文件夹 // 直接可以取到的原因：SoundFile是一个组，不是文件夹 let url = Bundle.main.url(forResource: sounds[tag], withExtension: "wav") // 抛异常: 播放器可能为空 do&#123; // 2 将“音频”放入“播放器” player = try AVAudioPlayer(contentsOf: url!) // 3 播放音频 player.play() &#125;catch&#123; print(error) &#125; &#125;&#125;]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 1 摇色子APP]]></title>
    <url>%2F2019%2F03%2F05%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%201%20%E6%91%87%E8%89%B2%E5%AD%90APP%2F</url>
    <content type="text"><![CDATA[项目介绍点击按钮或者摇晃手机，两个骰子摇晃改变。 UI设计 IBOutlet和IBActionOutlet 插座 ：定义控件 Action 动作 ：控件动作 步骤control 拖拽定义控件IBOutlet和动作IBAction TIPS改名方式需要先断开连接，再修改变量名，再建立连接 否则运行时会抛异常：空指针问题 命名方法文件名 大驼峰 变量名 小驼峰 快捷键command+R:运行 随机数和数组实现图片使用数组存储String类型的图片文件名 随机数获取0-5的数字作为数组下标 将功能放进func函数中，代码更改性更强 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// ViewController.swift// Dicee//// Created by iris on 2019/3/5.// Copyright © 2019 IrisWang. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; // 一、随机数 var index1:Int = 0 var index2:Int = 0 // 二、数组 let diceArray = ["dice1","dice2","dice3","dice4","dice5","dice6"] @IBOutlet weak var diceeImageView1: UIImageView! @IBOutlet weak var diceeImageView2: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 初始的数字也是随机的 updateDiceImage() &#125; @IBAction func rollButton(_ sender: Any) &#123; // 更新骰子 updateDiceImage() &#125; // 三、函数:将功能放进函数中 // 更新骰子函数 func updateDiceImage()&#123; // 1.获取随机数 // 闭区间 0...5 取0-5这几个数 index1 = Int.random(in: 0...5) index2 = Int.random(in: 0...5) // 2.获取数组的某一个 // diceArray[index1] // 3.摇骰子功能 command+R:运行 diceeImageView1.image = UIImage(named: diceArray[index1]) diceeImageView2.image = UIImage(named: diceArray[index2]) &#125;&#125; 摇一摇功能谷歌关键词：shake apple documentation 给出结果：motionEnded 123456// 四、摇一摇功能// 手势结束之后，要进行的行为 motionEndedoverride func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) &#123; // 更新骰子 updateDiceImage()&#125; 练习——占卜球]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 7 定制Table Views]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%207%20%E5%AE%9A%E5%88%B6Table%20Views%2F</url>
    <content type="text"><![CDATA[项目简介开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。 12345import UIKitimport Foundationclass RestaurantTableViewController: UITableViewController&#123;//code&#125; 将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码： cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择打钩，且Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。 12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 位置和类型label设置 添加“Type”和“Location”。添加如下两个数组变量： 1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可： 12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 结果： 练习 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 ###]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%206%20%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84Table%20Based%20App%2F</url>
    <content type="text"><![CDATA[项目简介 table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。 出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击到UITableViewDataSource中查看： 1234567891011121314151617public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell's reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different //...&#125; UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有.有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 5 Stack View设计UI]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%205%20Stack%20View%E8%AE%BE%E8%AE%A1UI%2F</url>
    <content type="text"><![CDATA[项目介绍 参考链接：https://www.jianshu.com/p/25f062e903cf 作者：Andy_Ron 这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 步骤Assets.xcassetsXcode中添加图片 Lable布局用Stack View布局title的label 先拖入两个label。其一修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色；其二修改label的title为“Get help from experts in 15 minutes” 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出两个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label。 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution image布局 拖动三个image view对象。并修改其image属性为user1，user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 组合stack view后添加布局约束 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 选中大的stack view，添加space constraints，上，左右，分别为70，0，0 添加约束后，如果出现布局问题，可通过issue indicator解决：点击问题 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 3 傻瓜式制作APP图标]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%203%20%E5%82%BB%E7%93%9C%E5%BC%8F%E5%88%B6%E4%BD%9CAPP%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用真机测试的效果如下： 设计网址：https://www.canva.cn/ step1 自定义尺寸：1024 x 1024 step2 设计：拖入背景和元素 step3 下载得到png格式的图标 生成图标网址：https://appicon.co/ 将图片拖入网站，选择需要的格式，下载得到zip 解压后得到 图标拖入工程项目中需要各种大小的icon 进入Assets.xcassets的文件夹，删除AppIcon.appiconset文件夹 再将上步解压后的文件夹拖入 消除警告，直接键盘delete删除多余图片即可]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 每日一个Swift小程序]]></title>
    <url>%2F2019%2F03%2F04%2FIOS%E5%BC%80%E5%8F%91%20-%20%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AASwift%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[swift学习日记——每日一个小程序 名称：30DaysofSwift 工具： Xcode 10.1, Swift 4.2, UIKit 思路来源：samvlu ，Allen_朝辉，nimomeng 用例方面：主要参考nimomeng的case，也参考了Sam Lu的40个小项目，也参考了Allen_朝辉的项目 代码方面：前两个项目学习了Storyboard，然而实际上多人协作的项目中我们尽可能少用Storyboard，因为很容易出现冲突问题。况且从学习的角度，storyboard很难说清楚操作步骤是什么。因此以后的项目都尽量手写。 开源项目：暂未整理完成 Project 3 : 计时器 Change Custom Font 学习内容： 具体实现 SnapKit：项目的自动布局 Timer 计时器：fire()与invalidate() guard语句：guard 判断合理条件，保证判断条件简约。详见 guard详解 Project 2 : 改变字体 Change Custom Font 学习内容： 获取字体属性：UIFont.familyNames可以存储为数组，可以直接输出、或通过索引获取 随机获取字体：随机数arc4random()格式为UInt32，需转为Int，再对数组长度取余。获得范围随机数 字体设置：words.font=UIFont(name: “字体名称”, size: 20) 按钮边框设置：圆角cornerRadius，颜色borderColor，该颜色需要CGColor，因此需要将UIColor转为CGColor 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041//// ViewController.swift// ChangeCustomFont//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var words: UILabel! @IBOutlet weak var change: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 按钮的边框粗细、圆角、颜色 // 注：颜色需要CGColor，因此需要将UIColor转为CGColor change.layer.borderWidth = 1; change.layer.cornerRadius = 8; change.layer.borderColor = UIColor.blue.cgColor &#125; // 字体改变：根据随机数，随机获取系统字体的第i个 @IBAction func change(_ sender: Any) &#123; // 1.存储字体名称y为数组 let familyNames_arr = UIFont.familyNames let count:Int = familyNames_arr.count // 2.获取随机数 // 平常的随机数：0 ~ X,UInt32格式，需要转为Int let random1:Int = Int(arc4random()) // 限制长度的随机数，取余 ：0 ~ X let random2:Int = random1 % count // 3.设置字体为第 随机数 的字体 print(familyNames_arr[random2]) words.font=UIFont(name: familyNames_arr[random2], size: 20) &#125;&#125; Project 1 : 加法计算器 Calculation of Add 学习内容： 具体实现 IOS的UI布局：使用Storyboard和其辅助视图添加部件，且为部件定义，加上动作 值的转化：Option获取 -&gt; String -&gt; Float计算 -&gt; String展示]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Swift开发iOS10 - 4 AutoLayout]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%94%A8Swift%E5%BC%80%E5%8F%91iOS10%20-%204%20AutoLayout%2F</url>
    <content type="text"><![CDATA[项目介绍Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag 使用Auto Layout使label到中央Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Control-drag使得label到右下角用control+drag方法来添加spacing constraint。 按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。 所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束 使用Auto Layou\Control-drag使得label水平居中，距离上边40]]></content>
      <categories>
        <category>IOS学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习整理 - 未完待续]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%AE%9E%E4%B9%A0%E6%95%B4%E7%90%86%20-%20%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[实习的资料整理。 包括银行、互联网公司。 包括各公司的福利整合。 农业银行截止日期：3.20日申请入口 宣传网页： https://i.eqxiu.com/s/iqd0XQ71?eqrcode=1&amp;share_level=5&amp;from_user=b819b53f-2d44-49e8-aa62-fa07f712a8ef&amp;from_id=c8995d88-6327-45bc-97dc-a4ad26ef27cb&amp;share_time=1551152498524&amp;from=timeline&amp;isappinstalled=0 福利工资17k。公积金5200。 农行总部编制 档案北京管理 北上广天成西 六地即可 扩招截止20年 这两年把握机会 进入顶级国企 全国统一待遇 当地公积金封顶 上海数据中心 部门 免费房子（一辈子） 招商银行时间：3.4-4.7内推网页： https://cmbjob.ccc.cmbchina.com/positionlistshare.html?v=3.0&amp;refereeId=847a71a8-f981-4d7a-abd3-d846ddef0634&amp;refereeCode=674440&amp;recruitType=3&amp;positionClass=&amp;deptId=003 福利180w行员贷款福利 招行有免费房子住的（只有一年） 花旗银行 发简历给HR 微信https://mp.weixin.qq.com/s/Yyxep9M6z525g-c6czt78Q 发简历给HR 快手实习招聘 腾讯时间：提前批3月9日，普招3.31 字节跳动时间：未知。一直在发布岗位，投递后5个工作日内安排面试内推码：6PFRDJMhttps://job.toutiao.com/2018/intern_referral/?token=5lT3rIxuAZuD18qmg3DYlg%3D%3D&amp;key=MjU4NDcsMzE5MTEsMzE5MTQsMzE5MTUsMzE5MTgsMzE5MjMsMzE5MzE%3D&amp;from=groupmessage&amp;isappinstalled=0 深信服时间：未知 华为 其他Google Girl Hackathon报名截止时间：2019年3月6日23:59分 报名： https://mp.weixin.qq.com/s/7H9NBuRYAqNnRciF3m3Cng]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的计时器]]></title>
    <url>%2F2019%2F02%2F28%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目介绍 项目完全由代码所写，没有使用storyboard，代码更具有复现性。 手动部分：需要将图片拖入assets 项目知识SnapKit 布局经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达9340颗星。 作者仍然是写Objective-C的第三方库Masonry的大牛 - @Robert Payne。 SnapKit配置1.github下载：https://github.com/SnapKit/SnapKit 2.将下载下来的SnapKit项目的 SnapKit.xcodeproj 拖进自己的项目目录最外层中 3.工程文件 -&gt; General -&gt; Embedded Binaries 中点击加号，添加SnapKit库到项目中来 4.command+B 重新编译项目 SnapKit使用123456789101112131415161718192021import UIKitimport SnapKit class ViewController: UIViewController &#123; // 1.定义box var box = UIView() override func viewDidLoad() &#123; super.viewDidLoad() box.backgroundColor = UIColor.orange // 2.将box加入父视图，之后的布局是相对于父视图布局的 self.view.addSubview(box) // 3. 添加布局的约束：上下左右、中心、 box.snp.makeConstraints &#123; (make) -&gt; Void in make.width.equalTo(100) make.height.equalTo(100) make.center.equalTo(self.view) &#125; &#125;&#125; Timer 计时器初始化1234self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true ,block:&#123; (timer) in // withTimeInterval ： 的值0.1s 时间片后，执行的代码 // repeats : withTimeInterval的时间后，是否继续重复 &#125;) 启动：fire1self.timer.fire() 您可以使用此方法来触发重复计时器，而不会中断其常规的触发计划。 如果计时器不重复 repeats，则在触发后自动失效，即使其预定的触发日期尚未到达。 暂停：invalidate（移除计时循环）1self.timer.invalidate() 官方的解释是： This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes and releases the timer, either just before the invalidate method returns or at some later point. 这是唯一一个把一个定时器从NSRunLoop object运行循环中移除的方法。 NSRunLoop object这个对象移除，并且release掉这个的定时器，或者是在这个invalidate方法返回的之前或是在之后的某个时间段，再进行移除并release操作。 guardguard 打头只判断合理条件，保证判断条件简约 guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 详见 guard详解 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//// ViewController.swift// WatchDemo//// Created by iris on 2019/2/27.// Copyright © 2019 iris. All rights reserved.//// 学习：import UIKitimport SnapKitclass ViewController: UIViewController &#123; var timer:Timer! var resultLabel:UILabel! //计时器：文字显示 var resultNumber:Double = 0 //计时器：时间记录 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. // 1.计时器的数字显示 // 1.1 数字的背景 let resultView = UIView() resultView.backgroundColor = UIColor.init(red: 0.0, green: 0.0, blue: 0.1, alpha: 1) // 注意：使用snp.makeConstraints方法的元素必须事先添加到父元素的中，例如：self.view.addSubview(view) self.view.addSubview(resultView) resultView.snp.makeConstraints&#123; (make) in make.top.equalTo(0) make.left.equalTo(0) make.height.equalTo(300) // 长度 300 make.width.equalTo(self.view.frame.width) &#125; // 1.2 数字的显示 resultLabel = UILabel() self.view.addSubview(resultLabel) resultLabel.textColor = UIColor.black resultView.addSubview(resultLabel) resultLabel.snp.makeConstraints&#123; (make) in make.center.equalTo(resultView) make.width.height.equalTo(140) make.width.equalTo(400) &#125; resultLabel.font = UIFont.init(name: "Helvetica Neue", size: 60) resultLabel.text = "0.0" resultLabel.textColor = UIColor .white // 设置字体对齐方式 resultLabel.textAlignment = NSTextAlignment.center // 2.开始按钮 // 2.1 开始按钮：背景 let startView = UIView() startView.backgroundColor = UIColor.init(red: 0.1, green: 0.0, blue: 0.8, alpha: 0.8) self.view.addSubview(startView) startView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.left.equalTo(0) make.bottom.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 2.2 开始按钮：布局 let startButton:UIButton = UIButton() // startButton.setTitle("Start", for: UIControl.State.normal) startButton.setImage(UIImage (imageLiteralResourceName: "start"), for: UIControl.State.normal) startView.addSubview(startButton) startButton.snp.makeConstraints &#123; (make) in make.center.equalTo(startView) make.width.height.equalTo(50) &#125; // 2.3 开始按钮：点击事件添加 startButton.addTarget(self, action: #selector(startHander), for: UIControl.Event.touchUpInside) // 3 停止按钮 // 3.1 停止：背景 let stopView:UIView = UIView() stopView.backgroundColor = UIColor.init(red: 0.1, green: 0.8, blue: 0.0, alpha: 0.8) self.view.addSubview(stopView) stopView.snp.makeConstraints &#123; (make) in make.top.equalTo(300) make.bottom.equalTo(0) make.right.equalTo(0) make.width.equalTo(self.view.frame.width / 2) &#125; // 3.2 停止：按钮 let stopButton:UIButton = UIButton()// stopButton.setTitle("Stop", for: UIControl.State.normal) stopButton.setImage(UIImage (imageLiteralResourceName: "pause"), for: UIControl.State.normal) stopView.addSubview(stopButton) stopButton.snp.makeConstraints &#123; (make) in make.center.equalTo(stopView) make.width.height.equalTo(50) &#125; // 3.2 停止：按钮事件添加 stopButton.addTarget(self, action: #selector(stopHander), for: UIControl.Event.touchUpInside) // 4 重置 // 4.1 重置按钮 let resetButton:UIButton = UIButton() resetButton.setTitle("Reset", for: UIControl.State.normal) resetButton.titleLabel?.font = UIFont.init(name:"Helvetica Neue",size:20) resultView.addSubview(resetButton) resetButton.snp.makeConstraints &#123; (make) in make.right.equalTo(-10) make.top.equalTo(10) make.width.equalTo(100) make.height.equalTo(50) &#125; // 4.1 重置：事件监听 resetButton.addTarget(self, action: #selector(resetHander), for: UIControl.Event.touchUpInside) &#125; // 3个按钮的事件函数 // 1.开始计时 @objc func startHander()&#123; if self.timer != nil&#123; self.stopHander() &#125; self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true,block:&#123; (timer) in self.resultNumber = self.resultNumber + 0.1 self.resultLabel.text = String(format:"%.1f",self.resultNumber) &#125;) self.timer.fire() &#125; // 2.暂停时间 @objc func stopHander()&#123; // 2.1 不进行判断的方法，可能出现异常，内存可能泄露// var timerForDistory:Timer!// timerForDistory = self.timer// timerForDistory.invalidate() // 2.2 进行判断的方法，可能出现异常，内存可能泄露 // guard 打头只判断合理条件，保证判断条件简约 // guard xxx : 如果不满足gurad后面的条件xxx，则执行else的内部代码 guard let timerForDistory = self.timer else &#123; return &#125; timerForDistory.invalidate() &#125; // 3.重置计时器 @objc func resetHander()&#123; self.resultNumber = 0 self.resultLabel.text = "0.0" &#125;&#125;]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发 - 简单的加法计算器swift版本]]></title>
    <url>%2F2019%2F02%2F26%2FIOS%E5%BC%80%E5%8F%91%20-%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8swift%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[近日开始学习IOS开发。想找一个简单版本较新的IOS开发教程都很难：（1）现在找的很多都是object-C的，不是swift的，（2）老版与最新版本swift中很多语法也不适配，（3）Xcode版本和用法也不一样。 因此，今天自己写一个最简单的教程，用于swift入门，记录自己的学习。 基础步骤基础步骤就是项目类型、项目名称、项目位置的选取。 1.创建APP 2.项目类型为 简单的view 3.项目名称：加法计算器 4.结果 界面拖拽1、打开故事版，找到UI部件框，搜索需要的部件——输入框、Label、按钮 2、拖拽部件、部件位置布局、部件更名，右边为其结果 3、选择展示设备、选择运行设备、运行程序查看结果 4、运行结果，布局已经实现 功能实现输入框定义1、左右展示storyboard与ViewController文件，用于拖拉式实现部件定义和部件功能添加。 2、方式1：text部件定义，按住control，鼠标拖拽至ViewController对应空白处，接着添加名称以及修改属性。 方式2：输入语句，将代码前的空心点拖拽左边的UITextField @IBOutlet weak var sum: UITextField! 3、定以后的结果如下。 使用方式1拖拽num1，num2定义，使用代码和空心圈绑定至左边UITextField。 按钮功能1、添加Action作为响应 生成如下的代码，我们可以将功能函数写在calculate方法的代码内 2、编写计算的代码和清空的代码 1234567891011121314151617181920212223//计算方法//sum = num1+num2@IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125;//重置方法@IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = ""&#125; 3、结果，可以实现浮点数相加的功能 项目源码ViewController代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//// ViewController.swift// Calculation_add//// Created by iris on 2019/2/25.// Copyright © 2019 iris. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; //UITextField的定义 @IBOutlet weak var num1: UITextField! @IBOutlet weak var num2: UITextField! @IBOutlet weak var sum: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; //计算方法 //sum = num1+num2 @IBAction func calculate(_ sender: Any) &#123; //1.Option类型转为String：XX! //2.String类型转为Int： Int(XX)! let value1:Float = Float(num1.text!)! let value2:Float = Float(num2.text!)! //3.Int类型转为String：String（XX） let result:String = String(value1+value2) //4.改变结果框的颜色 sum.textColor = UIColor .cyan //5.sum.text 展示的类型为String sum.text = result &#125; //重置方法 @IBAction func reset(_ sender: Any) &#123; //清空输入框的内容 num1.text = "" num2.text = "" sum.text = "" &#125;&#125; 下载资源 CSDN资源https://download.csdn.net/user/katherine_java/uploads]]></content>
      <categories>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统下使用Hexo在Github上搭建博客]]></title>
    <url>%2F2019%2F02%2F23%2FMac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、安装环节二、Hexo部署三、github仓库四、git代码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具整理 - 设计类工具]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%20-%20%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[设计icon：https://www.canva.cn/ 生成icon：https://appicon.co/ 海报： 阿里矢量图标：https://www.iconfont.cn/ 矢量图标：https://www.easyicon.net/update/ 快捷键 command+shift+g ：跳出窗口，进入地址 Cammand+i :格式化 简历： 排版排版是简历给面试官的第一印象，正所谓人靠衣装……但是排版其实是需要审美的，有人说那我不会穿衣打扮怎么办，不会打扮不要紧，但是要会打理，可以不会搭配，但是需要打理得干净、整洁、大方，不能给人邋遢的感觉，简历也是这个道理 第一是行间距，不知道大家有没有看过一些简历字迹是挤在一起一坨一坨的，这种情况下，稍稍加大一点行间距，就可以美观很多，单倍行距太小了，1.5倍太宽，一页纸写不下多少东西，比较合适的参考值是1.2和1.25倍 第三是字体，字体可以通篇一致（指中文一致，英文数字一致，并不是中英文都一致），也可以根据分级目录选字体，字体颜色大小粗细都可以根据审美自行调整，但核心还是要整洁大方 第四是标点，尤其注意列项的时候，切忌有的加标点有的没加，还要注意半角全角等 内容个人信息个人信息里面，三项必填的，姓名、电话、邮箱，几项选填的，性别、年龄、学历、所在地、政治面貌等，有些没必要填的，学校专业班级，学校专业可以放在教育经历那一栏，还有，如果有技术博客和GitHub，建议都写上 实习经历、工作经历除了公司和时间，重要的是做的是啥，项目经验也是一样，做了啥，才是整个简历面试官想看的主要部分，个人觉得这块可以尝试这么去写，先是简单介绍整体项目，再说一说用到的技术栈，再是自己在项目中的角色，承担的部分，也可以把遇到的最大的挑战、难点写上去，前提是你得想好应对政策，面试的一大套路是让面试官往你铺设的道上走 基本技能这个常规写就好，不要太夸张，也不要太笼统，一句熟悉C、C++、Java，就没有展开了，可以稍微具体一点 获奖经历、科研成果挑重点写，获奖经历最好写含金量比较大的，小规模的比赛其实没必要写，奖学金的话可以写国奖，校级院级的个人觉得也没什么必要，有论文专利之类要写上 自我评价这块其实是最虚的东西，写得好与坏差距挺大的，但基本套话比较多，所以自己衡量 自我评价真的很虚，写得好和坏差距挺大的，如果你觉得写得好的，往上放，这是亮点]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历 - 简历要点]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%AE%80%E5%8E%86%20-%20%E7%AE%80%E5%8E%86%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[排版排版是简历给面试官的第一印象，正所谓人靠衣装……但是排版其实是需要审美的，有人说那我不会穿衣打扮怎么办，不会打扮不要紧，但是要会打理，可以不会搭配，但是需要打理得干净、整洁、大方，不能给人邋遢的感觉，简历也是这个道理 第一是行间距，不知道大家有没有看过一些简历字迹是挤在一起一坨一坨的，这种情况下，稍稍加大一点行间距，就可以美观很多，单倍行距太小了，1.5倍太宽，一页纸写不下多少东西，比较合适的参考值是1.2和1.25倍 第三是字体，字体可以通篇一致（指中文一致，英文数字一致，并不是中英文都一致），也可以根据分级目录选字体，字体颜色大小粗细都可以根据审美自行调整，但核心还是要整洁大方 第四是标点，尤其注意列项的时候，切忌有的加标点有的没加，还要注意半角全角等 内容个人信息个人信息里面，三项必填的，姓名、电话、邮箱，几项选填的，性别、年龄、学历、所在地、政治面貌等，有些没必要填的，学校专业班级，学校专业可以放在教育经历那一栏，还有，如果有技术博客和GitHub，建议都写上 实习工作经历、项目经验除了公司和时间，重要的是做的是啥，项目经验也是一样，做了啥，才是整个简历面试官想看的主要部分，个人觉得这块可以尝试这么去写，先是简单介绍整体项目，再说一说用到的技术栈，再是自己在项目中的角色，承担的部分，也可以把遇到的最大的挑战、难点写上去，前提是你得想好应对政策，面试的一大套路是让面试官往你铺设的道上走 如果你做的项目很多，挑最熟悉的写，难度最大的，收获成长最多的，这些你有的讲 一般挑两到三个细写就可以了 基本技能这个常规写就好，不要太夸张，也不要太笼统，一句熟悉C、C++、Java，就没有展开了，可以稍微具体一点 获奖经历、科研成果挑重点写，获奖经历最好写含金量比较大的，小规模的比赛其实没必要写，奖学金的话可以写国奖，校级院级的个人觉得也没什么必要，有论文专利之类要写上 自我评价这块其实是最虚的东西，写得好与坏差距挺大的，但基本套话比较多，所以自己衡量 自我评价真的很虚，写得好和坏差距挺大的，如果你觉得写得好的，往上放，这是亮点]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12+Swift4+Xcode10开发 - 4 元气天气APP]]></title>
    <url>%2F2019%2F01%2F06%2FIOS12%2BSwift4%2BXcode10%E5%BC%80%E5%8F%91%20-%20%205%20%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95APP%2F</url>
    <content type="text"><![CDATA[项目介绍 需求分析iOS原生风格的极简的日程管理工具。 现在大部分的Todo工具：UI设计趋向于小清新、可爱动画等多元设计；功能为可以记录时间、地点、时间重要程度等信息，这样对于提高了增加任务的时间、精力成本。 本APP主打的就是：界面使用iOS原生峰哥，功能就是随时想到、随时记录。 功能：用户可以对待办事项输入、修改、删除、修改顺序操作，可以标记已经完成任务。 举例一个使用场景：午餐时想到了一个idea直接打开APP记录、午睡后想到这个idea的实现可直接修改，晚上实现该功能后直接打钩，第二天测试人员告知该idea可行时删除任务。 功能需求浏览任务页面：可以在tableview查看所有任务及其完成状态；可以在编辑状态下批量删除任务、移动任务顺序；按下navigation的+进入添加任务页面；按下&gt;进入修改任务页面。 添加修改页面：判断当前任务是添加还是修改。使用自定义protocol和delegate反向传值，将文字传回浏览页面。 遇到的困难知识点TableView的使用1.我们知道tableView是IOS中的高级视图，其继承与ScrollView，具有ScrollView的功能，还扩展了许多。 2.tableView的表现格式分两种Plain和Grouped两种风格 3.tableView的两种代理类delegate和dataSource.这两种代理至关重要，我们在做tableView和这些代理是分不开的。 4.代理中比较常用的代理方法： (1)dataSource的两个必须使用的代理 显示UITableView的Cell的个数：一共有多少个格子 Cell和model的数据的交互：根据数据，获取每一个数据的值 5.增删改查需要做的：第一步获取需要操作的行数（增加不需要），第二步对数据库进行处理，第三部更新视图 6.更新视图的2种方式：beginUpdates、endUpdates之前操作（如一行一行的删除数据）；tableView.reloadData()刷新TableView了。 在使用数据库之后，我就直接reloadData()刷新TableView了。比较方便 123456// 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() Navigation使用，sugue实现跳转常用控件：相当于一个扑克盒子，里面的页面是出栈和入栈来实现试图切换。 利用segue界面跳转一共有两种方式： 第一种就是以上我的例子，利用button组件，拖拽添加segue，直接运行就可以用。 第二种是利用ViewController与ViewController之间，拖拽添加segue。不过，这种方法就需要在相应需要跳转的方法内写入代码，手动去设置它的跳转。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： 项目布局UI设计页面一页面二步骤配置tableview数据重用单元格的形式，数据成千上万行，最终渲染个数为屏幕上显示的数目。 往下拉的时候，最上面的cell到最下面来，放置重复渲染，提高手机性能。 使用tableview cellCell定一个class为TodoCell，Cell使用as!强制转换为TodoCell。 model结构体使用Struct初探结构体：不需要写初始化构造器，直接可以构造出来；轻量级的class indexPath动态配置每行数据确定位置：第几行indexPath.row、第几段indexPath.session cell切换打勾和取消使用static单元格，grouped风格。 navigation controller压栈(入栈)和出栈navigation controller类似扑克盒子 跳转实现 主页面标题设置为大标题，需要在选中navigation页面，设置大标题 新页面需要设置小标题，添加item当做标题，再修改名称，改为大标题为never 返回按钮的名称需要在页面一的任务清单UINavigationItem中修改 添加任务功能✨流程如下： 使用：(自定义protocol和delegate反向传值)+出栈 添加新任务：反向传值 确定之后页面消失：出栈，navigation老大让他出栈 编辑任务✨1 正向传值segue将选中的cell中的（1 任务文本todo；2选中的行数row）传到编辑页面 2 编辑页面根据输入框判断是否有文本，定下title。若不为空，title为编辑任务；为空title为添加任务 3 修改后按下navigate bar button确认后，将（1修改后的文字；2之前选中的行数）传回主页面 4 主页面中实现协议的函数中：修改mode数组中的数据，根据行数row找到cell，再将cell的文字改为新的任务 左滑删除已经预置代码，直接取消注释； 添加上删除某一行的数据； 更新页面已经写了，不需要添加。 批量选择+批量删除navigation自带了添加编辑button的代码，取消注释，将button改到左边即可，还需要批量功能 由于需要批量的对象是table view，选中他，找到edit选择multiple 编辑即可 实现批量选中的效果： 批量删除需要重新放一个”删除“按钮； 在按下按钮后：获取选中的indexPath存储于数组，通过循环删除数据对应行数indexPath.row，使用table view的delete方法删除存于数组中的行数 1234567891011121314// 获取所有被选中的indexPath，若为空则不进行删除操作if let indexPaths = tableView.indexPathsForSelectedRows&#123; //1 Model 数据删除 for indexPath in indexPaths&#123; todos.remove(at: indexPath.row) &#125; //2 View 视图更新—— table View的删除方法 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能 tableView.beginUpdates() tableView.deleteRows(at: indexPaths, with: .automatic) tableView.endUpdates() // 方式二：从新load数据更新页面；但没有动画效果 //tableView.reloadData()&#125; ps 更新视图 // 方式一：把批量对视图的操作防在两句话中间，可以提高app的性能tableView.beginUpdates()// codestableView.endUpdates()// 方式二：从新load数据更新页面；但没有动画效果 —— 就是相当于执行 cell for row的方法，将结果取出来，再更新视图//tableView.reloadData() 发现无法选择，原因是：原先的设置选择后，立即变成未选中状态，使得页面保持白色，不会保持变成灰色。需要：在原先的选择代码中，使用flag——isEditing，判断若在editing状态，则可以选中、打钩等一系列操作。 1234// 如果不是在编辑的情况下，选择打勾才有用、取消选中等才有用 if !isEditing&#123; //选择的代码——选择后原数据状态改变、重新mark为相反的、判断mark绘制√，取消选择背景变回白色 &#125; 按钮的默认文字汉化左滑时候的delete —— 变成 ”删除“的关键词：tableView、title、delete、button后出现需要重写的方法 批量选择edit、done改成中文——1 通过command+点击获取方法、2通过三元运算符+isEditing确认是”编辑“还是”确定“ 移动单元格已有该方法，重写to support rearranging the table view 首先使用临时变量temp交换两个数据，接着更新视图moveRow（不写这一句也可以移动，即自动调用）。 但是这里存在一个小bug，当编辑状态下，当选中数据，被移动后，该数据将一直处于选中状态，且无法删除。结局方法为：移动数据后，reloadData，取消选中状态，就不会导致setEditing函数自动调用该函数，导致混乱。 1234567891011121314// 移动单元格功能// Override to support rearranging the table view.override func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to: IndexPath) &#123; // 1 移动数据 let temp = todos[fromIndexPath.row] todos[fromIndexPath.row] = todos[to.row] todos[to.row] = temp print(todos) // 2 更新数据:自动更新,可以不用下面的代码 tableView.moveRow(at: fromIndexPath, to: to) // 3 移动后，刷新 tableView.reloadData()&#125; 简单数据存储userDefaultsAppDelegate文件+轻量级本地存储userDefaults+编码解码 1 AppDelegate文件：APP的声明周期：打开：APP启动、激活 按下home健：由于某种原因被挤到后台、进入后台 再次进入：即将激活、激活 退出：（APPlist 中）进入后台、（退出后）完全退出 2 数据数据存储在沙盒里面，信息安全，本APP只能访问本APP的数据 沙盒数据中只能存储基本的数据类型，我们的数据是存储对象的Array，无法存储进沙盒plist，因此需要写一个存储函数来编码数据为.data 3 使用userDefaults写好储存数据的方法（编码为data格式+存入沙盒）和解码方法（通过forKey获取数据，解码至todos数组）： 1234567891011121314151617181920212223242526// 数据存储——编码数据func saveData()&#123; // 可能会抛出错误 do&#123; // 编码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 let data = try JSONEncoder().encode(todos) // 得到data类型的数据，存入沙盒 UserDefaults.standard.set(data, forKey: "todos") &#125;catch&#123; print(error) &#125;&#125;//取数据——解码func getData()&#123; // 获得data类型的数据，由于可能为空，则使用if let：不为空的时候获取本地数据，为空则不获取 if let data = UserDefaults.standard.data(forKey: "todos") &#123; // 解码固定格式 do&#123; // 解码的固定格式 —— 创建一个编码器(JSONENcoder)——要在model中遵守协议使对象可编码 todos = try JSONDecoder().decode([Todo].self, from: data) &#125;catch&#123; print(error) &#125; &#125;&#125; 再把写数据的函数在所有操作数据处理调用； 在程序load时候调用取数据。 本地存储coredata和realm了解cs和bs+什么是数据库+为什么App需要本地存储 cs：client-server —— QQ、微信——聊天记录存在本机 bs：browser-sever —— 网页论坛——数据存储在服务器 IOS本地存储数据库： userdefaults——轻量级的数据 coredata——苹果自带的，学习成本高，代码多、不够快——了解 realm：速度快 realm安装与示例使用由于cocoapods无法pod，我选择下载安装法，自行配置： 先去 Realm 的官网去下载最新框架： https://realm.io/cn/docs/swift/latest/#prerequisites 接着拖拽 RealmSwift.framework 和 Realm.framework 文件到”Embedded Binaries”选项中。选中 Copy items if needed 并点击 Finish 寻找应用的 Realm 文件：Swift using Realm Swift:(lldb) po Realm.Configuration.defaultConfiguration.fileURL command+shift+g ：跳转窗口，进入沙盒 在model中新建模型User.swift，import包，定义模型 1234567import Foundationimport RealmSwift// 定义模型的做法和定义常规 Swift 类的做法类似class User: Object &#123; @objc dynamic var name = "" @objc dynamic var age = 0&#125; 进入AppDelegate，找到启动的方法，在该方法中： 1 数据实例化 do - catch中 2 创建数据库、3 存储数据 1234567891011121314151617181920212223func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. print("APP启动") // 0 输出沙盒地址 print(Realm.Configuration.defaultConfiguration.fileURL) // 1 实例化需要存储数据 —— 实例化user对象 let user = User() user.name = "Iris" user.age = 18 do&#123; // 2 创建一个数据库 let realm = try Realm() // 3将对象存入数据库 try realm.write &#123; realm.add(user) &#125; &#125;catch&#123; print(error) &#125; return true&#125; 查看数据：print(Realm.Configuration.defaultConfiguration.fileURL) command+shift+g ：输入得到的地址，跳转窗口，进入沙盒，查看的结果 realm操作1 在主页面处实例化数据库，为全局变量123// 使用数据库后，todo相当于一个中间人的角色// 实例化realm数据库 —— 强制try，确定不会出异常 （一般不这样写，可能会出现网络等异常）let realm = try! Realm() 2 创建RealmSwift的类 class Todo1234567import Foundationimport RealmSwift//定义模型的做法和定义常规 Swift 类的做法类似class Todo: Object &#123; @objc dynamic var name = "" @objc dynamic var checked = false&#125; 2 写数据新增数据功能： 新增数据后，创建一个类Todo的todo对象，传入saveData 3 取数据现在viewLoad()的时候，读取数据。发现需要results类型，所以下一步更改todos的类型 12// 从Realm数据库中读取数据 todos = realm.objects(Todo.self) 声明todos由数组类型改为复合类型，接受取出来的 result array的数据，定义为可选性，可能为空 123456789//定义为esults类型todos -- 定义复合数据类型 -- 名字:复合类型&lt;类型&gt; ——1种方式var todos: Results&lt;Todo&gt;? //定义空数组L：需要指明数组内存的类型。—— 3种方式//var Todos: Array&lt;Todo&gt;=[]//var todos:[Todo] = []//var todos = [Todo]()//定义空字典的方法：指明key和value的类型; [:]表明m空字典。—— 2 种方式//var dict:[String:Any] = [:]//var dict = [String:Any]() 可选性（todos为空），则初始的时候判断。 为此，进行初始判断：当todos取出来为空的时候，数组的行数为0，且出现文字——请添加任务 12345678910111213141516171819// 二、每段有几行：第i个session的行数override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows // todos?.count ：?表示，该符号前面为空，则不执行后面的，整个则为 nil // 空合运算符 xxx ?? ooo ,xxx为空，则执行ooo // 若tosos为空，则ession的行数 返回1 return todos?.count ?? 0&#125;// 三、每行显示什么override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 想要用到的到TodoCell下面的属性，向下z强制转型 let cell = tableView.dequeueReusableCell(withIdentifier: "todo", for: indexPath) as! TodoCell // 若取出的todos不为空，我们赋值给 这里的todos，可以在下面用 if let todos = todos&#123; //确定位置 第几行indexPath.row、第几段indexPath.session // Configure the cell... cell.todo.text = todos[indexPath.row].name cell.checkMark.text = todos[indexPath.row].checked ? "✓" : " " &#125; 在存储数据的时候，把更新页面直接改为reload()方法。 修改数据1 修改任务部分 ：获取当前行数，修改todos![indexPath.row].name = name；更新视图 2 状态更改部分：按下，状态取反，修改todos![indexPath.row].checked =取反；更新视图 删数据删除数据 更新视图 12345678910111213// Override to support editing the table view.override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; // 数据操作 do&#123; try realm.write &#123; realm.delete(todos![indexPath.row]) &#125; &#125;catch&#123; print(error) &#125; // 更新视图 tableView.reloadData()&#125; Realm-搜索和排序+searchBar+收起软键盘+主线程点击search bar 搜索，发生什么事情。 想到需要一个delegate协议。先遵守协议UISearchBarDelegate，再委托。告诉Todos Controller，search bar是老板（委托人），一会他有些申请会委托给controller做。 12345678910111213// 实现搜索功能// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 todos = todosData.filter("name CONTAINS %@", searchBar.text!) // 2 更新视图 tableView.reloadData()&#125; 当searchBar内容改变的时候，查看其是否为空，若为空，则‘’‘ 搜索之后，根据创建时间排序。先在class 中添加时间属性为当前时间，搜索的时候按照时间倒叙： 123456789101112// 实现searchBar委托给todosController干的事情func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; // 1.1 从数据库获取所有的数据 let todosData = realm.objects(Todo.self) // 1.2 从所有数据中获取查询后的数据 // predicate——断言——规定怎么查询 // name 中包含 %@ 占位符 _ searchBar.text!强制解包 // 排序：时间倒叙 todos = todosData.filter("name CONTAINS %@", searchBar.text!).sorted(byKeyPath: "createdAT", ascending: false) // 2 更新视图 tableView.reloadData()&#125; 未完成： //需求：打√之后，就放置在最后，取消打钩，放置在最前 源码12]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发 - 老虎机]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E5%BC%80%E5%8F%91%20-%20%E8%80%81%E8%99%8E%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[老虎机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package test.iris; import java.awt.Color; import java.awt.FlowLayout;import java.awt.Font;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Random; import javax.swing.BorderFactory;import javax.swing.ImageIcon;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.SwingConstants;import javax.swing.border.EmptyBorder; public class UI extends JFrame&#123; private static UI ui = null; static String[] paths = &#123; "1.png", "2.png", "3.png" &#125;; private MyLabel labelLeft = new MyLabel(paths[0], 0);// 左图 private MyLabel labelCenter = new MyLabel(paths[1], 1);// 中图 private MyLabel labelRight = new MyLabel(paths[2], 2);// 右图 private JButton button = new JButton("开始");// 开始按钮 private JLabel labelMessage = new JLabel("");// 结果标签 private UI() &#123; setTitle("老虎机"); setBounds(200, 200, 500, 500); JPanel panel = new JPanel(); setContentPane(panel); panel.setLayout(new GridLayout(3, 1)); panel.setBorder(new EmptyBorder(50, 50, 50, 50)); // 上中下三块面板 JPanel panelTop = new JPanel(); JPanel panelCenter = new JPanel(); JPanel panelBottom = new JPanel(); panel.add(panelTop); panel.add(panelCenter); panel.add(panelBottom); // 三张图片显示区域 panelTop.setLayout(new FlowLayout()); panelTop.add(labelLeft); panelTop.add(labelCenter); panelTop.add(labelRight); // 开始按钮面板 panelCenter.setLayout(new GridLayout(1, 1)); panelCenter.setBorder(new EmptyBorder(30, 100, 30, 100)); button.addActionListener(new MyListener()); panelCenter.add(button); // 抽奖结果面板 panelBottom.setLayout(new GridLayout(1, 1)); labelMessage.setBorder(BorderFactory.createLineBorder(Color.BLACK)); labelMessage.setFont(new Font("微软雅黑",0 , 40)); labelMessage.setForeground(Color.red); labelMessage.setHorizontalAlignment(SwingConstants.CENTER); panelBottom.add(labelMessage); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setVisible(true); &#125; public static UI getInstance() &#123; return UI.ui; &#125; public static String[] getPaths() &#123; return paths; &#125; public MyLabel getLabelLeft() &#123; return labelLeft; &#125; public MyLabel getLabelCenter() &#123; return labelCenter; &#125; public MyLabel getLabelRight() &#123; return labelRight; &#125; public JButton getButton() &#123; return button; &#125; public JLabel getLabelMessage() &#123; return labelMessage; &#125; public static void main(String[] args) &#123; UI.ui = new UI(); &#125;&#125; class MyListener implements ActionListener&#123; private boolean buttonFlag = false;// 按钮点击状态，默认未点击 public static boolean threadFlag = true;//线程中断标志 @Override public void actionPerformed(ActionEvent e) &#123; UI ui = UI.getInstance(); JButton button = ui.getButton(); JLabel labelMessage = ui.getLabelMessage(); MyLabel labelLeft = ui.getLabelLeft(); MyLabel labelCenter = ui.getLabelCenter(); MyLabel labelRight = ui.getLabelRight(); if (buttonFlag) &#123; threadFlag = false; buttonFlag = false; button.setText("开始"); synchronized (labelLeft) //等待三个线程释放锁 &#123; synchronized (labelCenter) &#123; synchronized (labelRight) &#123; int leftId = labelLeft.getId(); int centerId = labelCenter.getId(); int rightId = labelRight.getId(); String result = getResult(leftId, centerId, rightId); labelMessage.setText(result); &#125; &#125; &#125; &#125; else &#123; threadFlag = true; buttonFlag = true; new MyThread(220, labelLeft).start(); new MyThread(150, labelCenter).start(); new MyThread(60, labelRight).start(); labelMessage.setText(""); button.setText("暂停"); &#125; &#125; public static String getResult(int leftId, int centerId, int rightId) &#123; String result = null; if (leftId == centerId &amp; leftId == rightId) result = "一等奖"; else if (leftId == centerId || leftId == rightId || centerId == rightId) result = "二等奖"; else result = "未中奖"; return result; &#125;&#125; class MyLabel extends JLabel&#123; private int id;// 标签id public MyLabel(String path, int id) &#123; ImageIcon icon = new ImageIcon(path); setIcon(icon); this.id = id; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; class MyThread extends Thread&#123; private long time; private MyLabel label; private Random random = new Random(); public MyThread(long time, MyLabel label) &#123; this.time = time; this.label = label; &#125; @Override public void run() &#123; synchronized (label) //锁住lable对象 &#123; while (MyListener.threadFlag) &#123; try &#123; Thread.sleep(time); int id = random.nextInt(3); label.setId(id); ImageIcon icon = new ImageIcon(UI.paths[id]); label.setIcon(icon); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的简历V1]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[教育经历2017.09 - 2020.06 硕士 中南大学 计算机科学与技术 专业排名未知研究方向：可视化与可视分析、高维数据可视分析。成果：发表专利一项、参与发表A类论文一篇、主持中南大学研究生自主探索项目一项 2013.09 - 2017.06 本科 中南大学 计算机科学与技术 专业排名1%~5%保研本校研究生；国家励志奖学金、中南大学大学生关怀奖学金、班长奖学金、学年一等学金；“优秀毕业生”；多次获“优秀学生”、“优秀团员”、“优秀学生干部”；校运会跨栏金牌 学术研究 “基于强声凝聚的PM2.5减排装置的复合式消声系统”专利 参与论文被A类会议IEEE Visualization Conference接受，现已推荐发表在《IEEE Transactions on Visualization and Computer Graphics》期刊 项目经历2019.01 - 2019.02 iOS——元气天气APP 项目负责人需求：展示当地天气、查询异地天气的时看到正能量文字，元气满满的开始新的一天。 实现：采用了MVC设计模式。获取当前位置的天气：利用 Cocoa 框架中的protocol-delegate设计模式，实现定位协议获得当前经纬度；Pod第三方库，使用Alamofire请求、SwiftJSON解析数据；将数据赋值给model，更新页面。查询页面跳转传值：使用segue导航正向传值，自定义protocol、委托代理delegate实现导航反向传值。 知识点：protocol-delegate、计算属性、第三方库的CocoaPods安装的使用、extension代码优化 2019.02 - 2019.03 iOS——去做吧！APP 项目负责人需求：Todo list 实现： 知识点： 2018.10 - 2018.12 Android——《延禧攻略》连连看、五子棋游戏、绘图板 项目负责人需求： 实现： 知识点： 2018.05 - 2018.08 Java——多线程弹球游戏、欢乐抽奖、AI五子棋、趣味画板 项目负责人需求： 实现： 趣味画板： 使用JPanel对主界面JFrame分区，绘制组件；为事件源（组件）上添加鼠标监听器； 重绘功能：定义shape类，绘制时将坐标、颜色存入对象，再对象存入数组；主函数继承JPanel，重写panit()函数时，绘制shapeArray[]数组中所有的Shape对象。 2018.01 - 2018.04 自由探索项目——面向高维时序数据的可视分析 项目负责人1、T LAMP在数据上应用一个滑动窗口方法，并为每个窗口计算一个一维LAMP。随后，一维LAMP映射的结果序列沿着时间轴进行排列：x轴表示时间，而y轴表示LAMP的相似性值。类似的事件随着时间的推移被聚合，分析人员可以通过视觉特征有效识别特定模式。2、为了分析高维数据中属性的性质，我们用一个序列的多元矩阵来揭示了各个属性贡献程度随时间变化。此外，我们还引入了一种新的算法，根据用户的选择来寻找相似的模式。3、对齐一维投影序列，现有大多数现有的时序数据投影方法都采用二维投影。TLAMP依赖于一维LAMP投影，利用图中的第二维度来显示高维数据随时间推移的变化。 2017.08 - 2017.08 前端项目——‘互联网+’走基层追寻红色文化”社会实践 策划、技术支持1、负责活动主题策划。活动亮点在于利用专业技术创建“红色信息平台”、科技普及2、龙洞红色旅游网站搭建、微信二维码语音导航助手3、项目新闻稿撰写，新媒体推送撰写，项目总结答辩工作成果：国家级、地区级别、校级网站报道13篇、新媒体微信推送13篇、电视台报道1次]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
</search>
